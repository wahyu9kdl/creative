<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.8 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="pre5378Trust200902" docName="draft-ietf-tls-tls13-28" category="std" obsoletes="5077, 5246, 6961" updates="4492, 5705, 6066">

  <front>
    <title abbrev="TLS">The Transport Layer Security (TLS) Protocol Version 1.3</title>

    <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
      <organization>RTFM, Inc.</organization>
      <address>
        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <date year="2018" month="March" day="20"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document specifies version 1.3 of the Transport Layer Security
(TLS) protocol.  TLS allows client/server applications to communicate
over the Internet in a way that is designed to prevent eavesdropping,
tampering, and message forgery.</t>

<t>This document updates RFCs 4492, 5705, and 6066 and it obsoletes
RFCs 5077, 5246, and 6961. This document also specifies new
requirements for TLS 1.2 implementations.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>RFC EDITOR: PLEASE REMOVE THE FOLLOWING PARAGRAPH
The source for this draft is maintained in GitHub. Suggested changes
should be submitted as pull requests at
https://github.com/tlswg/tls13-spec. Instructions are on that page as
well. Editorial changes can be managed in GitHub, but any substantive
change should be discussed on the TLS mailing list.</t>

<t>The primary goal of TLS is to provide a secure channel between two
communicating peers; the only requirement from the underlying
transport is a reliable, in-order, data stream. Specifically, the
secure channel should provide the following properties:</t>

<t><list style="symbols">
  <t>Authentication: The server side of the channel is always
authenticated; the client side is optionally
authenticated. Authentication can happen via asymmetric cryptography
(e.g., RSA <xref target="RSA"/>, ECDSA <xref target="ECDSA"/>, EdDSA <xref target="RFC8032"/>) or a pre-shared key (PSK).</t>
  <t>Confidentiality: Data sent over the channel after establishment
is only visible to the
endpoints. TLS does not hide the length of the data it transmits,
though endpoints are able to pad TLS records in order to obscure lengths
and improve protection against traffic analysis techniques.</t>
  <t>Integrity: Data sent over the channel after establishment cannot be
modified by attackers.</t>
</list></t>

<t>These properties should be true even in the face of an attacker who has complete
control of the network, as described in <xref target="RFC3552"/>.
See <xref target="security-analysis"/> for a more complete statement of the relevant security
properties.</t>

<t>TLS consists of two primary components:</t>

<t><list style="symbols">
  <t>A handshake protocol (<xref target="handshake-protocol"/>) that authenticates the communicating parties,
negotiates cryptographic modes and parameters, and establishes
shared keying material. The handshake protocol is designed to
resist tampering; an active attacker should not be able to force
the peers to negotiate different parameters than they would
if the connection were not under attack.</t>
  <t>A record protocol (<xref target="record-protocol"/>) that uses the parameters established by the
handshake protocol to protect traffic between the communicating
peers. The record protocol divides traffic up into a series of
records, each of which is independently protected using the
traffic keys.</t>
</list></t>

<t>TLS is application protocol independent; higher-level protocols can
layer on top of TLS transparently. The TLS standard, however, does not
specify how protocols add security with TLS; how to
initiate TLS handshaking and how to interpret the authentication
certificates exchanged are left to the judgment of the designers and
implementors of protocols that run on top of TLS.</t>

<t>This document defines TLS version 1.3. While TLS 1.3 is not directly
compatible with previous versions, all versions of TLS incorporate a
versioning mechanism which allows clients and servers to interoperably
negotiate a common version if one is supported by both peers.</t>

<t>This document supersedes and obsoletes previous versions of TLS
including version 1.2 <xref target="RFC5246"/>.  It also obsoletes the TLS ticket
mechanism defined in <xref target="RFC5077"/> and replaces it with the mechanism
defined in <xref target="resumption-and-psk"/>. <xref target="negotiated-groups"/> updates
<xref target="RFC4492"/> by modifying the protocol attributes used to negotiate
Elliptic Curves.  Because TLS 1.3 changes the way keys are derived, it
updates <xref target="RFC5705"/> as described in <xref target="exporters"/>.  It also changes
how OCSP messages are carried and therefore updates <xref target="RFC6066"/>
and obsoletes <xref target="RFC6961"/> as described in section <xref target="ocsp-and-sct"/>.</t>

<section anchor="conventions-and-terminology" title="Conventions and Terminology">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
when, and only when, they appear in all capitals, as shown here.</t>

<t>The following terms are used:</t>

<t>client: The endpoint initiating the TLS connection.</t>

<t>connection: A transport-layer connection between two endpoints.</t>

<t>endpoint: Either the client or server of the connection.</t>

<t>handshake: An initial negotiation between client and server that establishes the parameters of their subsequent interactions within TLS.</t>

<t>peer: An endpoint. When discussing a particular endpoint, “peer” refers to the endpoint that is not the primary subject of discussion.</t>

<t>receiver: An endpoint that is receiving records.</t>

<t>sender: An endpoint that is transmitting records.</t>

<t>server: The endpoint which did not initiate the TLS connection.</t>

</section>
<section anchor="change-log" title="Change Log">

<t>RFC EDITOR PLEASE DELETE THIS SECTION.</t>

<t>(*) indicates changes to the wire protocol which may require implementations
    to update.</t>

<t>draft-28</t>

<t>Add a section on exposure of PSK identities.</t>

<t>draft-27</t>

<t><list style="symbols">
  <t>SHOULD-&gt;MUST for being able to process “supported_versions” without
0x0304.</t>
  <t>Much editorial cleanup.</t>
</list></t>

<t>draft-26</t>

<t><list style="symbols">
  <t>Clarify that you can’t negotiate pre-TLS 1.3 with supported_versions.</t>
</list></t>

<t>draft-25</t>

<t><list style="symbols">
  <t>Add the header to additional data (*)</t>
  <t>Minor clarifications.</t>
  <t>IANA cleanup.</t>
</list></t>

<t>draft-24</t>

<t><list style="symbols">
  <t>Require that CH2 have version 0303 (*)</t>
  <t>Some clarifications</t>
</list></t>

<t>draft-23</t>

<t><list style="symbols">
  <t>Renumber key_share (*)</t>
  <t>Add a new extension and new code points to allow negotiating PSS
separately for certificates and CertificateVerify (*)</t>
  <t>Slightly restrict when CCS must be accepted to make implementation
easier.</t>
  <t>Document protocol invariants</t>
  <t>Add some text on the security of static RSA.</t>
</list></t>

<t>draft-22</t>

<t><list style="symbols">
  <t>Implement changes for improved middlebox penetration (*)</t>
  <t>Move server_certificate_type to encrypted extensions (*)</t>
  <t>Allow resumption with a different SNI (*)</t>
  <t>Padding extension can change on HRR (*)</t>
  <t>Allow an empty ticket_nonce (*)</t>
  <t>Remove requirement to immediately respond to close_notify with
close_notify (allowing half-close)</t>
</list></t>

<t>draft-21</t>

<t><list style="symbols">
  <t>Add a per-ticket nonce so that each ticket is associated with a
different PSK (*).</t>
  <t>Clarify that clients should send alerts with the handshake key
if possible.</t>
  <t>Update state machine to show rekeying events</t>
  <t>Add discussion of 0-RTT and replay. Recommend that implementations
implement some anti-replay mechanism.</t>
</list></t>

<t>draft-20</t>

<t><list style="symbols">
  <t>Add “post_handshake_auth” extension to negotiate post-handshake authentication
(*).</t>
  <t>Shorten labels for HKDF-Expand-Label so that we can fit within one
compression block (*).</t>
  <t>Define how RFC 7250 works (*).</t>
  <t>Re-enable post-handshake client authentication even when you do PSK.
The previous prohibition was editorial error.</t>
  <t>Remove cert_type and user_mapping, which don’t work on TLS 1.3 anyway.</t>
  <t>Added the no_application_protocol alert from <xref target="RFC7301"/> to the list
of extensions.</t>
  <t>Added discussion of traffic analysis and side channel attacks.</t>
</list></t>

<t>draft-19</t>

<t><list style="symbols">
  <t>Hash context_value input to Exporters (*)</t>
  <t>Add an additional Derive-Secret stage to Exporters (*).</t>
  <t>Hash ClientHello1 in the transcript when HRR is used. This
reduces the state that needs to be carried in cookies. (*)</t>
  <t>Restructure CertificateRequest to have the selectors
in extensions. This also allowed defining a “certificate_authorities”
extension which can be used by the client instead of trusted_ca_keys (*).</t>
  <t>Tighten record framing requirements and require checking of them (*).</t>
  <t>Consolidate “ticket_early_data_info” and “early_data” into a single
extension (*).</t>
  <t>Change end_of_early_data to be a handshake message (*).</t>
  <t>Add pre-extract Derive-Secret stages to key schedule (*).</t>
  <t>Remove spurious requirement to implement “pre_shared_key”.</t>
  <t>Clarify location of “early_data” from server (it goes in EE,
as indicated by the table in S 10).</t>
  <t>Require peer public key validation</t>
  <t>Add state machine diagram.</t>
</list></t>

<t>draft-18</t>

<t><list style="symbols">
  <t>Remove unnecessary resumption_psk which is the only thing expanded from
the resumption master secret. (*).</t>
  <t>Fix signature_algorithms entry in extensions table.</t>
  <t>Restate rule from RFC 6066 that you can’t resume unless SNI is the same.</t>
</list></t>

<t>draft-17</t>

<t><list style="symbols">
  <t>Remove 0-RTT Finished and resumption_context, and replace with a
psk_binder field in the PSK itself (*)</t>
  <t>Restructure PSK key exchange negotiation modes (*)</t>
  <t>Add max_early_data_size field to TicketEarlyDataInfo (*)</t>
  <t>Add a 0-RTT exporter and change the transcript for the regular exporter (*)</t>
  <t>Merge TicketExtensions and Extensions registry. Changes
ticket_early_data_info code point (*)</t>
  <t>Replace Client.key_shares in response to HRR (*)</t>
  <t>Remove redundant labels for traffic key derivation (*)</t>
  <t>Harmonize requirements about cipher suite matching: for resumption you
need to match KDF but for 0-RTT you need whole cipher suite. This
allows PSKs to actually negotiate cipher suites. (*)</t>
  <t>Move SCT and OCSP into Certificate.extensions (*)</t>
  <t>Explicitly allow non-offered extensions in NewSessionTicket</t>
  <t>Explicitly allow predicting client Finished for NST</t>
  <t>Clarify conditions for allowing 0-RTT with PSK</t>
</list></t>

<t>draft-16</t>

<t><list style="symbols">
  <t>Revise version negotiation (*)</t>
  <t>Change RSASSA-PSS and EdDSA SignatureScheme codepoints for better backwards compatibility (*)</t>
  <t>Move HelloRetryRequest.selected_group to an extension (*)</t>
  <t>Clarify the behavior of no exporter context and make it the same
as an empty context.(*)</t>
  <t>New KeyUpdate format that allows for requesting/not-requesting an
answer. This also means changes to the key schedule to support
independent updates (*)</t>
  <t>New certificate_required alert (*)</t>
  <t>Forbid CertificateRequest with 0-RTT and PSK.</t>
  <t>Relax requirement to check SNI for 0-RTT.</t>
</list></t>

<t>draft-15</t>

<t><list style="symbols">
  <t>New negotiation syntax as discussed in Berlin (*)</t>
  <t>Require CertificateRequest.context to be empty during handshake (*)</t>
  <t>Forbid empty tickets (*)</t>
  <t>Forbid application data messages in between post-handshake messages
from the same flight (*)</t>
  <t>Clean up alert guidance (*)</t>
  <t>Clearer guidance on what is needed for TLS 1.2.</t>
  <t>Guidance on 0-RTT time windows.</t>
  <t>Rename a bunch of fields.</t>
  <t>Remove old PRNG text.</t>
  <t>Explicitly require checking that handshake records not span
key changes.</t>
</list></t>

<t>draft-14</t>

<t><list style="symbols">
  <t>Allow cookies to be longer (*)</t>
  <t>Remove the “context” from EarlyDataIndication as it was undefined
and nobody used it (*)</t>
  <t>Remove 0-RTT EncryptedExtensions and replace the ticket_age extension
with an obfuscated version. Also necessitates a change to
NewSessionTicket (*).</t>
  <t>Move the downgrade sentinel to the end of ServerHello.Random
to accommodate tlsdate (*).</t>
  <t>Define ecdsa_sha1 (*).</t>
  <t>Allow resumption even after fatal alerts. This matches current
practice.</t>
  <t>Remove non-closure warning alerts. Require treating unknown alerts as
fatal.</t>
  <t>Make the rules for accepting 0-RTT less restrictive.</t>
  <t>Clarify 0-RTT backward-compatibility rules.</t>
  <t>Clarify how 0-RTT and PSK identities interact.</t>
  <t>Add a section describing the data limits for each cipher.</t>
  <t>Major editorial restructuring.</t>
  <t>Replace the Security Analysis section with a WIP draft.</t>
</list></t>

<t>draft-13</t>

<t><list style="symbols">
  <t>Allow server to send SupportedGroups.</t>
  <t>Remove 0-RTT client authentication</t>
  <t>Remove (EC)DHE 0-RTT.</t>
  <t>Flesh out 0-RTT PSK mode and shrink EarlyDataIndication</t>
  <t>Turn PSK-resumption response into an index to save room</t>
  <t>Move CertificateStatus to an extension</t>
  <t>Extra fields in NewSessionTicket.</t>
  <t>Restructure key schedule and add a resumption_context value.</t>
  <t>Require DH public keys and secrets to be zero-padded to the size
of the group.</t>
  <t>Remove the redundant length fields in KeyShareEntry.</t>
  <t>Define a cookie field for HRR.</t>
</list></t>

<t>draft-12</t>

<t><list style="symbols">
  <t>Provide a list of the PSK cipher suites.</t>
  <t>Remove the ability for the ServerHello to have no extensions
(this aligns the syntax with the text).</t>
  <t>Clarify that the server can send application data after its first
flight (0.5 RTT data)</t>
  <t>Revise signature algorithm negotiation to group hash, signature
algorithm, and curve together. This is backwards compatible.</t>
  <t>Make ticket lifetime mandatory and limit it to a week.</t>
  <t>Make the purpose strings lower-case. This matches how people
are implementing for interop.</t>
  <t>Define exporters.</t>
  <t>Editorial cleanup</t>
</list></t>

<t>draft-11</t>

<t><list style="symbols">
  <t>Port the CFRG curves &amp; signatures work from RFC4492bis.</t>
  <t>Remove sequence number and version from additional_data, which
is now empty.</t>
  <t>Reorder values in HkdfLabel.</t>
  <t>Add support for version anti-downgrade mechanism.</t>
  <t>Update IANA considerations section and relax some of the policies.</t>
  <t>Unify authentication modes. Add post-handshake client authentication.</t>
  <t>Remove early_handshake content type. Terminate 0-RTT data with
an alert.</t>
  <t>Reset sequence number upon key change (as proposed by Fournet et al.)</t>
</list></t>

<t>draft-10</t>

<t><list style="symbols">
  <t>Remove ClientCertificateTypes field from CertificateRequest
and add extensions.</t>
  <t>Merge client and server key shares into a single extension.</t>
</list></t>

<t>draft-09</t>

<t><list style="symbols">
  <t>Change to RSA-PSS signatures for handshake messages.</t>
  <t>Remove support for DSA.</t>
  <t>Update key schedule per suggestions by Hugo, Hoeteck, and Bjoern Tackmann.</t>
  <t>Add support for per-record padding.</t>
  <t>Switch to encrypted record ContentType.</t>
  <t>Change HKDF labeling to include protocol version and value lengths.</t>
  <t>Shift the final decision to abort a handshake due to incompatible
certificates to the client rather than having servers abort early.</t>
  <t>Deprecate SHA-1 with signatures.</t>
  <t>Add MTI algorithms.</t>
</list></t>

<t>draft-08</t>

<t><list style="symbols">
  <t>Remove support for weak and lesser used named curves.</t>
  <t>Remove support for MD5 and SHA-224 hashes with signatures.</t>
  <t>Update lists of available AEAD cipher suites and error alerts.</t>
  <t>Reduce maximum permitted record expansion for AEAD from 2048 to 256 octets.</t>
  <t>Require digital signatures even when a previous configuration is used.</t>
  <t>Merge EarlyDataIndication and KnownConfiguration.</t>
  <t>Change code point for server_configuration to avoid collision with
server_hello_done.</t>
  <t>Relax certificate_list ordering requirement to match current practice.</t>
</list></t>

<t>draft-07</t>

<t><list style="symbols">
  <t>Integration of semi-ephemeral DH proposal.</t>
  <t>Add initial 0-RTT support.</t>
  <t>Remove resumption and replace with PSK + tickets.</t>
  <t>Move ClientKeyShare into an extension.</t>
  <t>Move to HKDF.</t>
</list></t>

<t>draft-06</t>

<t><list style="symbols">
  <t>Prohibit RC4 negotiation for backwards compatibility.</t>
  <t>Freeze &amp; deprecate record layer version field.</t>
  <t>Update format of signatures with context.</t>
  <t>Remove explicit IV.</t>
</list></t>

<t>draft-05</t>

<t><list style="symbols">
  <t>Prohibit SSL negotiation for backwards compatibility.</t>
  <t>Fix which MS is used for exporters.</t>
</list></t>

<t>draft-04</t>

<t><list style="symbols">
  <t>Modify key computations to include session hash.</t>
  <t>Remove ChangeCipherSpec.</t>
  <t>Renumber the new handshake messages to be somewhat more
consistent with existing convention and to remove a duplicate
registration.</t>
  <t>Remove renegotiation.</t>
  <t>Remove point format negotiation.</t>
</list></t>

<t>draft-03</t>

<t><list style="symbols">
  <t>Remove GMT time.</t>
  <t>Merge in support for ECC from RFC 4492 but without explicit
curves.</t>
  <t>Remove the unnecessary length field from the AD input to AEAD
ciphers.</t>
  <t>Rename {Client,Server}KeyExchange to {Client,Server}KeyShare.</t>
  <t>Add an explicit HelloRetryRequest to reject the client’s.</t>
</list></t>

<t>draft-02</t>

<t><list style="symbols">
  <t>Increment version number.</t>
  <t>Rework handshake to provide 1-RTT mode.</t>
  <t>Remove custom DHE groups.</t>
  <t>Remove support for compression.</t>
  <t>Remove support for static RSA and DH key exchange.</t>
  <t>Remove support for non-AEAD ciphers.</t>
</list></t>

</section>
<section anchor="major-differences-from-tls-12" title="Major Differences from TLS 1.2">

<t>The following is a list of the major functional differences between
TLS 1.2 and TLS 1.3. It is not intended to be exhaustive and there
are many minor differences.</t>

<t><list style="symbols">
  <t>The list of supported symmetric algorithms has been pruned of all algorithms that
are considered legacy. Those that remain all use Authenticated Encryption
with Associated Data (AEAD) algorithms. The ciphersuite concept has been
changed to separate the authentication and key exchange mechanisms from
the record protection algorithm (including secret key length) and a hash
to be used with the key derivation function and HMAC.</t>
  <t>A 0-RTT mode was added, saving a round-trip at connection setup for
some application data, at the cost of certain security properties.</t>
  <t>Static RSA and Diffie-Hellman cipher suites have been removed;
all public-key based key exchange mechanisms now provide forward secrecy.</t>
  <t>All handshake messages after the ServerHello are now encrypted. The
newly introduced EncryptedExtension message allows various extensions
previously sent in clear in the ServerHello to also enjoy
confidentiality protection from active attackers.</t>
  <t>The key derivation functions have been re-designed. The new design allows
easier analysis by cryptographers due to their improved key separation
properties. The HMAC-based Extract-and-Expand Key Derivation Function (HKDF)
is used as an underlying primitive.</t>
  <t>The handshake state machine has been significantly restructured to
be more consistent and to remove superfluous messages such as
ChangeCipherSpec (except when needed for middlebox compatibility).</t>
  <t>Elliptic curve algorithms are now in the base spec and new signature
algorithms, such as ed25519 and ed448, are included. TLS 1.3 removed point format
negotiation in favor of a single point format for each curve.</t>
  <t>Other cryptographic improvements including the removal of compression and
custom DHE groups, changing the RSA padding to use RSASSA-PSS, and the removal of
DSA.</t>
  <t>The TLS 1.2 version negotiation mechanism has been deprecated in favor
of a version list in an extension. This increases compatibility with
existing servers that incorrectly implemented version negotiation.</t>
  <t>Session resumption with and without server-side state as well as the
PSK-based ciphersuites of earlier TLS versions have been replaced by a
single new PSK exchange.</t>
  <t>Updated references to point to the updated versions of RFCs, as
appropriate (e.g., RFC 5280 rather than RFC 3280).</t>
</list></t>

</section>
<section anchor="updates-affecting-tls-12" title="Updates Affecting TLS 1.2">

<t>This document defines several changes that optionally affect
implementations of TLS 1.2, including those which do not also
support TLS 1.3:</t>

<t><list style="symbols">
  <t>A version downgrade protection mechanism is described in <xref target="server-hello"/>.</t>
  <t>RSASSA-PSS signature schemes are defined in <xref target="signature-algorithms"/>.</t>
  <t>The “supported_versions” ClientHello extension can be used to negotiate
the version of TLS to use, in preference to the legacy_version field of
the ClientHello.</t>
  <t>The “signature_algorithms_cert” extension allows a client to indicate
which signature algorithms it can validate in X.509 certificates</t>
</list></t>

<t>Additionally, this document clarifies some compliance requirements for earlier
versions of TLS; see <xref target="protocol-invariants"/>.</t>

</section>
</section>
<section anchor="protocol-overview" title="Protocol Overview">

<t>The cryptographic parameters used by the secure channel are produced by the
TLS handshake protocol. This sub-protocol of TLS is used by the client
and server when first communicating with each other.
The handshake protocol allows peers to negotiate a protocol version,
select cryptographic algorithms, optionally authenticate each other,
and establish shared secret keying material.
Once the handshake is complete, the peers use the established keys
to protect the application layer traffic.</t>

<t>A failure of the handshake or other protocol error triggers the
termination of the connection, optionally preceded by an alert message
(<xref target="alert-protocol"/>).</t>

<t>TLS supports three basic key exchange modes:</t>

<t><list style="symbols">
  <t>(EC)DHE (Diffie-Hellman over either finite fields or elliptic curves)</t>
  <t>PSK-only</t>
  <t>PSK with (EC)DHE</t>
</list></t>

<t><xref target="tls-full"/> below shows the basic full TLS handshake:</t>

<figure title="Message flow for full TLS Handshake" anchor="tls-full"><artwork><![CDATA[
       Client                                               Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*         -------->
                                                       ServerHello  ^ Key
                                                      + key_share*  | Exch
                                                 + pre_shared_key*  v
                                             {EncryptedExtensions}  ^  Server
                                             {CertificateRequest*}  v  Params
                                                    {Certificate*}  ^
                                              {CertificateVerify*}  | Auth
                                                        {Finished}  v
                                 <--------     [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}                -------->
       [Application Data]        <------->      [Application Data]

              +  Indicates noteworthy extensions sent in the
                 previously noted message.

              *  Indicates optional or situation-dependent
                 messages/extensions that are not always sent.

              {} Indicates messages protected using keys
                 derived from a [sender]_handshake_traffic_secret.

              [] Indicates messages protected using keys
                 derived from [sender]_application_traffic_secret_N
]]></artwork></figure>

<t>The handshake can be thought of as having three phases (indicated
in the diagram above):</t>

<t><list style="symbols">
  <t>Key Exchange: Establish shared keying material and select the
 cryptographic parameters. Everything after this phase is
 encrypted.</t>
  <t>Server Parameters: Establish other handshake parameters
 (whether the client is authenticated, application layer protocol support, etc.).</t>
  <t>Authentication: Authenticate the server (and optionally the client)
 and provide key confirmation and handshake integrity.</t>
</list></t>

<t>In the Key Exchange phase, the client sends the ClientHello
(<xref target="client-hello"/>) message, which contains a random nonce
(ClientHello.random); its offered protocol versions; a list of
symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key shares (in the
“key_share” extension <xref target="key-share"/>), a set of pre-shared key labels (in the
“pre_shared_key” extension <xref target="pre-shared-key-extension"/>) or both; and
potentially additional extensions.  Additional fields and/or messages
may also be present for middlebox compatibility.</t>

<t>The server processes the ClientHello and determines the appropriate
cryptographic parameters for the connection. It then responds with its
own ServerHello (<xref target="server-hello"/>), which indicates the negotiated connection
parameters. The combination of the ClientHello
and the ServerHello determines the shared keys. If (EC)DHE
key establishment is in use, then the ServerHello
contains a “key_share” extension with the server’s ephemeral
Diffie-Hellman share; the server’s share MUST be in the same group as one of the
client’s shares. If PSK key establishment is
in use, then the ServerHello contains a “pre_shared_key”
extension indicating which of the client’s offered PSKs was selected.
Note that implementations can use (EC)DHE and PSK together, in which
case both extensions will be supplied.</t>

<t>The server then sends two messages to establish the Server Parameters:</t>

<t><list style="hanging">
  <t hangText='EncryptedExtensions:'>
  responses to ClientHello extensions that are not required to
determine the cryptographic parameters, other than those
that are specific to individual certificates. [<xref target="encrypted-extensions"/>]</t>
  <t hangText='CertificateRequest:'>
  if certificate-based client authentication is desired, the
desired parameters for that certificate. This message is
omitted if client authentication is not desired. [<xref target="certificate-request"/>]</t>
</list></t>

<t>Finally, the client and server exchange Authentication messages. TLS
uses the same set of messages every time that certificate-based
authentication is needed.  (PSK-based authentication happens as a side
effect of key exchange.)
Specifically:</t>

<t><list style="hanging">
  <t hangText='Certificate:'>
  the certificate of the endpoint and any per-certificate extensions.
This message is omitted by the server if not authenticating with a
certificate and by the client if the server did not send
CertificateRequest (thus indicating that the client should not
authenticate with a certificate). Note that if raw
public keys <xref target="RFC7250"/> or the cached information extension
<xref target="RFC7924"/> are in use, then this message will not
contain a certificate but rather some other value corresponding to
the server’s long-term key.  [<xref target="certificate"/>]</t>
  <t hangText='CertificateVerify:'>
  a signature over the entire handshake using the private key
corresponding to the public key in the Certificate message. This
message is omitted if the endpoint is not authenticating via a
certificate. [<xref target="certificate-verify"/>]</t>
  <t hangText='Finished:'>
  a MAC (Message Authentication Code) over the entire handshake.
This message provides key confirmation, binds the endpoint’s identity
to the exchanged keys, and in PSK mode
also authenticates the handshake. [<xref target="finished"/>]</t>
</list></t>

<t>Upon receiving the server’s messages, the client responds with its Authentication
messages, namely Certificate and CertificateVerify (if requested), and Finished.</t>

<t>At this point, the handshake is complete, and the client and server
derive the keying material required by the record layer to exchange
application-layer data protected through authenticated encryption.
Application data MUST NOT be sent prior to sending the Finished message,
except as specified
in [<xref target="zero-rtt-data"/>].
Note that while the server may send application data prior to receiving
the client’s Authentication messages, any data sent at that point is,
of course, being sent to an unauthenticated peer.</t>

<section anchor="incorrect-dhe-share" title="Incorrect DHE Share">

<t>If the client has not provided a sufficient “key_share” extension (e.g., it
includes only DHE or ECDHE groups unacceptable to or unsupported by the
server), the server corrects the mismatch with a HelloRetryRequest and
the client needs to restart the handshake with an appropriate
“key_share” extension, as shown in Figure 2.
If no common cryptographic parameters can be negotiated,
the server MUST abort the handshake with an appropriate alert.</t>

<figure title="Message flow for a full handshake with mismatched parameters" anchor="tls-restart"><artwork><![CDATA[
         Client                                               Server

         ClientHello
         + key_share             -------->
                                                   HelloRetryRequest
                                 <--------               + key_share
         ClientHello
         + key_share             -------->
                                                         ServerHello
                                                         + key_share
                                               {EncryptedExtensions}
                                               {CertificateRequest*}
                                                      {Certificate*}
                                                {CertificateVerify*}
                                                          {Finished}
                                 <--------       [Application Data*]
         {Certificate*}
         {CertificateVerify*}
         {Finished}              -------->
         [Application Data]      <------->        [Application Data]
]]></artwork></figure>

<t>Note: The handshake transcript incorporates the initial
ClientHello/HelloRetryRequest exchange; it is not reset with the new
ClientHello.</t>

<t>TLS also allows several optimized variants of the basic handshake, as
described in the following sections.</t>

</section>
<section anchor="resumption-and-psk" title="Resumption and Pre-Shared Key (PSK)">

<t>Although TLS PSKs can be established out of band,
PSKs can also be established in a previous connection and
then used to establish a new connection (“session resumption” or “resuming” with a PSK).
Once a handshake has completed, the server can
send to the client a PSK identity that corresponds to a unique key derived from
the initial handshake (see <xref target="NSTMessage"/>). The client
can then use that PSK identity in future handshakes to negotiate the use
of the associated PSK. If the server accepts the PSK, then the security context of the
new connection is cryptographically tied to the original connection and the key derived
from the initial handshake is used to bootstrap the cryptographic state
instead of a full handshake.
In TLS 1.2 and below, this functionality was provided by “session IDs” and
“session tickets” <xref target="RFC5077"/>. Both mechanisms are obsoleted in TLS 1.3.</t>

<t>PSKs can be used with (EC)DHE key exchange in order to provide forward
secrecy in combination with shared keys, or can be used alone, at the
cost of losing forward secrecy for the application data.</t>

<t><xref target="tls-resumption-psk"/> shows a pair of handshakes in which the first establishes
a PSK and the second uses it:</t>

<figure title="Message flow for resumption and PSK" anchor="tls-resumption-psk"><artwork><![CDATA[
       Client                                               Server

Initial Handshake:
       ClientHello
       + key_share               -------->
                                                       ServerHello
                                                       + key_share
                                             {EncryptedExtensions}
                                             {CertificateRequest*}
                                                    {Certificate*}
                                              {CertificateVerify*}
                                                        {Finished}
                                 <--------     [Application Data*]
       {Certificate*}
       {CertificateVerify*}
       {Finished}                -------->
                                 <--------      [NewSessionTicket]
       [Application Data]        <------->      [Application Data]


Subsequent Handshake:
       ClientHello
       + key_share*
       + pre_shared_key          -------->
                                                       ServerHello
                                                  + pre_shared_key
                                                      + key_share*
                                             {EncryptedExtensions}
                                                        {Finished}
                                 <--------     [Application Data*]
       {Finished}                -------->
       [Application Data]        <------->      [Application Data]
]]></artwork></figure>

<t>As the server is authenticating via a PSK, it does not send a
Certificate or a CertificateVerify message. When a client offers resumption
via PSK, it SHOULD also supply a “key_share” extension to the server to
allow the server to decline resumption and fall back
to a full handshake, if needed. The server responds with a “pre_shared_key”
extension to negotiate use of PSK key establishment and can (as shown here)
respond with a “key_share” extension to do (EC)DHE key establishment, thus
providing forward secrecy.</t>

<t>When PSKs are provisioned out of band, the PSK identity and the KDF hash
algorithm to
be used with the PSK MUST also be provisioned.</t>

<t><list style="hanging">
  <t hangText='Note:'>
  When using an out-of-band provisioned pre-shared secret, a critical
consideration is using sufficient entropy during the key generation, as
discussed in <xref target="RFC4086"></xref>. Deriving a shared secret from a password or other
low-entropy sources is not secure. A low-entropy secret, or password, is
subject to dictionary attacks based on the PSK binder.  The specified PSK
authentication is not a strong password-based authenticated key exchange even
when used with Diffie-Hellman key establishment.  Specifically, it does not
prevent an attacker that can observe the handshake from performing
a brute-force attack on the password/pre-shared key.</t>
</list></t>

</section>
<section anchor="zero-rtt-data" title="0-RTT Data">

<t>When clients and servers share a PSK (either obtained externally or
via a previous handshake), TLS 1.3 allows clients to send data on the
first flight (“early data”). The client uses the PSK to authenticate
the server and to encrypt the early data.</t>

<t>As shown in <xref target="tls-0-rtt"/>, the 0-RTT data is just added to the 1-RTT
handshake in the first flight. The rest of the handshake uses the same messages
as for a 1-RTT handshake with PSK resumption.</t>

<figure title="Message flow for a zero round trip handshake" anchor="tls-0-rtt"><artwork><![CDATA[
         Client                                               Server

         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     -------->
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 <--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              -------->
         [Application Data]      <------->        [Application Data]

               +  Indicates noteworthy extensions sent in the
                  previously noted message.

               *  Indicates optional or situation-dependent
                  messages/extensions that are not always sent.

               () Indicates messages protected using keys
                  derived from client_early_traffic_secret.

               {} Indicates messages protected using keys
                  derived from a [sender]_handshake_traffic_secret.

               [] Indicates messages protected using keys
                  derived from [sender]_application_traffic_secret_N
]]></artwork></figure>

<t>IMPORTANT NOTE: The security properties for 0-RTT data are weaker than
those for other kinds of TLS data.  Specifically:</t>

<t><list style="numbers">
  <t>This data is not forward secret, as it is encrypted solely under
keys derived using the offered PSK.</t>
  <t>There are no guarantees of non-replay between connections.
Protection against replay for ordinary TLS 1.3 1-RTT data is
provided via the server’s Random value, but 0-RTT data does not depend
on the ServerHello and therefore has weaker guarantees.  This is especially
relevant if the data is authenticated either with TLS client
authentication or inside the application protocol. The same warnings
apply to any use of the early_exporter_master_secret.</t>
</list></t>

<t>0-RTT data cannot be duplicated within a connection (i.e., the server will
not process the same data twice for the same connection) and an
attacker will not be able to make 0-RTT data appear to be 1-RTT data
(because it is protected with different keys.) <xref target="replay-0rtt"/>
contains a description of potential attacks and <xref target="anti-replay"/>
describes mechanisms which the server can use to limit the impact of
replay.</t>

</section>
</section>
<section anchor="presentation-language" title="Presentation Language">

<t>This document deals with the formatting of data in an external representation.
The following very basic and somewhat casually defined presentation syntax will
be used.</t>

<section anchor="basic-block-size" title="Basic Block Size">

<t>The representation of all data items is explicitly specified. The basic data
block size is one byte (i.e., 8 bits). Multiple byte data items are
concatenations of bytes, from left to right, from top to bottom. From the byte
stream, a multi-byte item (a numeric in the example) is formed (using C
notation) by:</t>

<figure><artwork><![CDATA[
   value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
           ... | byte[n-1];
]]></artwork></figure>

<t>This byte ordering for multi-byte values is the commonplace network byte order
or big-endian format.</t>

</section>
<section anchor="miscellaneous" title="Miscellaneous">

<t>Comments begin with “/*” and end with “*/”.</t>

<t>Optional components are denoted by enclosing them in “[[ ]]” double
brackets.</t>

<t>Single-byte entities containing uninterpreted data are of type
opaque.</t>

<t>A type alias T’ for an existing type T is defined by:</t>

<figure><artwork><![CDATA[
   T T';
]]></artwork></figure>

</section>
<section anchor="numbers" title="Numbers">

<t>The basic numeric data type is an unsigned byte (uint8). All larger numeric
data types are formed from fixed-length series of bytes concatenated as
described in <xref target="basic-block-size"/> and are also unsigned. The following numeric
types are predefined.</t>

<figure><artwork><![CDATA[
   uint8 uint16[2];
   uint8 uint24[3];
   uint8 uint32[4];
   uint8 uint64[8];
]]></artwork></figure>

<t>All values, here and elsewhere in the specification, are transmitted in network byte
(big-endian) order; the uint32 represented by the hex bytes 01 02 03 04 is
equivalent to the decimal value 16909060.</t>

</section>
<section anchor="vectors" title="Vectors">

<t>A vector (single-dimensioned array) is a stream of homogeneous data elements.
The size of the vector may be specified at documentation time or left
unspecified until runtime. In either case, the length declares the number of
bytes, not the number of elements, in the vector. The syntax for specifying a
new type, T’, that is a fixed-length vector of type T is</t>

<figure><artwork><![CDATA[
   T T'[n];
]]></artwork></figure>

<t>Here, T’ occupies n bytes in the data stream, where n is a multiple of the size
of T.  The length of the vector is not included in the encoded stream.</t>

<t>In the following example, Datum is defined to be three consecutive bytes that
the protocol does not interpret, while Data is three consecutive Datum,
consuming a total of nine bytes.</t>

<figure><artwork><![CDATA[
   opaque Datum[3];      /* three uninterpreted bytes */
   Datum Data[9];        /* 3 consecutive 3-byte vectors */
]]></artwork></figure>

<t>Variable-length vectors are defined by specifying a subrange of legal lengths,
inclusively, using the notation &lt;floor..ceiling&gt;. When these are encoded, the
actual length precedes the vector’s contents in the byte stream. The length
will be in the form of a number consuming as many bytes as required to hold the
vector’s specified maximum (ceiling) length. A variable-length vector with an
actual length field of zero is referred to as an empty vector.</t>

<figure><artwork><![CDATA[
   T T'<floor..ceiling>;
]]></artwork></figure>

<t>In the following example, mandatory is a vector that must contain between 300
and 400 bytes of type opaque. It can never be empty. The actual length field
consumes two bytes, a uint16, which is sufficient to represent the value 400
(see <xref target="numbers"/>). Similarly, longer can represent up to 800 bytes of
data, or 400 uint16 elements, and it may be empty. Its encoding will include a
two-byte actual length field prepended to the vector. The length of an encoded
vector must be an exact multiple of the length of a single element (e.g.,
a 17-byte vector of uint16 would be illegal).</t>

<figure><artwork><![CDATA[
   opaque mandatory<300..400>;
         /* length field is 2 bytes, cannot be empty */
   uint16 longer<0..800>;
         /* zero to 400 16-bit unsigned integers */
]]></artwork></figure>

</section>
<section anchor="enumerateds" title="Enumerateds">

<t>An additional sparse data type is available called enum or
enumerated. Each definition is a different type. Only enumerateds of
the same type may be assigned or compared.  Every element of an
enumerated must be assigned a value, as demonstrated in the following
example. Since the elements of the enumerated are not ordered, they
can be assigned any unique value, in any order.</t>

<figure><artwork><![CDATA[
   enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
]]></artwork></figure>

<t>Future extensions or additions to the protocol may define new values.
Implementations need to be able to parse and ignore unknown values unless the
definition of the field states otherwise.</t>

<t>An enumerated occupies as much space in the byte stream as would its maximal
defined ordinal value. The following definition would cause one byte to be used
to carry fields of type Color.</t>

<figure><artwork><![CDATA[
   enum { red(3), blue(5), white(7) } Color;
]]></artwork></figure>

<t>One may optionally specify a value without its associated tag to force the
width definition without defining a superfluous element.</t>

<t>In the following example, Taste will consume two bytes in the data stream but
can only assume the values 1, 2, or 4 in the current version of the protocol.</t>

<figure><artwork><![CDATA[
   enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
]]></artwork></figure>

<t>The names of the elements of an enumeration are scoped within the defined type.
In the first example, a fully qualified reference to the second element of the
enumeration would be Color.blue. Such qualification is not required if the
target of the assignment is well specified.</t>

<figure><artwork><![CDATA[
   Color color = Color.blue;     /* overspecified, legal */
   Color color = blue;           /* correct, type implicit */
]]></artwork></figure>

<t>The names assigned to enumerateds do not need to be unique.  The numerical value
can describe a range over which the same name applies.  The value includes the
minimum and maximum inclusive values in that range, separated by two period
characters. This is principally useful for reserving regions of the space.</t>

<figure><artwork><![CDATA[
   enum { sad(0), meh(1..254), happy(255) } Mood;
]]></artwork></figure>

</section>
<section anchor="constructed-types" title="Constructed Types">

<t>Structure types may be constructed from primitive types for convenience. Each
specification declares a new, unique type. The syntax for definition is much
like that of C.</t>

<figure><artwork><![CDATA[
   struct {
       T1 f1;
       T2 f2;
       ...
       Tn fn;
   } T;
]]></artwork></figure>

<t>Fixed- and variable-length vector fields are allowed using the standard vector
syntax. Structures V1 and V2 in the variants example below demonstrate this.</t>

<t>The fields within a structure may be qualified using the type’s name, with a
syntax much like that available for enumerateds. For example, T.f2 refers to
the second field of the previous declaration.</t>

</section>
<section anchor="constants" title="Constants">

<t>Fields and variables may be assigned a fixed value using “=”, as in:</t>

<figure><artwork><![CDATA[
   struct {
       T1 f1 = 8;  /* T.f1 must always be 8 */
       T2 f2;
   } T;
]]></artwork></figure>

</section>
<section anchor="variants" title="Variants">

<t>Defined structures may have variants based on some knowledge that is
available within the environment. The selector must be an enumerated
type that defines the possible variants the structure defines. Each
arm of the select specifies the type of that variant’s field and an
optional field label. The mechanism by which the variant is selected
at runtime is not prescribed by the presentation language.</t>

<figure><artwork><![CDATA[
   struct {
       T1 f1;
       T2 f2;
       ....
       Tn fn;
       select (E) {
           case e1: Te1 [[fe1]];
           case e2: Te2 [[fe2]];
           ....
           case en: Ten [[fen]];
       };
   } Tv;
]]></artwork></figure>

<t>For example:</t>

<figure><artwork><![CDATA[
   enum { apple(0), orange(1) } VariantTag;

   struct {
       uint16 number;
       opaque string<0..10>; /* variable length */
   } V1;

   struct {
       uint32 number;
       opaque string[10];    /* fixed length */
   } V2;

   struct {
       VariantTag type;
       select (VariantRecord.type) {
           case apple:  V1;
           case orange: V2;
       };
   } VariantRecord;
]]></artwork></figure>

</section>
</section>
<section anchor="handshake-protocol" title="Handshake Protocol">

<t>The handshake protocol is used to negotiate the security parameters
of a connection. Handshake messages are supplied to the TLS record layer, where
they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures, which are
processed and transmitted as specified by the current active connection state.</t>

<figure><artwork><![CDATA[
   enum {
       client_hello(1),
       server_hello(2),
       new_session_ticket(4),
       end_of_early_data(5),
       encrypted_extensions(8),
       certificate(11),
       certificate_request(13),
       certificate_verify(15),
       finished(20),
       key_update(24),
       message_hash(254),
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;    /* handshake type */
       uint24 length;             /* bytes in message */
       select (Handshake.msg_type) {
           case client_hello:          ClientHello;
           case server_hello:          ServerHello;
           case end_of_early_data:     EndOfEarlyData;
           case encrypted_extensions:  EncryptedExtensions;
           case certificate_request:   CertificateRequest;
           case certificate:           Certificate;
           case certificate_verify:    CertificateVerify;
           case finished:              Finished;
           case new_session_ticket:    NewSessionTicket;
           case key_update:            KeyUpdate;
       };
   } Handshake;
]]></artwork></figure>

<t>Protocol messages MUST be sent in the order defined in
<xref target="the-transcript-hash"/> and shown in the diagrams in <xref target="protocol-overview"/>.
A peer which receives a handshake message in an unexpected order
MUST abort the handshake with an “unexpected_message” alert.</t>

<t>New handshake message types are assigned by IANA as described in
<xref target="iana-considerations"/>.</t>

<section anchor="key-exchange-messages" title="Key Exchange Messages">

<t>The key exchange messages are used to determine the security capabilities
of the client and the server and to establish shared secrets including
the traffic keys used to protect the rest of the handshake and the data.</t>

<section anchor="cryptographic-negotiation" title="Cryptographic Negotiation">

<t>In TLS, the cryptographic negotiation proceeds by the client offering the
following four sets of options in its ClientHello:</t>

<t><list style="symbols">
  <t>A list of cipher suites which indicates the AEAD algorithm/HKDF hash
pairs which the client supports.</t>
  <t>A “supported_groups” (<xref target="negotiated-groups"/>) extension which indicates the (EC)DHE groups
which the client supports and a “key_share” (<xref target="key-share"/>) extension which contains
(EC)DHE shares for some or all of these groups.</t>
  <t>A “signature_algorithms” (<xref target="signature-algorithms"/>) extension which indicates the signature
algorithms which the client can accept.</t>
  <t>A “pre_shared_key” (<xref target="pre-shared-key-extension"/>) extension which
contains a list of symmetric key identities known to the client and a
“psk_key_exchange_modes” (<xref target="pre-shared-key-exchange-modes"/>)
extension which indicates the key exchange modes that may be used
with PSKs.</t>
</list></t>

<t>If the server does not select a PSK, then the first three of these
options are entirely orthogonal: the server independently selects a
cipher suite, an (EC)DHE group and key share for key establishment,
and a signature algorithm/certificate pair to authenticate itself to
the client. If there is no overlap between the received “supported_groups”
and the groups supported by the server then the server MUST abort the
handshake with a “handshake_failure” or an “insufficient_security” alert.</t>

<t>If the server selects a PSK, then it MUST also select a key
establishment mode from the set indicated by client’s
“psk_key_exchange_modes” extension (at present, PSK alone or with (EC)DHE). Note
that if the PSK can be used without (EC)DHE then non-overlap in the
“supported_groups” parameters need not be fatal, as it is in the
non-PSK case discussed in the previous paragraph.</t>

<t>If the server selects an (EC)DHE group and the client did not offer a
compatible “key_share” extension in the initial ClientHello, the server MUST
respond with a HelloRetryRequest (<xref target="hello-retry-request"/>) message.</t>

<t>If the server successfully selects parameters and does not require a
HelloRetryRequest, it indicates the selected parameters in the ServerHello as
follows:</t>

<t><list style="symbols">
  <t>If PSK is being used, then the server will send a
“pre_shared_key” extension indicating the selected key.</t>
  <t>If PSK is not being used, then (EC)DHE and certificate-based
authentication are always used.</t>
  <t>When (EC)DHE is in use, the server will also provide a
“key_share” extension.</t>
  <t>When authenticating via a certificate, the server will send
the Certificate (<xref target="certificate"/>) and CertificateVerify
(<xref target="certificate-verify"/>) messages. In TLS 1.3
as defined by this document, either a PSK or a certificate
is always used, but not both. Future documents may define how
to use them together.</t>
</list></t>

<t>If the server is unable to negotiate a supported set of parameters
(i.e., there is no overlap between the client and server parameters),
it MUST abort the handshake with either
a “handshake_failure” or “insufficient_security” fatal alert
(see <xref target="alert-protocol"/>).</t>

</section>
<section anchor="client-hello" title="Client Hello">

<t>When a client first connects to a server, it is REQUIRED to send the
ClientHello as its first TLS message. The client will also send a
ClientHello when the server has responded to its ClientHello with a
HelloRetryRequest. In that case, the client MUST send the same
ClientHello without modification, except:</t>

<t><list style="symbols">
  <t>If a “key_share” extension was supplied in the HelloRetryRequest,
replacing the list of shares with a list containing a single
KeyShareEntry from the indicated group.</t>
  <t>Removing the “early_data” extension (<xref target="early-data-indication"/>) if one was
present. Early data is not permitted after HelloRetryRequest.</t>
  <t>Including a “cookie” extension if one was provided in the
HelloRetryRequest.</t>
  <t>Updating the “pre_shared_key” extension if present by
recomputing the “obfuscated_ticket_age” and binder values
and (optionally) removing
any PSKs which are incompatible with the server’s indicated
cipher suite.</t>
  <t>Optionally adding, removing, or changing the length of the “padding”
extension <xref target="RFC7685"/>.</t>
  <t>Other modifications that may be allowed by an extension defined in the
future and present in the HelloRetryRequest.</t>
</list></t>

<t>Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS
1.3 and receives a ClientHello at any other time, it MUST terminate
the connection with an “unexpected_message” alert.</t>

<t>If a server established a TLS connection with a previous version of TLS
and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the
previous protocol version. In particular, it MUST NOT negotiate TLS 1.3.</t>

<t>Structure of this message:</t>

<figure><artwork><![CDATA[
   uint16 ProtocolVersion;
   opaque Random[32];

   uint8 CipherSuite[2];    /* Cryptographic suite selector */

   struct {
       ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
       Random random;
       opaque legacy_session_id<0..32>;
       CipherSuite cipher_suites<2..2^16-2>;
       opaque legacy_compression_methods<1..2^8-1>;
       Extension extensions<8..2^16-1>;
   } ClientHello;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='legacy_version'>
  In previous versions of TLS, this field was used for version negotiation
and represented the highest version number supported by the client.
Experience has shown that many servers do not properly implement
version negotiation, leading to “version intolerance” in which
the server rejects an otherwise acceptable ClientHello with a version
number higher than it supports.
In TLS 1.3, the client indicates its version preferences in the
“supported_versions” extension (<xref target="supported-versions"/>) and the legacy_version field MUST
be set to 0x0303, which is the version number for TLS 1.2.
(See <xref target="backward-compatibility"/> for details about backward compatibility.)</t>
  <t hangText='random'>
  32 bytes generated by a secure random number generator.
See <xref target="implementation-notes"/> for additional information.</t>
  <t hangText='legacy_session_id'>
  Versions of TLS before TLS 1.3 supported a “session resumption”
feature which has been merged with Pre-Shared Keys in this version
(see <xref target="resumption-and-psk"/>). A client which has a cached session ID
set by a pre-TLS 1.3 server SHOULD set this field to that value. In
compatibility mode (see <xref target="middlebox"/>) this field MUST be non-empty,
so a client not offering a pre-TLS 1.3 session MUST generate a
new 32-byte value. This value need not be random but SHOULD be
unpredictable to avoid implementations fixating on a specific value
(also known as ossification).
Otherwise, it MUST be set as a zero length vector (i.e., a single
zero byte length field).</t>
  <t hangText='cipher_suites'>
  This is a list of the symmetric cipher options supported by the
client, specifically the record protection algorithm (including
secret key length) and a hash to be used with HKDF, in descending
order of client preference. If the list contains cipher suites that
the server does not recognize, support or wish to use, the server
MUST ignore those cipher suites and process the remaining ones as
usual. Values are defined in <xref target="cipher-suites"/>. If the client is
attempting a PSK key establishment, it SHOULD advertise at least one
cipher suite indicating a Hash associated with the PSK.</t>
  <t hangText='legacy_compression_methods'>
  Versions of TLS before 1.3 supported compression with the list of
supported compression methods being sent in this field. For every TLS 1.3
ClientHello, this vector MUST contain exactly one byte, set to
zero, which corresponds to the “null” compression method in
prior versions of TLS. If a TLS 1.3 ClientHello is
received with any other value in this field, the server MUST
abort the handshake with an “illegal_parameter” alert. Note that TLS 1.3
servers might receive TLS 1.2 or prior ClientHellos which contain
other compression methods and (if negotiating such a prior version)
MUST follow the procedures for
the appropriate prior version of TLS.  TLS 1.3 ClientHellos are identified
as having a legacy_version of 0x0303 and a supported_versions extension
present with 0x0304 as the highest version indicated therein.</t>
  <t hangText='extensions'>
  Clients request extended functionality from servers by sending
data in the extensions field.  The actual “Extension” format is
defined in <xref target="extensions"/>.  In TLS 1.3, use
of certain extensions is mandatory, as functionality is moved into
extensions to preserve ClientHello compatibility with previous versions of TLS.
Servers MUST ignore unrecognized extensions.</t>
</list></t>

<t>All versions of TLS allow an extensions field to optionally follow the
compression_methods field. TLS 1.3 ClientHello
messages always contain extensions (minimally “supported_versions”, otherwise
they will be interpreted as TLS 1.2 ClientHello messages).
However, TLS 1.3 servers might receive ClientHello messages without an
extensions field from prior versions of TLS.
The presence of extensions can be detected by determining whether there
are bytes following the compression_methods field at the end of the
ClientHello. Note that this method of detecting optional data differs
from the normal TLS method of having a variable-length field, but it
is used for compatibility with TLS before extensions were defined.
TLS 1.3 servers will need to perform this check first and only
attempt to negotiate TLS 1.3 if the “supported_versions” extension
is present.
If negotiating a version of TLS prior to 1.3, a server MUST check that
the message either contains no data after legacy_compression_methods
or that it contains a valid extensions block with no data following.
If not, then it MUST abort the handshake with a “decode_error” alert.</t>

<t>In the event that a client requests additional functionality using
extensions, and this functionality is not supplied by the server, the
client MAY abort the handshake.</t>

<t>After sending the ClientHello message, the client waits for a ServerHello
or HelloRetryRequest message. If early data
is in use, the client may transmit early application data
(<xref target="zero-rtt-data"/>) while waiting for the next handshake message.</t>

</section>
<section anchor="server-hello" title="Server Hello">

<t>The server will send this message in response to a ClientHello message
to proceed with the handshake if it is able to negotiate an acceptable
set of handshake parameters based on the ClientHello.</t>

<t>Structure of this message:</t>

<figure><artwork><![CDATA[
   struct {
       ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
       Random random;
       opaque legacy_session_id_echo<0..32>;
       CipherSuite cipher_suite;
       uint8 legacy_compression_method = 0;
       Extension extensions<6..2^16-1>;
   } ServerHello;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='legacy_version'>
  In previous versions of TLS, this field was used for version negotiation
and represented the selected version number for the connection. Unfortunately,
some middleboxes fail when presented with new values.
In TLS 1.3, the TLS server indicates its version using the
“supported_versions” extension (<xref target="supported-versions"/>),
and the legacy_version field MUST
be set to 0x0303, which is the version number for TLS 1.2.
(See <xref target="backward-compatibility"/> for details about backward compatibility.)</t>
  <t hangText='random'>
  32 bytes generated by a secure random number generator.
See <xref target="implementation-notes"/> for additional information.
The last eight bytes MUST be overwritten as described
below if negotiating TLS 1.2 or TLS 1.1, but the
remaining bytes MUST be random.
This structure is generated by the server and MUST be
generated independently of the ClientHello.random.</t>
  <t hangText='legacy_session_id_echo'>
  The contents of the client’s legacy_session_id field. Note that
this field is echoed even if the client’s value corresponded to
a cached pre-TLS 1.3 session which the server has chosen not
to resume. A client which receives a legacy_session_id_echo field
that does not match what it sent in the ClientHello
MUST abort the handshake with an “illegal_parameter”
alert.</t>
  <t hangText='cipher_suite'>
  The single cipher suite selected by the server from the list in
ClientHello.cipher_suites. A client which receives a cipher suite
that was not offered MUST abort the handshake with an “illegal_parameter”
alert.</t>
  <t hangText='legacy_compression_method'>
  A single byte which MUST have the value 0.</t>
  <t hangText='extensions'>
  A list of extensions.  The ServerHello MUST only include extensions
which are required to establish the cryptographic context and negotiate
the protocol version. All TLS 1.3 ServerHello messages MUST contain the
“supported_versions” extension.  Current ServerHello messages additionally contain
either the “pre_shared_key” or “key_share” extensions, or both when using
a PSK with (EC)DHE key establishment. Other extensions are sent
separately in the EncryptedExtensions message.</t>
</list></t>

<t>For reasons of backward compatibility with middleboxes
(see <xref target="middlebox"/>) the HelloRetryRequest
message uses the same structure as the ServerHello, but with
Random set to the special value of the SHA-256 of
“HelloRetryRequest”:</t>

<figure><artwork><![CDATA[
  CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
  C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
]]></artwork></figure>

<t>Upon receiving a message with type server_hello, implementations
MUST first examine the Random value and if it matches
this value, process it as described in <xref target="hello-retry-request"/>).</t>

<t>TLS 1.3 has a downgrade protection mechanism embedded in the server’s
random value. TLS 1.3 servers which negotiate TLS 1.2 or below in
response to a ClientHello MUST set the last eight bytes of their
Random value specially.</t>

<t>If negotiating TLS 1.2, TLS 1.3 servers MUST set the last eight bytes of their
Random value to the bytes:</t>

<figure><artwork><![CDATA[
  44 4F 57 4E 47 52 44 01
]]></artwork></figure>

<t>If negotiating TLS 1.1 or below, TLS 1.3 servers MUST and TLS 1.2
servers SHOULD set the last eight bytes of their Random value to the
bytes:</t>

<figure><artwork><![CDATA[
  44 4F 57 4E 47 52 44 00
]]></artwork></figure>

<t>TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below
MUST check that the last eight bytes are not equal to either of these values.
TLS 1.2 clients SHOULD also check that the last eight bytes are not
equal to the second value if the ServerHello indicates TLS 1.1 or
below.  If a match is found, the client MUST abort the handshake
with an “illegal_parameter” alert.  This mechanism provides limited
protection against downgrade attacks over and above what is provided
by the Finished exchange: because the ServerKeyExchange, a message
present in TLS 1.2 and below, includes a signature over both random
values, it is not possible for an active attacker to modify the
random values without detection as long as ephemeral ciphers are used.
It does not provide downgrade protection when static RSA is used.</t>

<t>Note: This is a change from <xref target="RFC5246"/>, so in practice many TLS 1.2 clients
and servers will not behave as specified above.</t>

<t>A legacy TLS client performing renegotiation with TLS 1.2 or prior
and which receives a TLS 1.3 ServerHello during renegotiation
MUST abort the handshake with a “protocol_version” alert.
Note that renegotiation is not possible when TLS 1.3 has been
negotiated.</t>

<t>RFC EDITOR: PLEASE REMOVE THE FOLLOWING PARAGRAPH
Implementations of draft versions (see <xref target="draft-version-indicator"/>) of this
specification SHOULD NOT implement this mechanism on either client and server.
A pre-RFC client connecting to RFC servers, or vice versa, will appear to
downgrade to TLS 1.2. With the mechanism enabled, this will cause an
interoperability failure.</t>

</section>
<section anchor="hello-retry-request" title="Hello Retry Request">

<t>The server will send this message in response to a ClientHello message
if it is able to find an acceptable set of parameters but the
ClientHello does not contain sufficient information to proceed with
the handshake. As discussed in <xref target="server-hello"/>, the HelloRetryRequest
has the same format as a ServerHello message, and the
legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression
methods fields have the same meaning. However, for convenience we
discuss HelloRetryRequest throughout this document as if it were
a distinct message.</t>

<t>The server’s extensions MUST contain “supported_versions” and
otherwise the server SHOULD send only the extensions necessary for the
client to generate a correct ClientHello pair. As with ServerHello, a
HelloRetryRequest MUST NOT contain any extensions that were not first
offered by the client in its ClientHello, with the exception of
optionally the “cookie” (see <xref target="cookie"/>) extension.</t>

<t>Upon receipt of a HelloRetryRequest, the client MUST check
the legacy_version, legacy_session_id_echo, cipher_suite,
and legacy_compression_method as specified in <xref target="server-hello"/> and then process the
extensions, starting with determining the version using
“supported_versions”. Clients MUST abort the handshake with
an “illegal_parameter” alert if the HelloRetryRequest would not result in
any change in the ClientHello. If a client receives a second
HelloRetryRequest in the same connection (i.e., where
the ClientHello was itself in response to a HelloRetryRequest), it
MUST abort the handshake with an “unexpected_message” alert.</t>

<t>Otherwise, the client MUST process all extensions in the
HelloRetryRequest and send a second updated ClientHello. The
HelloRetryRequest extensions defined in this specification are:</t>

<t><list style="symbols">
  <t>supported_versions (see <xref target="supported-versions"/>)</t>
  <t>cookie (see <xref target="cookie"/>)</t>
  <t>key_share (see <xref target="key-share"/>)</t>
</list></t>

<t>In addition, in its updated ClientHello, the client SHOULD NOT offer
any pre-shared keys associated with a hash other than that of the
selected cipher suite. This allows the client to avoid having to
compute partial hash transcripts for multiple hashes in the second
ClientHello.  A client which receives a cipher suite that was not
offered MUST abort the handshake.  Servers MUST ensure that they
negotiate the same cipher suite when receiving a conformant updated
ClientHello (if the server selects the cipher suite as the first step
in the negotiation, then this will happen automatically). Upon
receiving the ServerHello, clients MUST check that the cipher suite
supplied in the ServerHello is the same as that in the
HelloRetryRequest and otherwise abort the handshake with an
“illegal_parameter” alert.</t>

<t>The value of selected_version in the HelloRetryRequest “supported_versions”
extension MUST be retained in the ServerHello, and a client MUST abort the
handshake with an “illegal_parameter” alert if the value changes.</t>

</section>
</section>
<section anchor="extensions" title="Extensions">

<t>A number of TLS messages contain tag-length-value encoded extensions structures.</t>

<figure><artwork><![CDATA[
   struct {
       ExtensionType extension_type;
       opaque extension_data<0..2^16-1>;
   } Extension;

   enum {
       server_name(0),                             /* RFC 6066 */
       max_fragment_length(1),                     /* RFC 6066 */
       status_request(5),                          /* RFC 6066 */
       supported_groups(10),                       /* RFC 4492, 7919 */
       signature_algorithms(13),                   /* [[this document]] */
       use_srtp(14),                               /* RFC 5764 */
       heartbeat(15),                              /* RFC 6520 */
       application_layer_protocol_negotiation(16), /* RFC 7301 */
       signed_certificate_timestamp(18),           /* RFC 6962 */
       client_certificate_type(19),                /* RFC 7250 */
       server_certificate_type(20),                /* RFC 7250 */
       padding(21),                                /* RFC 7685 */
       pre_shared_key(41),                         /* [[this document]] */
       early_data(42),                             /* [[this document]] */
       supported_versions(43),                     /* [[this document]] */
       cookie(44),                                 /* [[this document]] */
       psk_key_exchange_modes(45),                 /* [[this document]] */
       certificate_authorities(47),                /* [[this document]] */
       oid_filters(48),                            /* [[this document]] */
       post_handshake_auth(49),                    /* [[this document]] */
       signature_algorithms_cert(50),              /* [[this document]] */
       key_share(51),                              /* [[this document]] */
       (65535)
   } ExtensionType;
]]></artwork></figure>

<t>Here:</t>

<t><list style="symbols">
  <t>“extension_type” identifies the particular extension type.</t>
  <t>“extension_data” contains information specific to the particular
extension type.</t>
</list></t>

<t>The list of extension types is maintained by IANA as described in
<xref target="iana-considerations"/>.</t>

<t>Extensions are generally structured in a request/response fashion, though
some extensions are just indications with no corresponding response. The client
sends its extension requests in the ClientHello message and the server sends
its extension responses in the ServerHello, EncryptedExtensions,
HelloRetryRequest and Certificate messages. The server sends extension requests
in the CertificateRequest message which a client MAY respond to with
a Certificate message. The server MAY also send unsolicited
extensions in the NewSessionTicket, though the client does not respond
directly to these.</t>

<t>Implementations MUST NOT send extension responses
if the remote endpoint did not send the corresponding extension requests,
with the exception of the “cookie” extension in HelloRetryRequest.
Upon receiving such an extension, an endpoint MUST abort the handshake with an
“unsupported_extension” alert.</t>

<t>The table below indicates the messages where a given extension may
appear, using the following notation: CH (ClientHello), SH
(ServerHello), EE (EncryptedExtensions), CT (Certificate), CR
(CertificateRequest), NST (NewSessionTicket) and HRR
(HelloRetryRequest). If an implementation receives an extension which
it recognizes and which is not specified for the message in which it
appears it MUST abort the handshake with an “illegal_parameter” alert.</t>

<texttable>
      <ttcol align='left'>Extension</ttcol>
      <ttcol align='right'>TLS 1.3</ttcol>
      <c>server_name <xref target="RFC6066"></xref></c>
      <c>CH, EE</c>
      <c>max_fragment_length <xref target="RFC6066"></xref></c>
      <c>CH, EE</c>
      <c>status_request <xref target="RFC6066"></xref></c>
      <c>CH, CR, CT</c>
      <c>supported_groups <xref target="RFC7919"></xref></c>
      <c>CH, EE</c>
      <c>signature_algorithms <xref target="RFC5246"></xref></c>
      <c>CH, CR</c>
      <c>use_srtp <xref target="RFC5764"></xref></c>
      <c>CH, EE</c>
      <c>heartbeat <xref target="RFC6520"></xref></c>
      <c>CH, EE</c>
      <c>application_layer_protocol_negotiation <xref target="RFC7301"></xref></c>
      <c>CH, EE</c>
      <c>signed_certificate_timestamp <xref target="RFC6962"></xref></c>
      <c>CH, CR, CT</c>
      <c>client_certificate_type <xref target="RFC7250"></xref></c>
      <c>CH, EE</c>
      <c>server_certificate_type <xref target="RFC7250"></xref></c>
      <c>CH, EE</c>
      <c>padding <xref target="RFC7685"></xref></c>
      <c>CH</c>
      <c>key_share [[this document]]</c>
      <c>CH, SH, HRR</c>
      <c>pre_shared_key [[this document]]</c>
      <c>CH, SH</c>
      <c>psk_key_exchange_modes [[this document]]</c>
      <c>CH</c>
      <c>early_data [[this document]]</c>
      <c>CH, EE, NST</c>
      <c>cookie [[this document]]</c>
      <c>CH, HRR</c>
      <c>supported_versions [[this document]]</c>
      <c>CH, SH, HRR</c>
      <c>certificate_authorities [[this document]]</c>
      <c>CH, CR</c>
      <c>oid_filters [[this document]]</c>
      <c>CR</c>
      <c>post_handshake_auth [[this document]]</c>
      <c>CH</c>
      <c>signature_algorithms_cert [[this document]]</c>
      <c>CH, CR</c>
</texttable>

<t>When multiple extensions of different types are present, the
extensions MAY appear in any order, with the exception of
“pre_shared_key” <xref target="pre-shared-key-extension"/> which MUST be
the last extension in the ClientHello.
There MUST NOT be more than one extension of the same type in a given
extension block.</t>

<t>In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each
handshake even when in resumption-PSK mode. However, 0-RTT parameters are
those negotiated in the previous handshake; mismatches may require
rejecting 0-RTT (see <xref target="early-data-indication"/>).</t>

<t>There are subtle (and not so subtle) interactions that may occur in this
protocol between new features and existing features which may result in a
significant reduction in overall security. The following considerations should
be taken into account when designing new extensions:</t>

<t><list style="symbols">
  <t>Some cases where a server does not agree to an extension are error
conditions (e.g., the handshake cannot continue), and some are
simply refusals to support particular features. In general, error
alerts should be used for the former and a field in the server
extension response for the latter.</t>
  <t>Extensions should, as far as possible, be designed to prevent any attack that
forces use (or non-use) of a particular feature by manipulation of handshake
messages. This principle should be followed regardless of whether the feature
is believed to cause a security problem.
Often the fact that the extension fields are included in the inputs to the
Finished message hashes will be sufficient, but extreme care is needed when
the extension changes the meaning of messages sent in the handshake phase.
Designers and implementors should be aware of the fact that until the
handshake has been authenticated, active attackers can modify messages and
insert, remove, or replace extensions.</t>
</list></t>

<section anchor="supported-versions" title="Supported Versions">

<figure><artwork><![CDATA[
   struct {
       select (Handshake.msg_type) {
           case client_hello:
                ProtocolVersion versions<2..254>;

           case server_hello: /* and HelloRetryRequest */
                ProtocolVersion selected_version;
       };
   } SupportedVersions;
]]></artwork></figure>

<t>The “supported_versions” extension is used by the client to indicate
which versions of TLS it supports and by the server to indicate
which version it is using. The extension contains a list of
supported versions in preference order, with the most preferred
version first. Implementations of this specification MUST send this
extension in the ClientHello containing all versions of TLS which they are
prepared to negotiate (for this specification, that means minimally
0x0304, but if previous versions of TLS are allowed to be negotiated,
they MUST be present as well).</t>

<t>If this extension is not present, servers which are compliant with
this specification, and which also support TLS 1.2,
MUST negotiate TLS 1.2 or prior as specified in
<xref target="RFC5246"/>, even if ClientHello.legacy_version is 0x0304 or later.
Servers MAY abort the handshake upon receiving a ClientHello with
legacy_version 0x0304 or later.</t>

<t>If this extension is present in the ClientHello, servers MUST NOT use the
ClientHello.legacy_version value for version negotiation and MUST use only the
“supported_versions” extension to determine client
preferences. Servers MUST only select a version of TLS present in that
extension and MUST ignore any unknown versions that are present in that
extension. Note that this
mechanism makes it possible to negotiate a version prior to TLS 1.2 if
one side supports a sparse range. Implementations of TLS 1.3 which choose
to support prior versions of TLS SHOULD support TLS 1.2.
Servers MUST be prepared to receive ClientHellos that include this
extension but do not include 0x0304 in the list of versions.</t>

<t>A server which negotiates a version of TLS prior to TLS 1.3 MUST
set ServerHello.version and MUST NOT send the “supported_versions”
extension.
A server which negotiates TLS 1.3 MUST respond by sending a
“supported_versions” extension containing the selected version value
(0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS
1.2). Clients MUST check for this extension prior to processing
the rest of the ServerHello (although they will have to parse the
ServerHello in order to read the extension).
If this extension is present, clients MUST ignore the
ServerHello.legacy_version value and MUST use only the
“supported_versions” extension to determine the selected version. If the
“supported_versions” extension in the ServerHello contains a version not offered by the
client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an
“illegal_parameter” alert.</t>

<section anchor="draft-version-indicator" title="Draft Version Indicator">

<t>RFC EDITOR: PLEASE REMOVE THIS SECTION</t>

<t>While the eventual version indicator for the RFC version of TLS 1.3 will
be 0x0304, implementations of draft versions of this specification SHOULD
instead advertise 0x7f00 | draft_version
in the ServerHello and HelloRetryRequest “supported_versions” extension.
For instance, draft-17 would be encoded as the 0x7f11.
This allows pre-RFC implementations to safely negotiate with each other,
even if they would otherwise be incompatible.</t>

</section>
</section>
<section anchor="cookie" title="Cookie">

<figure><artwork><![CDATA[
   struct {
       opaque cookie<1..2^16-1>;
   } Cookie;
]]></artwork></figure>

<t>Cookies serve two primary purposes:</t>

<t><list style="symbols">
  <t>Allowing the server to force the client to demonstrate reachability
at their apparent network address (thus providing a measure of DoS
protection). This is primarily useful for non-connection-oriented
transports (see <xref target="RFC6347"/> for an example of this).</t>
  <t>Allowing the server to offload state to the client, thus allowing it to send
a HelloRetryRequest without storing any state. The server can do this by
storing the hash of the ClientHello in the HelloRetryRequest cookie
(protected with some suitable integrity algorithm).</t>
</list></t>

<t>When sending a HelloRetryRequest, the server MAY provide a “cookie” extension to the
client (this is an exception to the usual rule that the only extensions that
may be sent are those that appear in the ClientHello). When sending the
new ClientHello, the client MUST copy the contents of the extension received in
the HelloRetryRequest into a “cookie” extension in the new ClientHello.
Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.</t>

<t>When a server is operating statelessly it may receive an unprotected record of
type change_cipher_spec between the first and second ClientHello (see
<xref target="record-protocol"/>). Since the server is not storing any state this will appear
as if it were the first message to be received. Servers operating statelessly
MUST ignore these records.</t>

</section>
<section anchor="signature-algorithms" title="Signature Algorithms">

<t>TLS 1.3 provides two extensions for indicating which signature
algorithms may be used in digital signatures. The
“signature_algorithms_cert” extension applies to signatures in
certificates and the “signature_algorithms” extension, which originally
appeared in TLS 1.2, applies to signatures in CertificateVerify
messages. The keys found in certificates MUST also be of
appropriate type for the signature algorithms they are used
with. This is a particular issue for RSA keys and PSS signatures,
as described below. If no “signature_algorithms_cert” extension is present,
then the “signature_algorithms” extension also applies to signatures
appearing in certificates. Clients which desire the server to authenticate
itself via a certificate MUST send “signature_algorithms”. If a server
is authenticating via a certificate and the client has not sent a
“signature_algorithms” extension, then the server MUST abort the
handshake with a “missing_extension” alert (see <xref target="mti-extensions"/>).</t>

<t>The “signature_algorithms_cert” extension was added to allow implementations
which supported different sets of algorithms for certificates and in TLS itself
to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process
this extension. Implementations which have the same policy in both cases
MAY omit the “signature_algorithms_cert” extension.</t>

<t>The “extension_data” field of these extensions contains a
SignatureSchemeList value:</t>

<figure><artwork><![CDATA[
   enum {
       /* RSASSA-PKCS1-v1_5 algorithms */
       rsa_pkcs1_sha256(0x0401),
       rsa_pkcs1_sha384(0x0501),
       rsa_pkcs1_sha512(0x0601),

       /* ECDSA algorithms */
       ecdsa_secp256r1_sha256(0x0403),
       ecdsa_secp384r1_sha384(0x0503),
       ecdsa_secp521r1_sha512(0x0603),

       /* RSASSA-PSS algorithms with public key OID rsaEncryption */
       rsa_pss_rsae_sha256(0x0804),
       rsa_pss_rsae_sha384(0x0805),
       rsa_pss_rsae_sha512(0x0806),

       /* EdDSA algorithms */
       ed25519(0x0807),
       ed448(0x0808),

       /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
       rsa_pss_pss_sha256(0x0809),
       rsa_pss_pss_sha384(0x080a),
       rsa_pss_pss_sha512(0x080b),

       /* Legacy algorithms */
       rsa_pkcs1_sha1(0x0201),
       ecdsa_sha1(0x0203),

       /* Reserved Code Points */
       private_use(0xFE00..0xFFFF),
       (0xFFFF)
   } SignatureScheme;

   struct {
       SignatureScheme supported_signature_algorithms<2..2^16-2>;
   } SignatureSchemeList;
]]></artwork></figure>

<t>Note: This enum is named “SignatureScheme” because there is already
a “SignatureAlgorithm” type in TLS 1.2, which this replaces.
We use the term “signature algorithm” throughout the text.</t>

<t>Each SignatureScheme value lists a single signature algorithm that the
client is willing to verify. The values are indicated in descending order
of preference. Note that a signature algorithm takes as input an
arbitrary-length message, rather than a digest. Algorithms which
traditionally act on a digest should be defined in TLS to first
hash the input with a specified hash algorithm and then proceed as usual.
The code point groups listed above have the following meanings:</t>

<t><list style="hanging">
  <t hangText='RSASSA-PKCS1-v1_5 algorithms'>
  Indicates a signature algorithm using RSASSA-PKCS1-v1_5 <xref target="RFC8017"/>
with the corresponding hash algorithm as defined in <xref target="SHS"/>. These values
refer solely to signatures which appear in certificates (see
<xref target="server-certificate-selection"/>) and are not defined for use in signed
TLS handshake messages, although they MAY appear in “signature_algorithms”
and “signature_algorithms_cert” for backward compatibility with TLS 1.2,</t>
  <t hangText='ECDSA algorithms'>
  Indicates a signature algorithm using ECDSA <xref target="ECDSA"/>, the corresponding
curve as defined in ANSI X9.62 <xref target="X962"/> and FIPS 186-4 <xref target="DSS"/>, and the
corresponding hash algorithm as defined in <xref target="SHS"/>. The signature is
represented as a DER-encoded <xref target="X690"/> ECDSA-Sig-Value structure.</t>
  <t hangText='RSASSA-PSS RSAE algorithms'>
  Indicates a signature algorithm using RSASSA-PSS <xref target="RFC8017"/> with mask
generation function 1. The
digest used in the mask generation function and the digest being signed are
both the corresponding hash algorithm as defined in <xref target="SHS"/>.
The length of the salt MUST be equal to the length of the output of the
digest algorithm. If the public key is carried
in an X.509 certificate, it MUST use the rsaEncryption OID <xref target="RFC5280"/>.</t>
  <t hangText='EdDSA algorithms'>
  Indicates a signature algorithm using EdDSA as defined in
<xref target="RFC8032"/> or its successors. Note that these correspond to the
“PureEdDSA” algorithms and not the “prehash” variants.</t>
  <t hangText='RSASSA-PSS PSS algorithms'>
  Indicates a signature algorithm using RSASSA-PSS <xref target="RFC8017"/> with mask
generation function 1. The
digest used in the mask generation function and the digest being signed are
both the corresponding hash algorithm as defined in <xref target="SHS"/>.
The length of the salt MUST be equal to the length of the digest
algorithm. If the public key is carried in an X.509 certificate,
it MUST use the RSASSA-PSS OID  <xref target="RFC5756"/>. When used in certificate signatures,
the algorithm parameters MUST be DER encoded. If the corresponding
public key’s parameters are present, then the parameters in the signature
MUST be identical to those in the public key.</t>
  <t hangText='Legacy algorithms'>
  Indicates algorithms which are being deprecated because they use
algorithms with known weaknesses, specifically SHA-1 which is used
in this context with either with RSA using RSASSA-PKCS1-v1_5 or ECDSA.  These values
refer solely to signatures which appear in certificates (see
<xref target="server-certificate-selection"/>) and are not defined for use in
signed TLS handshake messages, although they MAY appear in “signature_algorithms”
and “signature_algorithms_cert” for backward compatibility with TLS 1.2,
Endpoints SHOULD NOT negotiate these algorithms
but are permitted to do so solely for backward compatibility. Clients
offering these values MUST list
them as the lowest priority (listed after all other algorithms in
SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed
certificate unless no valid certificate chain can be produced
without it (see <xref target="server-certificate-selection"/>).</t>
</list></t>

<t>The signatures on certificates that are self-signed or certificates that are
trust anchors are not validated since they begin a certification path (see
<xref target="RFC5280"/>, Section 3.2).  A certificate that begins a certification
path MAY use a signature algorithm that is not advertised as being supported
in the “signature_algorithms” extension.</t>

<t>Note that TLS 1.2 defines this extension differently. TLS 1.3 implementations
willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of
<xref target="RFC5246"/> when negotiating that version. In particular:</t>

<t><list style="symbols">
  <t>TLS 1.2 ClientHellos MAY omit this extension.</t>
  <t>In TLS 1.2, the extension contained hash/signature pairs. The pairs are
encoded in two octets, so SignatureScheme values have been allocated to
align with TLS 1.2’s encoding. Some legacy pairs are left unallocated. These
algorithms are deprecated as of TLS 1.3. They MUST NOT be offered or
negotiated by any implementation. In particular, MD5 <xref target="SLOTH"/>, SHA-224, and
DSA MUST NOT be used.</t>
  <t>ECDSA signature schemes align with TLS 1.2’s ECDSA hash/signature pairs.
However, the old semantics did not constrain the signing curve.  If TLS 1.2 is
negotiated, implementations MUST be prepared to accept a signature that uses
any curve that they advertised in the “supported_groups” extension.</t>
  <t>Implementations that advertise support for RSASSA-PSS (which is mandatory in
TLS 1.3), MUST be prepared to accept a signature using that scheme even when
TLS 1.2 is negotiated. In TLS 1.2, RSASSA-PSS is used with RSA cipher suites.</t>
</list></t>

</section>
<section anchor="certificate-authorities" title="Certificate Authorities">

<t>The “certificate_authorities” extension is used to indicate the
certificate authorities which an endpoint supports and which SHOULD
be used by the receiving endpoint to guide certificate selection.</t>

<t>The body of the “certificate_authorities” extension consists of a
CertificateAuthoritiesExtension structure.</t>

<figure><artwork><![CDATA[
   opaque DistinguishedName<1..2^16-1>;

   struct {
       DistinguishedName authorities<3..2^16-1>;
   } CertificateAuthoritiesExtension;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='authorities'>
  A list of the distinguished names <xref target="X501"/> of acceptable
certificate authorities, represented in DER-encoded <xref target="X690"/> format.  These
distinguished names specify a desired distinguished name for trust anchor
or subordinate CA; thus, this message can be used to
describe known trust anchors as well as a desired authorization space.</t>
</list></t>

<t>The client MAY send the “certificate_authorities” extension in the ClientHello
message. The server MAY send it in the CertificateRequest message.</t>

<t>The “trusted_ca_keys” extension, which serves a similar
purpose <xref target="RFC6066"/>, but is more complicated, is not used in TLS 1.3
(although it may appear in ClientHello messages from clients which are
offering prior versions of TLS).</t>

</section>
<section anchor="oid-filters" title="OID Filters">

<t>The “oid_filters” extension allows servers to provide a set of OID/value
pairs which it would like the client’s certificate to match. This
extension, if provided by the server, MUST only be sent in the CertificateRequest message.</t>

<figure><artwork><![CDATA[
   struct {
       opaque certificate_extension_oid<1..2^8-1>;
       opaque certificate_extension_values<0..2^16-1>;
   } OIDFilter;

   struct {
       OIDFilter filters<0..2^16-1>;
   } OIDFilterExtension;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='filters'>
  A list of certificate extension OIDs <xref target="RFC5280"/> with their allowed value(s) and
represented in DER-encoded <xref target="X690"/> format. Some certificate extension OIDs
allow multiple values (e.g., Extended Key Usage).  If the server has included
a non-empty filters list, the client certificate included in
the response MUST contain all of the specified extension OIDs that the client
recognizes. For each extension OID recognized by the client, all of the
specified values MUST be present in the client certificate (but the
certificate MAY have other values as well). However, the client MUST ignore
and skip any unrecognized certificate extension OIDs. If the client ignored
some of the required certificate extension OIDs and supplied a certificate
that does not satisfy the request, the server MAY at its discretion either
continue the connection without client authentication, or abort the handshake
with an “unsupported_certificate” alert. Any given OID MUST NOT appear
more than once in the filters list.</t>
</list></t>

<t>PKIX RFCs define a variety of certificate extension OIDs and their corresponding
value types. Depending on the type, matching certificate extension values are
not necessarily bitwise-equal. It is expected that TLS implementations will rely
on their PKI libraries to perform certificate selection using certificate
extension OIDs.</t>

<t>This document defines matching rules for two standard certificate extensions
defined in <xref target="RFC5280"/>:</t>

<t><list style="symbols">
  <t>The Key Usage extension in a certificate matches the request when all key
usage bits asserted in the request are also asserted in the Key Usage
certificate extension.</t>
  <t>The Extended Key Usage extension in a certificate matches the request when all
key purpose OIDs present in the request are also found in the Extended Key
Usage certificate extension. The special anyExtendedKeyUsage OID MUST NOT be
used in the request.</t>
</list></t>

<t>Separate specifications may define matching rules for other certificate
extensions.</t>

</section>
<section anchor="post_handshake_auth" title="Post-Handshake Client Authentication">

<t>The “post_handshake_auth” extension is used to indicate that a client is willing
to perform post-handshake authentication (<xref target="post-handshake-authentication"/>). Servers
MUST NOT send a post-handshake CertificateRequest to clients which do not
offer this extension. Servers MUST NOT send this extension.</t>

<figure><artwork><![CDATA[
   struct {} PostHandshakeAuth;
]]></artwork></figure>

<t>The “extension_data” field of the “post_handshake_auth” extension is zero
length.</t>

</section>
<section anchor="negotiated-groups" title="Negotiated Groups">

<t>When sent by the client, the “supported_groups” extension indicates
the named groups which the client supports for key exchange, ordered
from most preferred to least preferred.</t>

<t>Note: In versions of TLS prior to TLS 1.3, this extension was named
“elliptic_curves” and only contained elliptic curve groups. See <xref target="RFC4492"/> and
<xref target="RFC7919"/>. This extension was also used to negotiate
ECDSA curves. Signature algorithms are now negotiated independently (see
<xref target="signature-algorithms"/>).</t>

<t>The “extension_data” field of this extension contains a
“NamedGroupList” value:</t>

<figure><artwork><![CDATA[
   enum {

       /* Elliptic Curve Groups (ECDHE) */
       secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
       x25519(0x001D), x448(0x001E),

       /* Finite Field Groups (DHE) */
       ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
       ffdhe6144(0x0103), ffdhe8192(0x0104),

       /* Reserved Code Points */
       ffdhe_private_use(0x01FC..0x01FF),
       ecdhe_private_use(0xFE00..0xFEFF),
       (0xFFFF)
   } NamedGroup;

   struct {
       NamedGroup named_group_list<2..2^16-1>;
   } NamedGroupList;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='Elliptic Curve Groups (ECDHE)'>
  Indicates support for the corresponding named curve, defined
either in FIPS 186-4 <xref target="DSS"/> or in <xref target="RFC7748"/>.
Values 0xFE00 through 0xFEFF are reserved for private use.</t>
  <t hangText='Finite Field Groups (DHE)'>
  Indicates support of the corresponding finite field
group, defined in <xref target="RFC7919"/>.
Values 0x01FC through 0x01FF are reserved for private use.</t>
</list></t>

<t>Items in named_group_list are ordered according to the client’s
preferences (most preferred choice first).</t>

<t>As of TLS 1.3, servers are permitted to send the “supported_groups”
extension to the client. Clients MUST NOT act upon any information
found in “supported_groups” prior to successful completion of the
handshake but MAY use the information learned from a successfully
completed handshake to change what groups they use in their
“key_share” extension in subsequent connections.
If the server has a group it prefers to the
ones in the “key_share” extension but is still willing to accept the
ClientHello, it SHOULD send “supported_groups” to update the client’s
view of its preferences; this extension SHOULD contain all groups
the server supports, regardless of whether they are currently
supported by the client.</t>

</section>
<section anchor="key-share" title="Key Share">

<t>The “key_share” extension contains the endpoint’s cryptographic parameters.</t>

<t>Clients MAY send an empty client_shares vector in order to request
group selection from the server at the cost of an additional round trip.
(see <xref target="hello-retry-request"/>)</t>

<figure><artwork><![CDATA[
   struct {
       NamedGroup group;
       opaque key_exchange<1..2^16-1>;
   } KeyShareEntry;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='group'>
  The named group for the key being exchanged.</t>
  <t hangText='key_exchange'>
  Key exchange information.  The contents of this field are
determined by the specified group and its corresponding
definition.
Finite Field Diffie-Hellman <xref target="DH"/> parameters are described in
<xref target="ffdhe-param"/>; Elliptic Curve Diffie-Hellman parameters are
described in <xref target="ecdhe-param"/>.</t>
</list></t>

<t>In the ClientHello message, the “extension_data” field of this extension
contains a “KeyShareClientHello” value:</t>

<figure><artwork><![CDATA[
   struct {
       KeyShareEntry client_shares<0..2^16-1>;
   } KeyShareClientHello;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='client_shares'>
  A list of offered KeyShareEntry values in descending order of client preference.</t>
</list></t>

<t>This vector MAY be empty if the client is requesting a HelloRetryRequest.
Each KeyShareEntry value MUST correspond to a group offered in the
“supported_groups” extension and MUST appear in the same order.  However, the
values MAY be a non-contiguous subset of the “supported_groups” extension and
MAY omit the most preferred groups. Such a situation could arise if the most
preferred groups are new and unlikely to be supported in enough places to
make pregenerating key shares for them efficient.</t>

<t>Clients can offer as many KeyShareEntry values as the number of supported
groups it is offering, each
representing a single set of key exchange parameters. For instance, a
client might offer shares for several elliptic curves or multiple
FFDHE groups.  The key_exchange values for each KeyShareEntry MUST be
generated independently.  Clients MUST NOT offer multiple
KeyShareEntry values for the same group.  Clients MUST NOT offer any
KeyShareEntry values for groups not listed in the client’s
“supported_groups” extension.  Servers MAY check for violations of
these rules and abort the handshake with an “illegal_parameter” alert
if one is violated.</t>

<t>In a HelloRetryRequest message, the “extension_data” field of this
extension contains a KeyShareHelloRetryRequest value:</t>

<figure><artwork><![CDATA[
   struct {
       NamedGroup selected_group;
   } KeyShareHelloRetryRequest;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='selected_group'>
  The mutually supported group the server intends to negotiate and
is requesting a retried ClientHello/KeyShare for.</t>
</list></t>

<t>Upon receipt of this extension in a HelloRetryRequest, the client MUST
verify that (1) the selected_group field corresponds to a group which was provided
in the “supported_groups” extension in the original ClientHello; and (2)
the selected_group field does not correspond to a group which was
provided in the “key_share” extension in the original ClientHello. If either of
these checks fails, then the client MUST abort the handshake with an
“illegal_parameter” alert.  Otherwise, when sending the new ClientHello, the
client MUST replace the original “key_share” extension with one
containing only a new KeyShareEntry for the group indicated in the
selected_group field of the triggering HelloRetryRequest.</t>

<t>In a ServerHello message, the “extension_data” field of this
extension contains a KeyShareServerHello value:</t>

<figure><artwork><![CDATA[
   struct {
       KeyShareEntry server_share;
   } KeyShareServerHello;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='server_share'>
  A single KeyShareEntry value that is in the same group as one of the
client’s shares.</t>
</list></t>

<t>If using (EC)DHE key establishment, servers offer exactly one
KeyShareEntry in the ServerHello. This value MUST be in the same group
as the KeyShareEntry value offered
by the client that the server has selected for the negotiated key exchange.
Servers MUST NOT send a KeyShareEntry for any group not
indicated in the “supported_groups” extension and
MUST NOT send a KeyShareEntry when using the “psk_ke” PskKeyExchangeMode.
If using (EC)DHE key establishment, and a HelloRetryRequest containing a
“key_share” extension was received by the client, the client MUST verify that the
selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest.
If this check fails, the client MUST abort the handshake with an “illegal_parameter”
alert.</t>

<section anchor="ffdhe-param" title="Diffie-Hellman Parameters">

<t>Diffie-Hellman <xref target="DH"/> parameters for both clients and servers are encoded in
the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.
The opaque value contains the
Diffie-Hellman public value (Y = g^X mod p) for the specified group
(see <xref target="RFC7919"/> for group definitions)
encoded as a big-endian integer and padded to the left with zeros to the size of p in
bytes.</t>

<t>Note: For a given Diffie-Hellman group, the padding results in all public keys
having the same length.</t>

<t>Peers MUST validate each other’s public key Y by ensuring that 1 &lt; Y
&lt; p-1. This check ensures that the remote peer is properly behaved and
isn’t forcing the local system into a small subgroup.</t>

</section>
<section anchor="ecdhe-param" title="ECDHE Parameters">

<t>ECDHE parameters for both clients and servers are encoded in the
opaque key_exchange field of a KeyShareEntry in a KeyShare structure.</t>

<t>For secp256r1, secp384r1 and secp521r1, the contents are the serialized
value of the following struct:</t>

<figure><artwork><![CDATA[
   struct {
       uint8 legacy_form = 4;
       opaque X[coordinate_length];
       opaque Y[coordinate_length];
   } UncompressedPointRepresentation;
]]></artwork></figure>

<t>X and Y respectively are the binary representations of the x and y
values in network byte order.  There are no internal length markers,
so each number representation occupies as many octets as implied by
the curve parameters.  For P-256 this means that each of X and Y use
32 octets, padded on the left by zeros if necessary.  For P-384 they
take 48 octets each, and for P-521 they take 66 octets each.</t>

<t>For the curves secp256r1, secp384r1 and secp521r1,
peers MUST validate each other’s public value Q by ensuring
that the point is a valid point on the elliptic curve.
The appropriate validation procedures are defined in Section 4.3.7 of <xref target="X962"/>
and alternatively in Section 5.6.2.3 of <xref target="KEYAGREEMENT"/>.
This process consists of three
steps: (1) verify that Q is not the point at infinity (O), (2) verify
that for Q = (x, y) both integers x and y are in the correct interval, (3)
ensure that (x, y) is a correct solution to the elliptic curve
equation.  For these curves, implementers do not need to verify
membership in the correct subgroup.</t>

<t>For X25519 and X448, the contents of the public value are the byte string inputs and outputs of the
corresponding functions defined in <xref target="RFC7748"/>, 32 bytes for X25519 and 56
bytes for X448.</t>

<t>Note: Versions of TLS prior to 1.3 permitted point format negotiation;
TLS 1.3 removes this feature in favor of a single point format
for each curve.</t>

</section>
</section>
<section anchor="pre-shared-key-exchange-modes" title="Pre-Shared Key Exchange Modes">

<t>In order to use PSKs, clients MUST also send a “psk_key_exchange_modes”
extension. The semantics of this extension are that the client only
supports the use of PSKs with these modes, which restricts both the
use of PSKs offered in this ClientHello and those which the server
might supply via NewSessionTicket.</t>

<t>A client MUST provide a “psk_key_exchange_modes” extension if it offers
a “pre_shared_key” extension. If clients offer “pre_shared_key” without
a “psk_key_exchange_modes” extension, servers MUST abort the handshake.
Servers MUST NOT select a key exchange mode that is not listed by the
client. This extension also restricts the modes for use with PSK resumption;
servers SHOULD NOT send NewSessionTicket with tickets that are not
compatible with the advertised modes; however, if a server does so, the impact
will just be that the client’s attempts at resumption fail.</t>

<t>The server MUST NOT send a “psk_key_exchange_modes” extension.</t>

<figure><artwork><![CDATA[
   enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

   struct {
       PskKeyExchangeMode ke_modes<1..255>;
   } PskKeyExchangeModes;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='psk_ke'>
  PSK-only key establishment. In this mode, the server MUST NOT
supply a “key_share” value.</t>
  <t hangText='psk_dhe_ke'>
  PSK with (EC)DHE key establishment. In this mode,
the client and server MUST supply “key_share” values as described
in <xref target="key-share"/>.</t>
</list></t>

<t>Any future values that are allocated must ensure that the transmitted
protocol messages unambiguously identify which mode was selected by
the server; at present, this is indicated by the presence of the “key_share”
in the ServerHello.</t>

</section>
<section anchor="early-data-indication" title="Early Data Indication">

<t>When a PSK is used and early data is allowed for that PSK, the client can send application data
in its first flight of messages. If the client opts to do so, it MUST
supply both the “early_data” extension as well as the “pre_shared_key”
extension.</t>

<t>The “extension_data” field of this extension contains an
“EarlyDataIndication” value.</t>

<figure><artwork><![CDATA[
   struct {} Empty;

   struct {
       select (Handshake.msg_type) {
           case new_session_ticket:   uint32 max_early_data_size;
           case client_hello:         Empty;
           case encrypted_extensions: Empty;
       };
   } EarlyDataIndication;
]]></artwork></figure>

<t>See <xref target="NSTMessage"/> for the use of the max_early_data_size field.</t>

<t>The parameters for the 0-RTT data (version, symmetric cipher suite, ALPN
protocol, etc.) are those associated with the PSK in use.
For externally provisioned PSKs, the associated values are those
provisioned along with the key.  For PSKs established via a NewSessionTicket
message, the associated values are those which were negotiated in the connection
which established the PSK. The PSK used to encrypt the early data
MUST be the first PSK listed in the client’s “pre_shared_key” extension.</t>

<t>For PSKs provisioned via NewSessionTicket, a server MUST validate that
the ticket age for the selected PSK identity (computed by subtracting
ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32)
is within a small tolerance of the
time since the ticket was issued (see <xref target="anti-replay"/>).  If it is not,
the server SHOULD proceed with the handshake but reject 0-RTT, and
SHOULD NOT take any other action that assumes that this ClientHello is
fresh.</t>

<t>0-RTT messages sent in the first flight have the same (encrypted) content types
as messages of the same type sent in other flights (handshake and
application_data) but are protected under
different keys.  After receiving the server’s Finished message, if the
server has accepted early data, an EndOfEarlyData message
will be sent to indicate the key change. This message will be encrypted
with the 0-RTT traffic keys.</t>

<t>A server which receives an “early_data” extension
MUST behave in one of three ways:</t>

<t><list style="symbols">
  <t>Ignore the extension and return a regular 1-RTT response.  The server then
skips past early data by attempting to deprotect received records using the handshake traffic
key, discarding records which fail deprotection (up to the configured max_early_data_size).
Once a record is deprotected
successfully, it is treated as the start of the client’s second flight
and the the server proceeds as with an ordinary 1-RTT handshake.</t>
  <t>Request that the client send another ClientHello by responding with a
HelloRetryRequest.  A client MUST NOT include the “early_data” extension in
its followup ClientHello.  The server then ignores early data by skipping
all records with external content type of “application_data” (indicating
that they are encrypted), up to the configured max_early_data_size.</t>
  <t>Return its own “early_data” extension in EncryptedExtensions,
indicating that it intends to
process the early data. It is not possible for the server
to accept only a subset of the early data messages.
Even though the server sends a message accepting early data, the actual early
data itself may already be in flight by the time the server generates this message.</t>
</list></t>

<t>In order to accept early data, the server MUST have accepted a
PSK cipher suite and selected the first key offered in the
client’s “pre_shared_key” extension. In addition, it MUST verify that
the following values are the same as those associated with the selected
PSK:</t>

<t><list style="symbols">
  <t>The TLS version number</t>
  <t>The selected cipher suite</t>
  <t>The selected ALPN <xref target="RFC7301"/> protocol, if any</t>
</list></t>

<t>These requirements are a superset of those needed to perform a 1-RTT
handshake using the PSK in question.  For externally established PSKs, the
associated values are those provisioned along with the key.  For PSKs
established via a NewSessionTicket message, the associated values are those
negotiated in the connection during which the ticket was established.</t>

<t>Future extensions MUST define their interaction with 0-RTT.</t>

<t>If any of these checks fail, the server MUST NOT respond
with the extension and must discard all the first
flight data using one of the first two mechanisms listed above
(thus falling back to 1-RTT or 2-RTT). If the client attempts
a 0-RTT handshake but the server rejects it, the server will generally
not have the 0-RTT record protection keys and must instead
use trial decryption (either with the 1-RTT handshake keys or
by looking for a cleartext ClientHello in the case of HelloRetryRequest) to
find the first non-0-RTT message.</t>

<t>If the server chooses to accept the “early_data” extension,
then it MUST comply with the same error handling requirements
specified for all records when processing early data records.
Specifically, if the server fails to decrypt a 0-RTT record following
an accepted “early_data” extension it MUST terminate the connection
with a “bad_record_mac” alert as per <xref target="record-payload-protection"/>.</t>

<t>If the server rejects the “early_data” extension, the client
application MAY opt to retransmit the application data previously
sent in early data once the handshake has
been completed.  Note that automatic re-transmission of early data
could result in assumptions about the status of the connection being
incorrect. For instance, when the negotiated connection selects a
different ALPN protocol from what was used for the early data, an
application might need to construct different messages.  Similarly, if
early data assumes anything about the connection state, it might be
sent in error after the handshake completes.</t>

<t>A TLS implementation SHOULD NOT automatically re-send early data;
applications are in a better position to decide when re-transmission
is appropriate. A TLS implementation MUST NOT automatically re-send
early data unless the negotiated connection selects the same ALPN
protocol.</t>

</section>
<section anchor="pre-shared-key-extension" title="Pre-Shared Key Extension">

<t>The “pre_shared_key” extension is used to negotiate the identity of the
pre-shared key to be used with a given handshake in association
with PSK key establishment.</t>

<t>The “extension_data” field of this extension contains a
“PreSharedKeyExtension” value:</t>

<figure><artwork><![CDATA[
   struct {
       opaque identity<1..2^16-1>;
       uint32 obfuscated_ticket_age;
   } PskIdentity;

   opaque PskBinderEntry<32..255>;

   struct {
       PskIdentity identities<7..2^16-1>;
       PskBinderEntry binders<33..2^16-1>;
   } OfferedPsks;

   struct {
       select (Handshake.msg_type) {
           case client_hello: OfferedPsks;
           case server_hello: uint16 selected_identity;
       };
   } PreSharedKeyExtension;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='identity'>
  A label for a key. For instance, a ticket defined
in <xref target="ticket-establishment"/> or a label for a pre-shared key
established externally.</t>
  <t hangText='obfuscated_ticket_age'>
  An obfuscated version of the age of the key.
<xref target="ticket-age"/> describes how to form this value
for identities established via the NewSessionTicket message.
For identities established externally an obfuscated_ticket_age of 0
SHOULD be used, and servers MUST ignore the value.</t>
  <t hangText='identities'>
  A list of the identities that the client is willing
to negotiate with the server. If sent alongside the “early_data”
extension (see <xref target="early-data-indication"/>), the first identity is the
one used for 0-RTT data.</t>
  <t hangText='binders'>
  A series of HMAC values, one for
each PSK offered in the “pre_shared_keys” extension and in the same
order, computed as described below.</t>
  <t hangText='selected_identity'>
  The server’s chosen identity expressed as a (0-based) index into
the identities in the client’s list.</t>
</list></t>

<t>Each PSK is associated with a single Hash algorithm. For PSKs established
via the ticket mechanism (<xref target="NSTMessage"/>), this is the KDF Hash algorithm
on the connection where the ticket was established.
For externally established PSKs, the Hash algorithm MUST be set when the
PSK is established, or default to SHA-256 if no such algorithm
is defined. The server MUST ensure that it selects a compatible
PSK (if any) and cipher suite.</t>

<t>In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was
intended to be associated with the session (Section 3 of <xref target="RFC6066"/>), with the
server being required to enforce that the SNI value associated with the session
matches the one specified in the resumption handshake.  However, in reality the
implementations were not consistent on which of two supplied SNI values they
would use, leading to the consistency requirement being de-facto enforced by the
clients.  In TLS 1.3, the SNI value is always explicitly specified in the
resumption handshake, and there is no need for the server to associate an SNI value with the
ticket. Clients, however, SHOULD store the SNI with the PSK to fulfill
the requirements of <xref target="NSTMessage"/>.</t>

<t>Implementor’s note: when session resumption is the primary use case of PSKs
the most straightforward way to implement the
PSK/cipher suite matching requirements is to negotiate the cipher
suite first and then exclude any incompatible PSKs. Any unknown PSKs
(e.g., they are not in the PSK database or are encrypted with an
unknown key) SHOULD simply be ignored. If no acceptable PSKs are
found, the server SHOULD perform a non-PSK handshake if possible.
If backwards compatibility is important, client provided, externally
established PSKs SHOULD influence cipher suite selection.</t>

<t>Prior to accepting PSK key establishment, the server MUST validate the
corresponding binder value (see <xref target="psk-binder"/> below). If this value is
not present or does not validate, the server MUST abort the handshake.
Servers SHOULD NOT attempt to validate multiple binders; rather they
SHOULD select a single PSK and validate solely the binder that
corresponds to that PSK.
See [<xref target="client-hello-recording"/>] and [<xref target="psk-identity-exposure"/>] for the
security rationale for this requirement.
In order to accept PSK key establishment, the
server sends a “pre_shared_key” extension indicating the selected
identity.</t>

<t>Clients MUST verify that the server’s selected_identity is within the
range supplied by the client, that the server selected a cipher suite
indicating a Hash associated with the PSK and that a server
“key_share” extension is present if required by the
ClientHello “psk_key_exchange_modes”. If these values are not
consistent the client MUST abort the handshake with an
“illegal_parameter” alert.</t>

<t>If the server supplies an “early_data” extension, the client MUST
verify that the server’s selected_identity is 0. If any
other value is returned, the client MUST abort the handshake
with an “illegal_parameter” alert.</t>

<t>The “pre_shared_key” extension MUST be the last extension in the
ClientHello (this facilitates implementation as described
below). Servers MUST check that it is the last extension and otherwise
fail the handshake with an “illegal_parameter” alert.</t>

<section anchor="ticket-age" title="Ticket Age">

<t>The client’s view of the age of a ticket is the time since the receipt
of the NewSessionTicket message. Clients MUST NOT attempt to use
tickets which have ages greater than the “ticket_lifetime” value which
was provided with the ticket. The “obfuscated_ticket_age” field of
each PskIdentity contains an obfuscated version of the ticket age
formed by taking the age in milliseconds and adding the “ticket_age_add”
value that was included with the ticket (see <xref target="NSTMessage"/>), modulo 2^32.
This addition prevents passive observers from correlating connections
unless tickets are reused. Note that the “ticket_lifetime” field in
the NewSessionTicket message is in seconds but the “obfuscated_ticket_age”
is in milliseconds. Because ticket lifetimes are
restricted to a week, 32 bits is enough to represent any plausible
age, even in milliseconds.</t>

</section>
<section anchor="psk-binder" title="PSK Binder">

<t>The PSK binder value forms a binding between a PSK and the current
handshake, as well as a binding between the handshake in which the PSK was
generated (if via a NewSessionTicket message) and the current handshake.
Each entry in the binders list is computed as an HMAC
over a transcript hash (see <xref target="the-transcript-hash"/>) containing a partial ClientHello
up to and including the PreSharedKeyExtension.identities field. That
is, it includes all of the ClientHello but not the binders list
itself. The length fields for the message (including the overall
length, the length of the extensions block, and the length of the
“pre_shared_key” extension) are all set as if binders of the correct
lengths were present.</t>

<t>The PskBinderEntry is computed in the same way as the Finished
message (<xref target="finished"/>) but with the BaseKey being the binder_key
derived via the key schedule from the corresponding PSK which
is being offered (see <xref target="key-schedule"/>).</t>

<t>If the handshake includes a HelloRetryRequest, the initial ClientHello
and HelloRetryRequest are included in the transcript along with the
new ClientHello.  For instance, if the client sends ClientHello1, its
binder will be computed over:</t>

<figure><artwork><![CDATA[
   Transcript-Hash(Truncate(ClientHello1))
]]></artwork></figure>

<t>Where Truncate() removes the binders list from the ClientHello.</t>

<t>If the server responds with HelloRetryRequest, and the client then sends
ClientHello2, its binder will be computed over:</t>

<figure><artwork><![CDATA[
   Transcript-Hash(ClientHello1,
                   HelloRetryRequest,
                   Truncate(ClientHello2))
]]></artwork></figure>

<t>The full ClientHello1/ClientHello2 is included in all other handshake hash computations.
Note that in the first flight, Truncate(ClientHello1) is hashed directly,
but in the second flight, ClientHello1 is hashed and then reinjected as a
“message_hash” message, as described in <xref target="the-transcript-hash"/>.</t>

</section>
<section anchor="processing-order" title="Processing Order">

<t>Clients are permitted to “stream” 0-RTT data until they
receive the server’s Finished, only then sending the EndOfEarlyData
message, followed by the rest of the handshake.
In order to avoid deadlocks, when accepting “early_data”,
servers MUST process the client’s ClientHello and then immediately
send their flight of messages, rather than waiting for the client’s
EndOfEarlyData message before sending its ServerHello.</t>

</section>
</section>
</section>
<section anchor="server-parameters" title="Server Parameters">

<t>The next two messages from the server, EncryptedExtensions and
CertificateRequest, contain information from the server
that determines the rest of the handshake. These messages
are encrypted with keys derived from the server_handshake_traffic_secret.</t>

<section anchor="encrypted-extensions" title="Encrypted Extensions">

<t>In all handshakes, the server MUST send the
EncryptedExtensions message immediately after the
ServerHello message. This is the first message that is encrypted
under keys derived from the server_handshake_traffic_secret.</t>

<t>The EncryptedExtensions message contains extensions
that can be protected, i.e., any which are not needed to
establish the cryptographic context, but which are not
associated with individual certificates. The client
MUST check EncryptedExtensions for the presence of any forbidden
extensions and if any are found MUST abort the handshake with an
“illegal_parameter” alert.</t>

<t>Structure of this message:</t>

<figure><artwork><![CDATA[
   struct {
       Extension extensions<0..2^16-1>;
   } EncryptedExtensions;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='extensions'>
  A list of extensions. For more information, see the table in <xref target="extensions"/>.</t>
</list></t>

</section>
<section anchor="certificate-request" title="Certificate Request">

<t>A server which is authenticating with a certificate MAY optionally
request a certificate from the client. This message, if sent, MUST
follow EncryptedExtensions.</t>

<t>Structure of this message:</t>

<figure><artwork><![CDATA[
   struct {
       opaque certificate_request_context<0..2^8-1>;
       Extension extensions<2..2^16-1>;
   } CertificateRequest;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='certificate_request_context'>
  An opaque string which identifies the certificate request and
which will be echoed in the client’s Certificate message. The
certificate_request_context MUST be unique within the scope
of this connection (thus preventing replay of client
CertificateVerify messages). This field SHALL be zero length
unless used for the post-handshake authentication exchanges
described in <xref target="post-handshake-authentication"/>.
When requesting post-handshake authentication, the server SHOULD
make the context unpredictable to the client (e.g., by
randomly generating it) in order to prevent an attacker who
has temporary access to the client’s private key from
pre-computing valid CertificateVerify messages.</t>
  <t hangText='extensions'>
  A set of extensions describing the parameters of the
certificate being requested. The “signature_algorithms”
extension MUST be specified, and other extensions may optionally be
included if defined for this message.
Clients MUST ignore unrecognized extensions.</t>
</list></t>

<t>In prior versions of TLS, the CertificateRequest message
carried a list of signature algorithms and certificate authorities
which the server would accept. In TLS 1.3 the former is expressed
by sending the “signature_algorithms” and optionally “signature_algorithms_cert”
extensions. The latter is
expressed by sending the “certificate_authorities” extension
(see <xref target="certificate-authorities"/>).</t>

<t>Servers which are authenticating with a PSK MUST NOT send the
CertificateRequest message in the main handshake, though they
MAY send it in post-handshake authentication (see <xref target="post-handshake-authentication"/>)
provided that the client has sent the “post_handshake_auth”
extension (see <xref target="post_handshake_auth"/>).</t>

</section>
</section>
<section anchor="authentication-messages" title="Authentication Messages">

<t>As discussed in <xref target="protocol-overview"/>, TLS generally uses a common
set of messages for authentication, key confirmation, and handshake
integrity: Certificate, CertificateVerify, and Finished.
(The PreSharedKey binders also perform key confirmation, in a
similar fashion.) These three
messages are always sent as the last messages in their handshake
flight. The Certificate and CertificateVerify messages are only
sent under certain circumstances, as defined below. The Finished
message is always sent as part of the Authentication block.
These messages are encrypted under keys derived from
[sender]_handshake_traffic_secret.</t>

<t>The computations for the Authentication messages all uniformly
take the following inputs:</t>

<t><list style="symbols">
  <t>The certificate and signing key to be used.</t>
  <t>A Handshake Context consisting of the set of messages to be
included in the transcript hash.</t>
  <t>A base key to be used to compute a MAC key.</t>
</list></t>

<t>Based on these inputs, the messages then contain:</t>

<t><list style="hanging">
  <t hangText='Certificate'>
  The certificate to be used for authentication, and any
supporting certificates in the chain. Note that certificate-based
client authentication is not available in PSK (including 0-RTT) flows.</t>
  <t hangText='CertificateVerify'>
  A signature over the value Transcript-Hash(Handshake Context, Certificate)</t>
  <t hangText='Finished'>
  A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify)
using a MAC key derived from the base key.</t>
</list></t>

<t>The following table defines the Handshake Context and MAC Base Key
for each scenario:</t>

<texttable>
      <ttcol align='left'>Mode</ttcol>
      <ttcol align='left'>Handshake Context</ttcol>
      <ttcol align='left'>Base Key</ttcol>
      <c>Server</c>
      <c>ClientHello … later of EncryptedExtensions/CertificateRequest</c>
      <c>server_handshake_traffic_secret</c>
      <c>Client</c>
      <c>ClientHello … later of server Finished/EndOfEarlyData</c>
      <c>client_handshake_traffic_secret</c>
      <c>Post-Handshake</c>
      <c>ClientHello … client Finished + CertificateRequest</c>
      <c>client_application_traffic_secret_N</c>
</texttable>

<section anchor="the-transcript-hash" title="The Transcript Hash">

<t>Many of the cryptographic computations in TLS make use of a transcript
hash. This value is computed by hashing the concatenation of
each included handshake message, including the handshake
message header carrying the handshake message type and length fields,
but not including record layer headers. I.e.,</t>

<figure><artwork><![CDATA[
 Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)
]]></artwork></figure>

<t>As an exception to this general rule, when the server responds to a
ClientHello with a HelloRetryRequest, the value of ClientHello1 is
replaced with a special synthetic handshake message of handshake
type “message_hash” containing Hash(ClientHello1). I.e.,</t>

<figure><artwork><![CDATA[
 Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
     Hash(message_hash ||        /* Handshake type */
          00 00 Hash.length ||   /* Handshake message length (bytes) */
          Hash(ClientHello1) ||  /* Hash of ClientHello1 */
          HelloRetryRequest || ... || Mn)
]]></artwork></figure>

<t>The reason for this construction is to allow the server to do a
stateless HelloRetryRequest by storing just the hash of ClientHello1
in the cookie, rather than requiring it to export the entire intermediate
hash state (see <xref target="cookie"/>).</t>

<t>For concreteness, the transcript hash is always taken from the
following sequence of handshake messages, starting at the first
ClientHello and including only those messages that were sent:
ClientHello, HelloRetryRequest, ClientHello, ServerHello,
EncryptedExtensions, server CertificateRequest, server Certificate,
server CertificateVerify, server Finished, EndOfEarlyData, client
Certificate, client CertificateVerify, client Finished.</t>

<t>In general, implementations can implement the transcript by keeping a
running transcript hash value based on the negotiated hash. Note,
however, that subsequent post-handshake authentications do not include
each other, just the messages through the end of the main handshake.</t>

</section>
<section anchor="certificate" title="Certificate">

<t>This message conveys the endpoint’s certificate chain to the peer.</t>

<t>The server MUST send a Certificate message whenever the agreed-upon
key exchange method uses certificates for authentication (this
includes all key exchange methods defined in this document except PSK).</t>

<t>The client MUST send a Certificate message if and only if the server has
requested client authentication via a CertificateRequest message
(<xref target="certificate-request"/>). If the server requests client authentication
but no suitable certificate is available, the client
MUST send a Certificate message containing no certificates (i.e., with
the “certificate_list” field having length 0).  A Finished message MUST
be sent regardless of whether the Certificate message is empty.</t>

<t>Structure of this message:</t>

<figure><artwork><![CDATA[
   /* Managed by IANA */
   enum {
       X509(0),
       RawPublicKey(2),
       (255)
   } CertificateType;

   struct {
       select (certificate_type) {
           case RawPublicKey:
             /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
             opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

           case X509:
             opaque cert_data<1..2^24-1>;
       };
       Extension extensions<0..2^16-1>;
   } CertificateEntry;

   struct {
       opaque certificate_request_context<0..2^8-1>;
       CertificateEntry certificate_list<0..2^24-1>;
   } Certificate;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='certificate_request_context'>
  If this message is in response to a CertificateRequest, the
value of certificate_request_context in that message. Otherwise
(in the case of server authentication), this field SHALL be zero length.</t>
  <t hangText='certificate_list'>
  This is a sequence (chain) of CertificateEntry structures, each
containing a single certificate and set of extensions.</t>
  <t hangText='extensions:'>
  A set of extension values for the CertificateEntry. The “Extension”
format is defined in <xref target="extensions"/>. Valid extensions for server certificates
at present include OCSP Status extension (<xref target="RFC6066"/>) and
SignedCertificateTimestamps (<xref target="RFC6962"/>); future extensions may
be defined for this message as well. Extensions in the Certificate
message from the server MUST correspond to ones from the ClientHello message.
Extensions in the Certificate from the client MUST correspond with
extensions in the CertificateRequest message from the server.
If an extension applies to the entire chain, it SHOULD be included
in the first CertificateEntry.</t>
</list></t>

<t>If the corresponding certificate type extension
(“server_certificate_type” or “client_certificate_type”) was not negotiated
in Encrypted Extensions, or the X.509 certificate type was negotiated, then each
CertificateEntry contains a DER-encoded X.509 certificate. The sender’s
certificate MUST come in the first CertificateEntry in the list.  Each
following certificate SHOULD directly certify the one immediately preceding it.
Because certificate validation requires that trust anchors be
distributed independently, a certificate that specifies a trust anchor
MAY be omitted from the chain, provided that supported peers are known
to possess any omitted certificates.</t>

<t>Note: Prior to TLS 1.3, “certificate_list” ordering required each certificate
to certify the one immediately preceding it;
however, some implementations allowed some flexibility. Servers sometimes send
both a current and deprecated intermediate for transitional purposes, and others
are simply configured incorrectly, but these cases can nonetheless be validated
properly. For maximum compatibility, all implementations SHOULD be prepared to
handle potentially extraneous certificates and arbitrary orderings from any TLS
version, with the exception of the end-entity certificate which MUST be first.</t>

<t>If the RawPublicKey certificate type was negotiated, then the
certificate_list MUST contain no more than one CertificateEntry, which
contains an ASN1_subjectPublicKeyInfo value as defined in <xref target="RFC7250"/>,
Section 3.</t>

<t>The OpenPGP certificate type <xref target="RFC6091"/> MUST NOT be used with TLS 1.3.</t>

<t>The server’s certificate_list MUST always be non-empty. A client will
send an empty certificate_list if it does not have an appropriate
certificate to send in response to the server’s authentication
request.</t>

<section anchor="ocsp-and-sct" title="OCSP Status and SCT Extensions">

<t><xref target="RFC6066"/> and <xref target="RFC6961"/> provide extensions to negotiate the server
sending OCSP responses to the client. In TLS 1.2 and below, the
server replies with an empty extension to indicate negotiation of this
extension and the OCSP information is carried in a CertificateStatus
message. In TLS 1.3, the server’s OCSP information is carried in
an extension in the CertificateEntry containing the associated
certificate. Specifically:
The body of the “status_request” extension
from the server MUST be a CertificateStatus structure as defined
in <xref target="RFC6066"/>, which is interpreted as defined in <xref target="RFC6960"/>.</t>

<t>Note: status_request_v2 extension (<xref target="RFC6961"/>) is deprecated. TLS 1.3 servers
MUST NOT act upon its presence or information in it when processing Client
Hello, in particular they MUST NOT send the status_request_v2 extension in the
Encrypted Extensions, Certificate Request or the Certificate messages.
TLS 1.3 servers MUST be able to process Client Hello messages that include it,
as it MAY be sent by clients that wish to use it in earlier protocol versions.</t>

<t>A server MAY request that a client present an OCSP response with its
certificate by sending an empty “status_request” extension in its
CertificateRequest message. If the client opts to send an OCSP response, the
body of its “status_request” extension MUST be a CertificateStatus structure as
defined in <xref target="RFC6066"/>.</t>

<t>Similarly, <xref target="RFC6962"/> provides a mechanism for a server to send a
Signed Certificate Timestamp (SCT) as an extension in the ServerHello
in TLS 1.2 and below.
In TLS 1.3, the server’s SCT information is carried in an extension in
CertificateEntry.</t>

</section>
<section anchor="server-certificate-selection" title="Server Certificate Selection">

<t>The following rules apply to the certificates sent by the server:</t>

<t><list style="symbols">
  <t>The certificate type MUST be X.509v3 <xref target="RFC5280"/>, unless explicitly negotiated
otherwise (e.g., <xref target="RFC7250"/>).</t>
  <t>The server’s end-entity certificate’s public key (and associated
restrictions) MUST be compatible with the selected authentication
algorithm from the client’s “signature_algorithms” extension
(currently RSA, ECDSA, or EdDSA).</t>
  <t>The certificate MUST allow the key to be used for signing (i.e., the
digitalSignature bit MUST be set if the Key Usage extension is present) with
a signature scheme indicated in the client’s “signature_algorithms”/”signature_algorithms_cert”
extensions (see <xref target="signature-algorithms"/>).</t>
  <t>The “server_name” <xref target="RFC6066"/> and “certificate_authorities” extensions are used to
guide certificate selection. As servers MAY require the presence of the “server_name”
extension, clients SHOULD send this extension, when applicable.</t>
</list></t>

<t>All certificates provided by the server MUST be signed by a
signature algorithm advertised by the client, if it is able to provide such
a chain (see <xref target="signature-algorithms"/>).
Certificates that are self-signed
or certificates that are expected to be trust anchors are not validated as
part of the chain and therefore MAY be signed with any algorithm.</t>

<t>If the server cannot produce a certificate chain that is signed only via the
indicated supported algorithms, then it SHOULD continue the handshake by sending
the client a certificate chain of its choice that may include algorithms
that are not known to be supported by the client.
This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general,
but MAY do so if the client’s advertisement permits it,
and MUST NOT do so otherwise.</t>

<t>If the client cannot construct an acceptable chain using the provided
certificates and decides to abort the handshake, then it MUST abort the
handshake with an appropriate certificate-related alert (by default,
“unsupported_certificate”; see <xref target="error-alerts"/> for more).</t>

<t>If the server has multiple certificates, it chooses one of them based on the
above-mentioned criteria (in addition to other criteria, such as transport
layer endpoint, local configuration and preferences).</t>

</section>
<section anchor="client-certificate-selection" title="Client Certificate Selection">

<t>The following rules apply to certificates sent by the client:</t>

<t><list style="symbols">
  <t>The certificate type MUST be X.509v3 <xref target="RFC5280"/>, unless explicitly negotiated
otherwise (e.g., <xref target="RFC7250"/>).</t>
  <t>If the “certificate_authorities” extension in the CertificateRequest
message was present, at least one of the certificates in the certificate
chain SHOULD be issued by one of the listed CAs.</t>
  <t>The certificates MUST be signed using an acceptable signature
algorithm, as described in <xref target="certificate-request"/>.  Note that this
relaxes the constraints on certificate-signing algorithms found in
prior versions of TLS.</t>
  <t>If the CertificateRequest message contained a non-empty “oid_filters”
extension, the end-entity certificate MUST match the extension OIDs
that are recognized by the client, as described in <xref target="oid-filters"/>.</t>
</list></t>

<t>Note that, as with the server certificate, there are certificates that use
algorithm combinations that cannot be currently used with TLS.</t>

</section>
<section anchor="receiving-a-certificate-message" title="Receiving a Certificate Message">

<t>In general, detailed certificate validation procedures are out of scope for
TLS (see <xref target="RFC5280"/>). This section provides TLS-specific requirements.</t>

<t>If the server supplies an empty Certificate message, the client MUST abort
the handshake with a “decode_error” alert.</t>

<t>If the client does not send any certificates (i.e., it sends an empty
Certificate message),
the server MAY at its discretion either continue the handshake without client
authentication, or abort the handshake with a “certificate_required” alert. Also, if some
aspect of the certificate chain was unacceptable (e.g., it was not signed by a
known, trusted CA), the server MAY at its discretion either continue the
handshake (considering the client unauthenticated) or abort the handshake.</t>

<t>Any endpoint receiving any certificate which it would need to validate
using any signature algorithm using an MD5 hash MUST abort the
handshake with a “bad_certificate” alert.  SHA-1 is deprecated and it
is RECOMMENDED that any endpoint receiving any certificate which it
would need to validate using any signature algorithm using a SHA-1
hash abort the handshake with a “bad_certificate” alert. For clarity,
this means that endpoints MAY accept these algorithms for
certificates that are self-signed or are trust anchors.</t>

<t>All endpoints are RECOMMENDED to transition to SHA-256 or better as soon
as possible to maintain interoperability with implementations
currently in the process of phasing out SHA-1 support.</t>

<t>Note that a certificate containing a key for one signature algorithm
MAY be signed using a different signature algorithm (for instance,
an RSA key signed with an ECDSA key).</t>

</section>
</section>
<section anchor="certificate-verify" title="Certificate Verify">

<t>This message is used to provide explicit proof that an endpoint
possesses the private key corresponding to its certificate.
The CertificateVerify message also provides integrity for the handshake up
to this point. Servers MUST send this message when authenticating via a certificate.
Clients MUST send this message whenever authenticating via a certificate (i.e., when
the Certificate message is non-empty). When sent, this message MUST appear immediately
after the Certificate message and immediately prior to the Finished message.</t>

<t>Structure of this message:</t>

<figure><artwork><![CDATA[
   struct {
       SignatureScheme algorithm;
       opaque signature<0..2^16-1>;
   } CertificateVerify;
]]></artwork></figure>

<t>The algorithm field specifies the signature algorithm used (see
<xref target="signature-algorithms"/> for the definition of this field). The
signature is a digital signature using that algorithm. The
content that is covered under the signature is the hash output as described in
<xref target="the-transcript-hash"/>, namely:</t>

<figure><artwork><![CDATA[
   Transcript-Hash(Handshake Context, Certificate)
]]></artwork></figure>

<t>The digital signature is then computed over the concatenation of:</t>

<t><list style="symbols">
  <t>A string that consists of octet 32 (0x20) repeated 64 times</t>
  <t>The context string</t>
  <t>A single 0 byte which serves as the separator</t>
  <t>The content to be signed</t>
</list></t>

<t>This structure is intended to prevent an attack on previous versions
of TLS in which the ServerKeyExchange format meant that
attackers could obtain a signature of a message with a chosen 32-byte
prefix (ClientHello.random). The initial 64-byte pad clears that prefix
along with the server-controlled ServerHello.random.</t>

<t>The context string for a server signature is:
“TLS 1.3, server CertificateVerify”
The context string for a client signature is:
“TLS 1.3, client CertificateVerify”
It is used to provide separation between signatures made in different
contexts, helping against potential cross-protocol attacks.</t>

<t>For example, if the transcript hash was 32 bytes of
01 (this length would make sense for SHA-256), the content covered by
the digital signature for a server CertificateVerify would be:</t>

<figure><artwork><![CDATA[
   2020202020202020202020202020202020202020202020202020202020202020
   2020202020202020202020202020202020202020202020202020202020202020
   544c5320312e332c207365727665722043657274696669636174655665726966
   79
   00
   0101010101010101010101010101010101010101010101010101010101010101
]]></artwork></figure>

<t>On the sender side the process for computing the signature field of the
CertificateVerify message takes as input:</t>

<t><list style="symbols">
  <t>The content covered by the digital signature</t>
  <t>The private signing key corresponding to the certificate sent in the
previous message</t>
</list></t>

<t>If the CertificateVerify message is sent by a server, the signature
algorithm MUST be one offered in the client’s “signature_algorithms” extension
unless no valid certificate chain can be produced without unsupported
algorithms (see <xref target="signature-algorithms"/>).</t>

<t>If sent by a client, the signature algorithm used in the signature
MUST be one of those present in the supported_signature_algorithms
field of the “signature_algorithms” extension in the CertificateRequest message.</t>

<t>In addition, the signature algorithm MUST be compatible with the key
in the sender’s end-entity certificate. RSA signatures MUST use an
RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms
appear in “signature_algorithms”. The SHA-1 algorithm MUST NOT be used
in any signatures of CertificateVerify messages.
All SHA-1 signature algorithms in this specification are defined solely
for use in legacy certificates and are not valid for CertificateVerify
signatures.</t>

<t>The receiver of a CertificateVerify message MUST verify the signature field.
The verification process takes as input:</t>

<t><list style="symbols">
  <t>The content covered by the digital signature</t>
  <t>The public key contained in the end-entity certificate found in the
associated Certificate message.</t>
  <t>The digital signature received in the signature field of the
CertificateVerify message</t>
</list></t>

<t>If the verification fails, the receiver MUST terminate the handshake
with a “decrypt_error” alert.</t>

</section>
<section anchor="finished" title="Finished">

<t>The Finished message is the final message in the authentication
block. It is essential for providing authentication of the handshake
and of the computed keys.</t>

<t>Recipients of Finished messages MUST verify that the contents are
correct and if incorrect MUST terminate the connection
with a “decrypt_error” alert.</t>

<t>Once a side has sent its Finished message and received and
validated the Finished message from its peer, it may begin to send and
receive application data over the connection. There are two
settings in which it is permitted to send data prior to
receiving the peer’s Finished:</t>

<t><list style="numbers">
  <t>Clients sending 0-RTT data as described in <xref target="early-data-indication"/>.</t>
  <t>Servers MAY send data after sending their first flight, but
because the handshake is not yet complete, they have no assurance
of either the peer’s identity or of its liveness (i.e.,
the ClientHello might have been replayed).</t>
</list></t>

<t>The key used to compute the Finished message is computed from the
Base key defined in <xref target="authentication-messages"/> using HKDF (see
<xref target="key-schedule"/>). Specifically:</t>

<figure><artwork><![CDATA[
finished_key =
    HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)
]]></artwork></figure>

<t>Structure of this message:</t>

<figure><artwork><![CDATA[
   struct {
       opaque verify_data[Hash.length];
   } Finished;
]]></artwork></figure>

<t>The verify_data value is computed as follows:</t>

<figure><artwork><![CDATA[
   verify_data =
       HMAC(finished_key,
            Transcript-Hash(Handshake Context,
                            Certificate*, CertificateVerify*))

   * Only included if present.
]]></artwork></figure>

<t>HMAC <xref target="RFC2104"/> uses the Hash algorithm for the handshake.
As noted above, the HMAC input can generally be implemented by a running
hash, i.e., just the handshake hash at this point.</t>

<t>In previous versions of TLS, the verify_data was always 12 octets long. In
TLS 1.3, it is the size of the HMAC output for the Hash used for the handshake.</t>

<t>Note: Alerts and any other record types are not handshake messages
and are not included in the hash computations.</t>

<t>Any records following a Finished message MUST be encrypted under the
appropriate application traffic key as described in <xref target="updating-traffic-keys"/>.
In particular, this includes any alerts sent by the
server in response to client Certificate and CertificateVerify messages.</t>

</section>
</section>
<section anchor="end-of-early-data" title="End of Early Data">

<figure><artwork><![CDATA[
   struct {} EndOfEarlyData;
]]></artwork></figure>

<t>If the server sent an “early_data” extension, the client MUST send an
EndOfEarlyData message after receiving the server Finished.  If the server does
not send an “early_data” extension, then the client MUST NOT send an
EndOfEarlyData message. This message indicates that all
0-RTT application_data messages, if any, have been transmitted and
that the following records are protected under handshake traffic keys.
Servers MUST NOT send this message and clients receiving it
MUST terminate the connection with an “unexpected_message” alert.
This message is encrypted under keys derived from the client_early_traffic_secret.</t>

</section>
<section anchor="post-handshake-messages" title="Post-Handshake Messages">

<t>TLS also allows other messages to be sent after the main handshake.
These messages use a handshake content type and are encrypted under the
appropriate application traffic key.</t>

<section anchor="NSTMessage" title="New Session Ticket Message">

<t>At any time after the server has received the client Finished message,
it MAY send a NewSessionTicket message. This message creates a unique
association between the ticket value and a secret PSK
derived from the resumption master secret (see <xref target="cryptographic-computations"/>.</t>

<t>The client MAY use this PSK for future handshakes by including the
ticket value in the “pre_shared_key” extension in its ClientHello
(<xref target="pre-shared-key-extension"/>). Servers MAY send multiple tickets on a
single connection, either immediately after each other or
after specific events (see <xref target="client-tracking"/>).
For instance, the server might send a new ticket after post-handshake
authentication in order to encapsulate the additional client
authentication state. Multiple tickets are useful for clients
for a variety of purposes, including:</t>

<t><list style="symbols">
  <t>Opening multiple parallel HTTP connections.</t>
  <t>Performing connection racing across interfaces and address families
via, e.g., Happy Eyeballs <xref target="RFC8305"/> or related techniques.</t>
</list></t>

<t>Any ticket MUST only be resumed with a cipher suite that has the
same KDF hash algorithm as that used to establish the original connection.</t>

<t>Clients MUST only resume if the new SNI value is valid for the server
certificate presented in the original session, and SHOULD only resume if
the SNI value matches the one used in the original session.  The latter
is a performance optimization: normally, there is no reason to expect
that different servers covered by a single certificate would be able to
accept each other’s tickets, hence attempting resumption in that case
would waste a single-use ticket.  If such an indication is provided
(externally or by any other means), clients MAY resume with a different
SNI value.</t>

<t>On resumption, if reporting an SNI value to the calling application,
implementations MUST use the value sent in the resumption ClientHello rather
than the value sent in the previous session. Note that if a server
implementation declines all PSK identities with different SNI values, these two
values are always the same.</t>

<t>Note: Although the resumption master secret depends on the client’s second
flight, servers which do not request client authentication MAY compute
the remainder of the transcript independently and then send a
NewSessionTicket immediately upon sending its Finished rather than
waiting for the client Finished.  This might be appropriate in cases
where the client is expected to open multiple TLS connections in
parallel and would benefit from the reduced overhead of a resumption
handshake, for example.</t>

<figure><artwork><![CDATA[
   struct {
       uint32 ticket_lifetime;
       uint32 ticket_age_add;
       opaque ticket_nonce<0..255>;
       opaque ticket<1..2^16-1>;
       Extension extensions<0..2^16-2>;
   } NewSessionTicket;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='ticket_lifetime'>
  Indicates the lifetime in seconds as a 32-bit unsigned integer in
network byte order from the time of ticket issuance.
Servers MUST NOT use any value greater than 604800 seconds (7 days).
The value of zero indicates that the ticket should be discarded
immediately. Clients MUST NOT cache tickets for longer than
7 days, regardless of the ticket_lifetime, and MAY delete tickets
earlier based on local policy. A server MAY treat a ticket as valid
for a shorter period of time than what is stated in the
ticket_lifetime.</t>
  <t hangText='ticket_age_add'>
  A securely generated, random 32-bit value that is used to obscure the age of
the ticket that the client includes in the “pre_shared_key” extension.
The client-side ticket age is added to this value modulo 2^32 to
obtain the value that is transmitted by the client.
The server MUST generate a fresh value for each ticket it sends.</t>
  <t hangText='ticket_nonce'>
  A per-ticket value that is unique across all tickets issued on this connection.</t>
  <t hangText='ticket'>
  The value of the ticket to be used as the PSK identity.
The ticket itself is an opaque label. It MAY either be a database
lookup key or a self-encrypted and self-authenticated value. Section
4 of <xref target="RFC5077"/> describes a recommended ticket construction mechanism.</t>
  <t hangText='extensions'>
  A set of extension values for the ticket. The “Extension”
format is defined in <xref target="extensions"/>. Clients MUST ignore
unrecognized extensions.</t>
</list></t>

<t>The sole extension currently defined for NewSessionTicket is
“early_data”, indicating that the ticket may be used to send 0-RTT data
(<xref target="early-data-indication"/>)). It contains the following value:</t>

<t><list style="hanging">
  <t hangText='max_early_data_size'>
  The maximum amount of 0-RTT data that the client is allowed to send when using
this ticket, in bytes. Only Application Data payload (i.e., plaintext but
not padding or the inner content type byte) is counted. A server
receiving more than max_early_data_size bytes of 0-RTT data
SHOULD terminate the connection with an “unexpected_message” alert.
Note that servers that reject early data due to lack of cryptographic material
will be unable to differentiate padding from content, so clients SHOULD NOT
depend on being able to send large quantities of padding in early data records.</t>
</list></t>

<t>The PSK associated with the ticket is computed as:</t>

<figure><artwork><![CDATA[
    HKDF-Expand-Label(resumption_master_secret,
                     "resumption", ticket_nonce, Hash.length)
]]></artwork></figure>

<t>Because the ticket_nonce value is distinct for each NewSessionTicket
message, a different PSK will be derived for each ticket.</t>

<t>Note that in principle it is possible to continue issuing new tickets
which indefinitely extend the lifetime of the keying
material originally derived from an initial non-PSK handshake (which
was most likely tied to the peer’s certificate). It is RECOMMENDED
that implementations place limits on the total lifetime of such keying
material; these limits should take into account the lifetime of the
peer’s certificate, the likelihood of intervening revocation,
and the time since the peer’s online CertificateVerify signature.</t>

</section>
<section anchor="post-handshake-authentication" title="Post-Handshake Authentication">

<t>When the client has sent the “post_handshake_auth” extension (see
<xref target="post_handshake_auth"/>), a server MAY request client authentication at any time
after the handshake has completed by sending a CertificateRequest message. The
client MUST respond with the appropriate Authentication messages (see
<xref target="authentication-messages"/>). If the client chooses to authenticate, it MUST
send Certificate, CertificateVerify, and Finished. If it declines, it MUST send
a Certificate message containing no certificates followed by Finished.
All of the client’s messages for a given response
MUST appear consecutively on the wire with no intervening messages of other types.</t>

<t>A client that receives a CertificateRequest message without having sent
the “post_handshake_auth” extension MUST send an “unexpected_message” fatal
alert.</t>

<t>Note: Because client authentication could involve prompting the user, servers
MUST be prepared for some delay, including receiving an arbitrary number of
other messages between sending the CertificateRequest and receiving a
response. In addition, clients which receive multiple CertificateRequests in
close succession MAY respond to them in a different order than they were
received (the certificate_request_context value allows the server to
disambiguate the responses).</t>

</section>
<section anchor="key-update" title="Key and IV Update">

<figure><artwork><![CDATA[
   enum {
       update_not_requested(0), update_requested(1), (255)
   } KeyUpdateRequest;

   struct {
       KeyUpdateRequest request_update;
   } KeyUpdate;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='request_update'>
  Indicates whether the recipient of the KeyUpdate should respond with its
own KeyUpdate. If an implementation receives any other value, it MUST
terminate the connection with an “illegal_parameter” alert.</t>
</list></t>

<t>The KeyUpdate handshake message is used to indicate that the sender is
updating its sending cryptographic keys. This message can be sent by
either peer after it has sent a Finished message.
Implementations that receive a KeyUpdate message prior to receiving a Finished message
MUST terminate the connection with an “unexpected_message” alert.
After sending a KeyUpdate message, the sender SHALL send all its traffic using the
next generation of keys, computed as described in <xref target="updating-traffic-keys"/>.
Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.</t>

<t>If the request_update field is set to “update_requested” then the receiver MUST
send a KeyUpdate of its own with request_update set to “update_not_requested” prior
to sending its next application data record. This mechanism allows either side to force an update to the
entire connection, but causes an implementation which
receives multiple KeyUpdates while it is silent to respond with
a single update. Note that implementations may receive an arbitrary
number of messages between sending a KeyUpdate with request_update set
to update_requested and receiving the
peer’s KeyUpdate, because those messages may already be in flight.
However, because send and receive keys are derived from independent
traffic secrets, retaining the receive traffic secret does not threaten
the forward secrecy of data sent before the sender changed keys.</t>

<t>If implementations independently send their own KeyUpdates with
request_update set to “update_requested”, and they cross in flight, then each side
will also send a response, with the result that each side increments
by two generations.</t>

<t>Both sender and receiver MUST encrypt their KeyUpdate
messages with the old keys. Additionally, both sides MUST enforce that
a KeyUpdate with the old key is received before accepting any messages
encrypted with the new key. Failure to do so may allow message truncation
attacks.</t>

</section>
</section>
</section>
<section anchor="record-protocol" title="Record Protocol">

<t>The TLS record protocol takes messages to be transmitted, fragments
the data into manageable blocks, protects the records, and transmits
the result. Received data is verified, decrypted, reassembled, and
then delivered to higher-level clients.</t>

<t>TLS records are typed, which allows multiple higher-level protocols to
be multiplexed over the same record layer. This document specifies
four content types: handshake, application data, alert, and
change_cipher_spec.
The change_cipher_spec record is used only for compatibility purposes
(see <xref target="middlebox"/>).</t>

<t>An implementation may receive an unencrypted record of type
change_cipher_spec consisting of the single byte value 0x01 at any
time after the first ClientHello message has been sent or received and before
the peer’s Finished message has been received and MUST simply drop it without
further processing.  Note that this record may appear at a point at the
handshake where the implementation is expecting protected records
and so it is necessary to detect this
condition prior to attempting to deprotect the record. An
implementation which receives any other change_cipher_spec value or
which receives a protected change_cipher_spec record MUST abort the
handshake with an “unexpected_message” alert. A change_cipher_spec record
received before the first ClientHello message or after the peer’s Finished
message MUST be treated as an unexpected record type (though stateless
servers may not be able to distinguish these cases from allowed cases).</t>

<t>Implementations MUST NOT send record types not defined in this
document unless negotiated by some extension.  If a TLS implementation
receives an unexpected record type, it MUST terminate the connection
with an “unexpected_message” alert.  New record content type values
are assigned by IANA in the TLS Content Type Registry as described in
<xref target="iana-considerations"/>.</t>

<section anchor="record-layer" title="Record Layer">

<t>The record layer fragments information blocks into TLSPlaintext
records carrying data in chunks of 2^14 bytes or less. Message
boundaries are handled differently depending on the underlying
ContentType. Any future content types MUST specify appropriate
rules.
Note that these rules are stricter than what was enforced in TLS 1.2.</t>

<t>Handshake messages MAY be coalesced into a single TLSPlaintext
record or fragmented across several records, provided that:</t>

<t><list style="symbols">
  <t>Handshake messages MUST NOT be interleaved with other record
types. That is, if a handshake message is split over two or more
records, there MUST NOT be any other records between them.</t>
  <t>Handshake messages MUST NOT span key changes. Implementations MUST verify that
all messages immediately preceding a key change align with a record boundary;
if not, then they MUST terminate the connection with an “unexpected_message”
alert. Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and
KeyUpdate messages can immediately precede a key change, implementations MUST
send these messages in alignment with a record boundary.</t>
</list></t>

<t>Implementations MUST NOT send zero-length fragments of Handshake
types, even if those fragments contain padding.</t>

<t>Alert messages (<xref target="alert-protocol"/>) MUST NOT be fragmented across
records and multiple Alert messages MUST NOT be coalesced into a
single TLSPlaintext record. In other words, a record with an Alert
type MUST contain exactly one message.</t>

<t>Application Data messages contain data that is opaque to
TLS. Application Data messages are always protected. Zero-length
fragments of Application Data MAY be sent as they are potentially
useful as a traffic analysis countermeasure.  Application Data fragments
MAY be split across multiple records or coalesced into a single record.</t>

<figure><artwork><![CDATA[
   enum {
       invalid(0),
       change_cipher_spec(20),
       alert(21),
       handshake(22),
       application_data(23),
       (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion legacy_record_version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='type'>
  The higher-level protocol used to process the enclosed fragment.</t>
  <t hangText='legacy_record_version'>
  This value MUST be set to 0x0303 for all records generated by a
TLS 1.3 implementation other than an initial ClientHello (i.e., one
not generated after a HelloRetryRequest), where it
MAY also be 0x0301 for compatibility purposes.
This field is deprecated and MUST be ignored for all purposes.
Previous versions of TLS would use other values in this field
under some circumstances.</t>
  <t hangText='length'>
  The length (in bytes) of the following TLSPlaintext.fragment. The
length MUST NOT exceed 2^14 bytes. An endpoint that receives a record
that exceeds this length MUST terminate the connection with a
“record_overflow” alert.</t>
  <t hangText='fragment'>
  The data being transmitted. This value is transparent and is treated as an
independent block to be dealt with by the higher-level protocol
specified by the type field.</t>
</list></t>

<t>This document describes TLS 1.3, which uses the version 0x0304.
This version value is historical, deriving from the use of 0x0301
for TLS 1.0 and 0x0300 for SSL 3.0. In order to maximize backwards
compatibility, records containing an initial ClientHello SHOULD have version
0x0301 and a record containing a second ClientHello or
a ServerHello MUST have version
0x0303, reflecting TLS 1.0 and TLS 1.2 respectively.
When negotiating prior versions of TLS, endpoints
follow the procedure and requirements in <xref target="backward-compatibility"/>.</t>

<t>When record protection has not yet been engaged, TLSPlaintext
structures are written directly onto the wire. Once record protection
has started, TLSPlaintext records are protected and sent as
described in the following section. Note that application data
records MUST NOT be written to the wire unprotected (see
<xref target="protocol-overview"/> for details).</t>

</section>
<section anchor="record-payload-protection" title="Record Payload Protection">

<t>The record protection functions translate a TLSPlaintext structure into a
TLSCiphertext. The deprotection functions reverse the process. In TLS 1.3,
as opposed to previous versions of TLS, all ciphers are modeled as
“Authenticated Encryption with Additional Data” (AEAD) <xref target="RFC5116"/>.
AEAD functions provide an unified encryption and authentication
operation which turns plaintext into authenticated ciphertext and
back again. Each encrypted record consists of a plaintext header followed
by an encrypted body, which itself contains a type and optional padding.</t>

<figure><artwork><![CDATA[
   struct {
       opaque content[TLSPlaintext.length];
       ContentType type;
       uint8 zeros[length_of_padding];
   } TLSInnerPlaintext;

   struct {
       ContentType opaque_type = application_data; /* 23 */
       ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
       uint16 length;
       opaque encrypted_record[TLSCiphertext.length];
   } TLSCiphertext;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='content'>
  The TLSPLaintext.fragment value, containing the byte encoding of a
handshake or an alert message, or the raw bytes of the application’s
data to send.</t>
  <t hangText='type'>
  The TLSPlaintext.type value containing the content type of the record.</t>
  <t hangText='zeros'>
  An arbitrary-length run of zero-valued bytes may
appear in the cleartext after the type field.  This provides an
opportunity for senders to pad any TLS record by a chosen amount as
long as the total stays within record size limits.  See
<xref target="record-padding"/> for more details.</t>
  <t hangText='opaque_type'>
  The outer opaque_type field of a TLSCiphertext record is always set to the
value 23 (application_data) for outward compatibility with
middleboxes accustomed to parsing previous versions of TLS.  The
actual content type of the record is found in TLSInnerPlaintext.type after
decryption.</t>
  <t hangText='legacy_record_version'>
  The legacy_record_version field is always 0x0303.  TLS 1.3 TLSCiphertexts
are not generated until after TLS 1.3 has been negotiated, so there are
no historical compatibility concerns where other values might be received.
Note that the handshake protocol including the ClientHello and ServerHello
messages authenticates the protocol version, so this value is redundant.</t>
  <t hangText='length'>
  The length (in bytes) of the following TLSCiphertext.encrypted_record, which
is the sum of the lengths of the content and the padding, plus one
for the inner content type, plus any expansion added by the AEAD algorithm.
The length MUST NOT exceed 2^14 + 256 bytes.
An endpoint that receives a record that exceeds this length MUST
terminate the connection with a “record_overflow” alert.</t>
  <t hangText='encrypted_record'>
  The AEAD-encrypted form of the serialized TLSInnerPlaintext structure.</t>
</list></t>

<t>AEAD algorithms take as input a single key, a nonce, a plaintext, and “additional
data” to be included in the authentication check, as described in Section 2.1
of <xref target="RFC5116"/>. The key is either the client_write_key or the server_write_key,
the nonce is derived from the sequence number and the
client_write_iv or server_write_iv (see <xref target="nonce"/>), and the additional data input is the
record header. I.e.,</t>

<figure><artwork><![CDATA[
   additional_data = TLSCiphertext.opaque_type ||
                     TLSCiphertext.legacy_record_version ||
                     TLSCiphertext.length
]]></artwork></figure>

<t>The plaintext input to the AEAD algorithm is the encoded TLSInnerPlaintext structure.
Derivation of traffic keys is defined in <xref target="traffic-key-calculation"/>.</t>

<t>The AEAD output consists of the ciphertext output from the AEAD
encryption operation. The length of the plaintext is greater than the
corresponding TLSPlaintext.length due to the inclusion of TLSInnerPlaintext.type and
any padding supplied by the sender. The length of the
AEAD output will generally be larger than the plaintext, but by an
amount that varies with the AEAD algorithm. Since the ciphers might
incorporate padding, the amount of overhead could vary with different
lengths of plaintext. Symbolically,</t>

<figure><artwork><![CDATA[
   AEADEncrypted =
       AEAD-Encrypt(write_key, nonce, additional_data, plaintext)
]]></artwork></figure>

<t>Then the encrypted_record field of TLSCiphertext is set to AEADEncrypted.</t>

<t>In order to decrypt and verify, the cipher takes as input the key, nonce,
additional data, and the AEADEncrypted value. The output is either the plaintext
or an error indicating that the decryption failed. There is no separate
integrity check. That is:</t>

<figure><artwork><![CDATA[
   plaintext of encrypted_record =
       AEAD-Decrypt(peer_write_key, nonce, additional_data, AEADEncrypted)
]]></artwork></figure>

<t>If the decryption fails, the receiver MUST terminate the connection
with a “bad_record_mac” alert.</t>

<t>An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than
255 octets. An endpoint that receives a record from its peer with
TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate
the connection with a “record_overflow” alert.
This limit is derived from the maximum TLSInnerPlaintext length of
2^14 octets + 1 octet for ContentType + the maximum AEAD expansion of 255 octets.</t>

</section>
<section anchor="nonce" title="Per-Record Nonce">

<t>A 64-bit sequence number is maintained separately for reading and writing
records. The appropriate sequence number is incremented by one after
reading or writing each record.  Each sequence number is set to zero
at the beginning of a connection and whenever the key is changed; the
first record transmitted under a particular traffic key MUST use
sequence number 0.</t>

<t>Because the size of sequence numbers is 64-bit, they should not
wrap. If a TLS implementation would need to
wrap a sequence number, it MUST either re-key (<xref target="key-update"/>) or
terminate the connection.</t>

<t>Each AEAD algorithm will specify a range of possible lengths for the
per-record nonce, from N_MIN bytes to N_MAX bytes of input (<xref target="RFC5116"/>).
The length of the TLS per-record nonce (iv_length) is set to the larger of
8 bytes and N_MIN for the AEAD algorithm (see <xref target="RFC5116"/> Section 4).
An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS.
The per-record nonce for the AEAD construction is formed as follows:</t>

<t><list style="numbers">
  <t>The 64-bit record sequence number is encoded in network byte order
and padded to the left with zeros to iv_length.</t>
  <t>The padded sequence number is XORed with the static client_write_iv
or server_write_iv, depending on the role.</t>
</list></t>

<t>The resulting quantity (of length iv_length) is used as the per-record nonce.</t>

<t>Note: This is a different construction from that in TLS 1.2, which
specified a partially explicit nonce.</t>

</section>
<section anchor="record-padding" title="Record Padding">

<t>All encrypted TLS records can be padded to inflate the size of the
TLSCiphertext.  This allows the sender to hide the size of the
traffic from an observer.</t>

<t>When generating a TLSCiphertext record, implementations MAY choose to pad.
An unpadded record is just a record with a padding length of zero.
Padding is a string of zero-valued bytes appended to the ContentType
field before encryption.  Implementations MUST set the padding octets
to all zeros before encrypting.</t>

<t>Application Data records may contain a zero-length TLSInnerPlaintext.content if
the sender desires.  This permits generation of plausibly-sized cover
traffic in contexts where the presence or absence of activity may be
sensitive.  Implementations MUST NOT send Handshake or Alert records
that have a zero-length TLSInnerPlaintext.content; if such a message
is received, the receiving implementation MUST terminate the connection
with an “unexpected_message” alert.</t>

<t>The padding sent is automatically verified by the record protection
mechanism; upon successful decryption of a TLSCiphertext.encrypted_record,
the receiving implementation scans the field from the end toward the
beginning until it finds a non-zero octet. This non-zero octet is the
content type of the message.
This padding scheme was selected because it allows padding of any encrypted
TLS record by an arbitrary size (from zero up to TLS record size
limits) without introducing new content types.  The design also
enforces all-zero padding octets, which allows for quick detection of
padding errors.</t>

<t>Implementations MUST limit their scanning to the cleartext returned
from the AEAD decryption.  If a receiving implementation does not find
a non-zero octet in the cleartext, it MUST terminate the
connection with an “unexpected_message” alert.</t>

<t>The presence of padding does not change the overall record size limitations
- the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets. If the
maximum fragment length is reduced, as for example by the max_fragment_length
extension from <xref target="RFC6066"></xref>, then the reduced limit applies to the full plaintext,
including the content type and padding.</t>

<t>Selecting a padding policy that suggests when and how much to pad is a
complex topic and is beyond the scope of this specification. If the
application layer protocol on top of TLS has its own padding, it may be
preferable to pad application_data TLS records within the application
layer.  Padding for encrypted handshake and alert TLS records must
still be handled at the TLS layer, though.  Later documents may define
padding selection algorithms or define a padding policy request
mechanism through TLS extensions or some other means.</t>

</section>
<section anchor="limits-on-key-usage" title="Limits on Key Usage">

<t>There are cryptographic limits on the amount of plaintext which can be
safely encrypted under a given set of keys.  <xref target="AEAD-LIMITS"/> provides
an analysis of these limits under the assumption that the underlying
primitive (AES or ChaCha20) has no weaknesses. Implementations SHOULD
do a key update as described in <xref target="key-update"/> prior to reaching these limits.</t>

<t>For AES-GCM, up to 2^24.5 full-size records (about 24 million)
may be encrypted on a given connection while keeping a safety
margin of approximately 2^-57 for Authenticated Encryption (AE) security.
For ChaCha20/Poly1305, the record sequence number would wrap before the
safety limit is reached.</t>

</section>
</section>
<section anchor="alert-protocol" title="Alert Protocol">

<t>One of the content types supported by the TLS record layer is the
alert type.  Like other messages, alert messages are encrypted as
specified by the current connection state.</t>

<t>Alert messages convey a description of the alert and a legacy field
that conveyed the severity of the message in previous versions of
TLS. Alerts are divided into
two classes: closure alerts and error alerts.  In TLS 1.3, the
severity is implicit in the type of alert
being sent, and the ‘level’ field can safely be ignored. The “close_notify” alert
is used to indicate orderly closure of one direction of the connection.
Upon receiving such an alert, the TLS implementation SHOULD
indicate end-of-data to the application.</t>

<t>Error alerts indicate abortive closure of the
connection (see <xref target="error-alerts"/>). Upon receiving an error alert,
the TLS implementation SHOULD indicate an error to the application and
MUST NOT allow any further data to be sent or received on the
connection.  Servers and clients MUST forget the secret values and
keys established in failed connections, with the exception of
the PSKs associated with session tickets, which SHOULD be discarded if
possible.</t>

<t>All the alerts listed in <xref target="error-alerts"/> MUST be sent with
AlertLevel=fatal and MUST be treated as error alerts
regardless of the AlertLevel in the
message. Unknown alert types MUST be treated as error alerts.</t>

<t>Note: TLS defines two generic alerts (see <xref target="alert-protocol"/>) to use
upon failure to parse a message. Peers which receive a message which
cannot be parsed according to the syntax (e.g., have a length
extending beyond the message boundary or contain an out-of-range
length) MUST terminate the connection with a “decode_error”
alert. Peers which receive a message which is syntactically correct
but semantically invalid (e.g., a DHE share of p - 1, or an invalid
enum) MUST terminate the connection with an “illegal_parameter” alert.</t>

<figure><artwork><![CDATA[
   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       record_overflow(22),
       handshake_failure(40),
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       protocol_version(70),
       insufficient_security(71),
       internal_error(80),
       inappropriate_fallback(86),
       user_canceled(90),
       missing_extension(109),
       unsupported_extension(110),
       unrecognized_name(112),
       bad_certificate_status_response(113),
       unknown_psk_identity(115),
       certificate_required(116),
       no_application_protocol(120),
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;
]]></artwork></figure>

<section anchor="closure-alerts" title="Closure Alerts">

<t>The client and the server must share knowledge that the connection is ending in
order to avoid a truncation attack.</t>

<t><list style="hanging">
  <t hangText='close_notify'>
  This alert notifies the recipient that the sender will not send
any more messages on this connection. Any data received after a
closure alert has been received MUST be ignored.</t>
  <t hangText='user_canceled'>
  This alert notifies the recipient that the sender is canceling the
handshake for some reason unrelated to a protocol failure. If a user
cancels an operation after the handshake is complete, just closing the
connection by sending a “close_notify” is more appropriate. This alert
SHOULD be followed by a “close_notify”. This alert generally
has AlertLevel=warning.</t>
</list></t>

<t>Either party MAY initiate a close of its write side of the connection by
sending a “close_notify” alert. Any data received after a closure alert has
been received MUST be ignored. If a transport-level close is received prior
to a “close_notify”, the receiver cannot know that all the data that was sent
has been received.</t>

<t>Each party MUST send a “close_notify” alert before closing its write side
of the connection, unless it has already sent some error alert. This
does not have any effect on its read side of the connection. Note that this is
a change from versions of TLS prior to TLS 1.3 in which implementations were
required to react to a “close_notify” by discarding pending writes and
sending an immediate “close_notify” alert of their own. That previous
requirement could cause truncation in the read side. Both parties need not
wait to receive a “close_notify” alert before closing their read side of the
connection, though doing so would introduce the possibility of truncation.</t>

<t>If the application protocol using TLS provides that any data may be carried
over the underlying transport after the TLS connection is closed, the TLS
implementation MUST receive a “close_notify” alert before indicating
end-of-data to the application-layer. No part of this
standard should be taken to dictate the manner in which a usage profile for TLS
manages its data transport, including when connections are opened or closed.</t>

<t>Note: It is assumed that closing the write side of a connection reliably
delivers pending data before destroying the transport.</t>

</section>
<section anchor="error-alerts" title="Error Alerts">

<t>Error handling in the TLS Handshake Protocol is very simple. When an
error is detected, the detecting party sends a message to its
peer. Upon transmission or receipt of a fatal alert message, both
parties MUST immediately close the connection.</t>

<t>Whenever an implementation encounters a fatal error condition, it
SHOULD send an appropriate fatal alert and MUST close the connection
without sending or receiving any additional data. In the rest of this
specification, when the phrases “terminate the connection” and “abort the
handshake” are used without a specific alert it means that the
implementation SHOULD send the alert indicated by the descriptions
below. The phrases “terminate the connection with a X alert” and
“abort the handshake with a X alert” mean that the implementation
MUST send alert X if it sends any alert. All
alerts defined in this section below, as well as all unknown alerts,
are universally considered fatal as of TLS 1.3 (see <xref target="alert-protocol"/>).
The implementation SHOULD provide a way to facilitate logging
the sending and receiving of alerts.</t>

<t>The following error alerts are defined:</t>

<t><list style="hanging">
  <t hangText='unexpected_message'>
  An inappropriate message (e.g., the wrong handshake message, premature
application data, etc.) was received. This alert should never be
observed in communication between proper implementations.</t>
  <t hangText='bad_record_mac'>
  This alert is returned if a record is received which cannot be
deprotected. Because AEAD algorithms combine decryption and
verification, and also to avoid side channel attacks,
this alert is used for all deprotection failures.
This alert should never be observed in communication between
proper implementations, except when messages were corrupted
in the network.</t>
  <t hangText='record_overflow'>
  A TLSCiphertext record was received that had a length more than
2^14 + 256 bytes, or a record decrypted to a TLSPlaintext record
with more than 2^14 bytes (or some other negotiated limit).
This alert should never be observed in communication between
proper implementations, except when messages were corrupted
in the network.</t>
  <t hangText='handshake_failure'>
  Receipt of a “handshake_failure” alert message indicates that the
sender was unable to negotiate an acceptable set of security
parameters given the options available.</t>
  <t hangText='bad_certificate'>
  A certificate was corrupt, contained signatures that did not
verify correctly, etc.</t>
  <t hangText='unsupported_certificate'>
  A certificate was of an unsupported type.</t>
  <t hangText='certificate_revoked'>
  A certificate was revoked by its signer.</t>
  <t hangText='certificate_expired'>
  A certificate has expired or is not currently valid.</t>
  <t hangText='certificate_unknown'>
  Some other (unspecified) issue arose in processing the
certificate, rendering it unacceptable.</t>
  <t hangText='illegal_parameter'>
  A field in the handshake was incorrect or inconsistent with
other fields. This alert is used for errors which conform to
the formal protocol syntax but are otherwise incorrect.</t>
  <t hangText='unknown_ca'>
  A valid certificate chain or partial chain was received, but the
certificate was not accepted because the CA certificate could not
be located or could not be matched with a known trust anchor.</t>
  <t hangText='access_denied'>
  A valid certificate or PSK was received, but when access control was
applied, the sender decided not to proceed with negotiation.</t>
  <t hangText='decode_error'>
  A message could not be decoded because some field was out of the
specified range or the length of the message was incorrect.
This alert is used for errors where the message does not conform
to the formal protocol syntax.
This alert should never be observed in communication between
proper implementations, except when messages were corrupted
in the network.</t>
  <t hangText='decrypt_error'>
  A handshake (not record-layer) cryptographic operation failed, including being unable
to correctly verify a signature or validate a Finished message
or a PSK binder.</t>
  <t hangText='protocol_version'>
  The protocol version the peer has attempted to negotiate is
recognized but not supported. (see <xref target="backward-compatibility"/>)</t>
  <t hangText='insufficient_security'>
  Returned instead of “handshake_failure” when a negotiation has
failed specifically because the server requires parameters more
secure than those supported by the client.</t>
  <t hangText='internal_error'>
  An internal error unrelated to the peer or the correctness of the
protocol (such as a memory allocation failure) makes it impossible
to continue.</t>
  <t hangText='inappropriate_fallback'>
  Sent by a server in response to an invalid connection retry attempt
from a client (see <xref target="RFC7507"/>).</t>
  <t hangText='missing_extension'>
  Sent by endpoints that receive a handshake message not containing an
extension that is mandatory to send for the offered TLS version
or other negotiated parameters.</t>
  <t hangText='unsupported_extension'>
  Sent by endpoints receiving any handshake message containing an extension
known to be prohibited for inclusion in the given handshake message, or including
any extensions in a ServerHello or Certificate not first offered in the
corresponding ClientHello.</t>
  <t hangText='unrecognized_name'>
  Sent by servers when no server exists identified by the name
provided by the client via the “server_name” extension
(see <xref target="RFC6066"/>).</t>
  <t hangText='bad_certificate_status_response'>
  Sent by clients when an invalid or unacceptable OCSP response is
provided by the server via the “status_request” extension
(see <xref target="RFC6066"/>).</t>
  <t hangText='unknown_psk_identity'>
  Sent by servers when PSK key establishment is desired but no
 acceptable PSK identity is provided by the client. Sending this alert
 is OPTIONAL; servers MAY instead choose to send a “decrypt_error”
 alert to merely indicate an invalid PSK identity.</t>
  <t hangText='certificate_required'>
  Sent by servers when a client certificate is desired but none was provided by
the client.</t>
  <t hangText='no_application_protocol'>
  Sent by servers when a client
“application_layer_protocol_negotiation” extension advertises
only protocols that the server does not support
(see <xref target="RFC7301"/>).</t>
</list></t>

<t>New Alert values are assigned by IANA as described in <xref target="iana-considerations"/>.</t>

</section>
</section>
<section anchor="cryptographic-computations" title="Cryptographic Computations">

<t>The TLS handshake establishes one or more input secrets which
are combined to create the actual working keying material, as detailed
below. The key derivation process incorporates both the input secrets
and the handshake transcript. Note that because the handshake
transcript includes the random values from the Hello messages,
any given handshake will have different traffic secrets, even
if the same input secrets are used, as is the case when
the same PSK is used for multiple connections.</t>

<section anchor="key-schedule" title="Key Schedule">

<t>The key derivation process makes use of the HKDF-Extract and HKDF-Expand
functions as defined for HKDF <xref target="RFC5869"/>, as well as the functions
defined below:</t>

<figure><artwork><![CDATA[
    HKDF-Expand-Label(Secret, Label, Context, Length) =
         HKDF-Expand(Secret, HkdfLabel, Length)

    Where HkdfLabel is specified as:

    struct {
        uint16 length = Length;
        opaque label<7..255> = "tls13 " + Label;
        opaque context<0..255> = Context;
    } HkdfLabel;

    Derive-Secret(Secret, Label, Messages) =
         HKDF-Expand-Label(Secret, Label,
                           Transcript-Hash(Messages), Hash.length)
]]></artwork></figure>

<t>The Hash function used by Transcript-Hash and HKDF is the cipher suite hash
algorithm.
Hash.length is its output length in bytes. Messages is the concatenation of the
indicated handshake messages, including the handshake message type
and length fields, but not including record layer headers. Note that
in some cases a zero-length Context (indicated by “”) is passed to
HKDF-Expand-Label.  The Labels specified in this document are all
ASCII strings, and do not include a trailing NUL byte.</t>

<t>Note: with common hash functions, any label longer than 12 characters
requires an additional iteration of the hash function to compute.
The labels in this specification have all been chosen to fit within
this limit.</t>

<t>Keys are derived from two input secrets using
the HKDF-Extract and Derive-Secret functions. The general pattern
for adding a new secret is to use HKDF-Extract with the salt
being the current secret state and the IKM being the new
secret to be added. In this version of TLS 1.3, the two
input secrets are:</t>

<t><list style="symbols">
  <t>PSK (a pre-shared key established externally or derived from
the resumption_master_secret value from a previous connection)</t>
  <t>(EC)DHE shared secret (<xref target="ecdhe-shared-secret-calculation"/>)</t>
</list></t>

<t>This produces a full key derivation schedule shown in the diagram below.
In this diagram, the following formatting conventions apply:</t>

<t><list style="symbols">
  <t>HKDF-Extract is drawn as taking the Salt argument from the top and
the IKM argument from the left, with its output to the bottom and
the name of the output on the right.</t>
  <t>Derive-Secret’s Secret argument is indicated by the incoming
arrow. For instance, the Early Secret is the Secret for
generating the client_early_traffic_secret.</t>
  <t>“0” indicates a string of Hash-lengths bytes set to 0.</t>
</list></t>

<figure><artwork><![CDATA[
                 0
                 |
                 v
   PSK ->  HKDF-Extract = Early Secret
                 |
                 +-----> Derive-Secret(.,
                 |                     "ext binder" |
                 |                     "res binder",
                 |                     "")
                 |                     = binder_key
                 |
                 +-----> Derive-Secret(., "c e traffic",
                 |                     ClientHello)
                 |                     = client_early_traffic_secret
                 |
                 +-----> Derive-Secret(., "e exp master",
                 |                     ClientHello)
                 |                     = early_exporter_master_secret
                 v
           Derive-Secret(., "derived", "")
                 |
                 v
(EC)DHE -> HKDF-Extract = Handshake Secret
                 |
                 +-----> Derive-Secret(., "c hs traffic",
                 |                     ClientHello...ServerHello)
                 |                     = client_handshake_traffic_secret
                 |
                 +-----> Derive-Secret(., "s hs traffic",
                 |                     ClientHello...ServerHello)
                 |                     = server_handshake_traffic_secret
                 v
           Derive-Secret(., "derived", "")
                 |
                 v
      0 -> HKDF-Extract = Master Secret
                 |
                 +-----> Derive-Secret(., "c ap traffic",
                 |                     ClientHello...server Finished)
                 |                     = client_application_traffic_secret_0
                 |
                 +-----> Derive-Secret(., "s ap traffic",
                 |                     ClientHello...server Finished)
                 |                     = server_application_traffic_secret_0
                 |
                 +-----> Derive-Secret(., "exp master",
                 |                     ClientHello...server Finished)
                 |                     = exporter_master_secret
                 |
                 +-----> Derive-Secret(., "res master",
                                       ClientHello...client Finished)
                                       = resumption_master_secret
]]></artwork></figure>

<t>The general pattern here is that the secrets shown down the left side
of the diagram are just raw entropy without context, whereas the
secrets down the right side include handshake context and therefore
can be used to derive working keys without additional context.
Note that the different
calls to Derive-Secret may take different Messages arguments,
even with the same secret. In a 0-RTT exchange, Derive-Secret is
called with four distinct transcripts; in a 1-RTT-only exchange
with three distinct transcripts.</t>

<t>If a given secret is not available, then the 0-value consisting of
a string of Hash.length bytes set to zeros is used.  Note that this does not mean skipping
rounds, so if PSK is not in use Early Secret will still be
HKDF-Extract(0, 0). For the computation of the binder_secret, the label is
“ext binder” for external PSKs (those provisioned outside of TLS)
and “res binder” for resumption PSKs (those provisioned as the resumption
master secret of a previous handshake). The different labels prevent
the substitution of one type of PSK for the other.</t>

<t>There are multiple potential Early Secret values depending on
which PSK the server ultimately selects. The client will need to compute
one for each potential PSK; if no PSK is selected, it will then need to
compute the early secret corresponding to the zero PSK.</t>

<t>Once all the values which are to be derived from a given secret have
been computed, that secret SHOULD be erased.</t>

</section>
<section anchor="updating-traffic-keys" title="Updating Traffic Secrets">

<t>Once the handshake is complete, it is possible for either side to
update its sending traffic keys using the KeyUpdate handshake message
defined in <xref target="key-update"/>.  The next generation of traffic keys is computed by
generating client_/server_application_traffic_secret_N+1 from
client_/server_application_traffic_secret_N as described in
this section then re-deriving the traffic keys as described in
<xref target="traffic-key-calculation"/>.</t>

<t>The next-generation application_traffic_secret is computed as:</t>

<figure><artwork><![CDATA[
    application_traffic_secret_N+1 =
        HKDF-Expand-Label(application_traffic_secret_N,
                          "traffic upd", "", Hash.length)
]]></artwork></figure>

<t>Once client/server_application_traffic_secret_N+1 and its associated
traffic keys have been computed, implementations SHOULD delete
client_/server_application_traffic_secret_N and its associated traffic keys.</t>

</section>
<section anchor="traffic-key-calculation" title="Traffic Key Calculation">

<t>The traffic keying material is generated from the following input values:</t>

<t><list style="symbols">
  <t>A secret value</t>
  <t>A purpose value indicating the specific value being generated</t>
  <t>The length of the key being generated</t>
</list></t>

<t>The traffic keying material is generated from an input traffic secret value using:</t>

<figure><artwork><![CDATA[
    [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
    [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv" , "", iv_length)
]]></artwork></figure>

<t>[sender] denotes the sending side. The Secret value for each record type
is shown in the table below.</t>

<texttable>
      <ttcol align='left'>Record Type</ttcol>
      <ttcol align='left'>Secret</ttcol>
      <c>0-RTT Application</c>
      <c>client_early_traffic_secret</c>
      <c>Handshake</c>
      <c>[sender]_handshake_traffic_secret</c>
      <c>Application Data</c>
      <c>[sender]_application_traffic_secret_N</c>
</texttable>

<t>All the traffic keying material is recomputed whenever the
underlying Secret changes (e.g., when changing from the handshake to
application data keys or upon a key update).</t>

</section>
<section anchor="ecdhe-shared-secret-calculation" title="(EC)DHE Shared Secret Calculation">

<section anchor="finite-field-diffie-hellman" title="Finite Field Diffie-Hellman">

<t>For finite field groups, a conventional Diffie-Hellman
<xref target="DH76"/> computation is performed.
The negotiated key (Z) is converted to a byte string by encoding in big-endian and
left padded with zeros up to the size of the prime. This byte string is used as the
shared secret in the key schedule as specified above.</t>

<t>Note that this construction differs from previous versions of TLS which remove
leading zeros.</t>

</section>
<section anchor="elliptic-curve-diffie-hellman" title="Elliptic Curve Diffie-Hellman">

<t>For secp256r1, secp384r1 and secp521r1, ECDH calculations (including parameter
and key generation as well as the shared secret calculation) are
performed according to <xref target="IEEE1363"/> using the ECKAS-DH1 scheme with the identity
map as key derivation function (KDF), so that the shared secret is the
x-coordinate of the ECDH shared secret elliptic curve point represented
as an octet string.  Note that this octet string (Z in IEEE 1363 terminology)
as output by FE2OSP, the Field Element to Octet String Conversion
Primitive, has constant length for any given field; leading zeros
found in this octet string MUST NOT be truncated.</t>

<t>(Note that this use of the identity KDF is a technicality.  The
complete picture is that ECDH is employed with a non-trivial KDF
because TLS does not directly use this secret for anything
other than for computing other secrets.)</t>

<t>ECDH functions are used as follows:</t>

<t><list style="symbols">
  <t>The public key to put into the KeyShareEntry.key_exchange structure is the
result of applying the ECDH scalar multiplication function to the secret key
of appropriate length (into scalar input) and the standard public basepoint
(into u-coordinate point input).</t>
  <t>The ECDH shared secret is the result of applying the ECDH scalar multiplication
function to the secret key (into scalar input) and the peer’s public key
(into u-coordinate point input). The output is used raw, with no processing.</t>
</list></t>

<t>For X25519 and X448, implementations SHOULD use the approach specified
in <xref target="RFC7748"/> to calculate the Diffie-Hellman shared secret.
Implementations MUST check whether the computed Diffie-Hellman
shared secret is the all-zero value and abort if so, as described in
Section 6 of <xref target="RFC7748"/>. If implementors use an alternative
implementation of these elliptic curves, they SHOULD perform the
additional checks specified in Section 7 of <xref target="RFC7748"/>.</t>

</section>
</section>
<section anchor="exporters" title="Exporters">

<t><xref target="RFC5705"/> defines keying material exporters for TLS in terms of the TLS
pseudorandom function (PRF). This document replaces the PRF with HKDF, thus
requiring a new construction. The exporter interface remains the same.</t>

<t>The exporter value is computed as:</t>

<figure><artwork><![CDATA[
TLS-Exporter(label, context_value, key_length) =
    HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                      "exporter", Hash(context_value), key_length)
]]></artwork></figure>

<t>Where Secret is either the early_exporter_master_secret or the
exporter_master_secret.  Implementations MUST use the exporter_master_secret unless
explicitly specified by the application. The early_exporter_master_secret is
defined for use in settings where an exporter is needed for 0-RTT data.
A separate interface for the early exporter is RECOMMENDED; this avoids
the exporter user accidentally using an early exporter when a regular
one is desired or vice versa.</t>

<t>If no context is provided, the context_value is zero-length. Consequently,
providing no context computes the same value as providing an empty context.
This is a change from previous versions of TLS where an empty context produced a
different output to an absent context. As of this document’s publication, no
allocated exporter label is used both with and without a context. Future
specifications MUST NOT define a use of exporters that permit both an empty
context and no context with the same label. New uses of exporters SHOULD provide
a context in all exporter computations, though the value could be empty.</t>

<t>Requirements for the format of exporter labels are defined in section 4
of <xref target="RFC5705"/>.</t>

</section>
</section>
<section anchor="anti-replay" title="0-RTT and Anti-Replay">

<t>As noted in <xref target="zero-rtt-data"/> and <xref target="replay-0rtt"/>, TLS does not provide inherent replay
protections for 0-RTT data. There are two potential threats to be
concerned with:</t>

<t><list style="symbols">
  <t>Network attackers who mount a replay attack by simply duplicating a
flight of 0-RTT data.</t>
  <t>Network attackers who take advantage of client retry behavior
to arrange for the server to receive multiple copies of an application
message. This threat already exists
to some extent because clients that value robustness respond to network errors by
attempting to retry requests. However, 0-RTT adds an additional
dimension for any server system which does not maintain globally
consistent server state. Specifically, if a server system has
multiple zones where tickets from zone A will not be accepted in
zone B, then an attacker can duplicate a ClientHello and early
data intended for A to both A and B. At A, the data will
be accepted in 0-RTT, but at B the server will reject 0-RTT
data and instead force a full handshake. If the attacker blocks
the ServerHello from A, then the client will complete the
handshake with B and probably retry the request, leading to duplication on
the server system as a whole.</t>
</list></t>

<t>The first class of attack can be prevented by sharing state to guarantee that
the 0-RTT data is accepted at most once.  Servers SHOULD provide that level of
replay safety, by implementing one of the methods described in this section or
by equivalent means.  It is understood, however, that due to operational
concerns not all deployments will maintain state at that level.  Therefore, in
normal operation, clients will not know which, if any, of these mechanisms
servers actually implement and hence MUST only send early data which they deem
safe to be replayed.</t>

<t>In addition to the direct effects of replays, there is a class of attacks where
even operations normally considered idempotent could be exploited by a large
number of replays (timing attacks, resource limit exhaustion and others
described in <xref target="replay-0rtt"/>).  Those can be mitigated by ensuring that every
0-RTT payload can be replayed only a limited number of times.  The server MUST
ensure that any instance of it (be it a machine, a thread or any other entity
within the relevant serving infrastructure) would accept 0-RTT for the same
0-RTT handshake at most once; this limits the number of replays to the number of
server instances in the deployment.  Such a guarantee can be accomplished by
locally recording data from recently-received ClientHellos and rejecting
repeats, or by any other method that provides the same or a stronger guarantee.
The “at most once per server instance” guarantee is a minimum requirement;
servers SHOULD limit 0-RTT replays further when feasible.</t>

<t>The second class of attack cannot be prevented at the TLS layer and
MUST be dealt with by any application. Note that any application whose
clients implement any kind of retry behavior already needs to
implement some sort of anti-replay defense.</t>

<section anchor="single-use-tickets" title="Single-Use Tickets">

<t>The simplest form of anti-replay defense is for the server to only
allow each session ticket to be used once. For instance, the server
can maintain a database of all outstanding valid tickets; deleting each
ticket from the database as it is used. If an unknown ticket is
provided, the server would then fall back to a full handshake.</t>

<t>If the tickets are not self-contained but rather are database keys,
and the corresponding PSKs are deleted upon use, then connections established
using PSKs enjoy forward secrecy. This improves security for
all 0-RTT data and PSK usage when PSK is used without (EC)DHE.</t>

<t>Because this mechanism requires sharing the session database between
server nodes in environments with multiple distributed servers,
it may be hard to achieve high rates of successful PSK 0-RTT
connections when compared to self-encrypted tickets. Unlike
session databases, session tickets can successfully do PSK-based
session establishment even without consistent storage, though when
0-RTT is allowed they still require consistent storage for anti-replay
of 0-RTT data, as detailed in the following
section.</t>

</section>
<section anchor="client-hello-recording" title="Client Hello Recording">

<t>An alternative form of anti-replay is to record a unique value derived
from the ClientHello (generally either the random value or the PSK
binder) and reject duplicates. Recording all ClientHellos causes state
to grow without bound, but a server can instead record ClientHellos within
a given time window and use the “obfuscated_ticket_age” to ensure that
tickets aren’t reused outside that window.</t>

<t>In order to implement this, when a ClientHello is received, the server
first verifies the PSK binder as described
<xref target="pre-shared-key-extension"/>. It then computes the
expected_arrival_time as described in the next section and rejects
0-RTT if it is outside the recording window, falling back to the
1-RTT handshake.</t>

<t>If the expected arrival time is in the window, then the server
checks to see if it has recorded a matching ClientHello. If one
is found, it either aborts the handshake with an “illegal_parameter” alert
or accepts the PSK but reject 0-RTT. If no matching ClientHello
is found, then it accepts 0-RTT and then stores the ClientHello for
as long as the expected_arrival_time is inside the window.
Servers MAY also implement data stores with false positives, such as
Bloom filters, in which case they MUST respond to apparent replay by
rejecting 0-RTT but MUST NOT abort the handshake.</t>

<t>The server MUST derive the storage key only from validated sections
of the ClientHello. If the ClientHello contains multiple
PSK identities, then an attacker can create multiple ClientHellos
with different binder values for the less-preferred identity on the
assumption that the server will not verify it, as recommended
by <xref target="pre-shared-key-extension"/>.
I.e., if the
client sends PSKs A and B but the server prefers A, then the
attacker can change the binder for B without affecting the binder
for A. If the binder for B is part of the storage key,
then this ClientHello will not appear as a duplicate,
which will cause the ClientHello to be accepted, and may
cause side effects such as replay cache pollution, although any
0-RTT data will not be decryptable because it will use different
keys. If the validated binder or the ClientHello.random
are used as the storage key, then this attack is not possible.</t>

<t>Because this mechanism does not require storing all outstanding
tickets, it may be easier to implement in distributed systems with
high rates of resumption and 0-RTT, at the cost of potentially
weaker anti-replay defense because of the difficulty of reliably
storing and retrieving the received ClientHello messages.
In many such systems, it is impractical to have globally
consistent storage of all the received ClientHellos.
In this case, the best anti-replay protection is provided by
having a single storage zone be
authoritative for a given ticket and refusing 0-RTT for that
ticket in any other zone. This approach prevents simple
replay by the attacker because only one zone will accept
0-RTT data. A weaker design is to implement separate storage for
each zone but allow 0-RTT in any zone. This approach limits
the number of replays to once per zone. Application message
duplication of course remains possible with either design.</t>

<t>When implementations are freshly started, they SHOULD
reject 0-RTT as long as any portion of their recording window overlaps
the startup time. Otherwise, they run the risk of accepting
replays which were originally sent during that period.</t>

<t>Note: If the client’s clock is running much faster than the server’s
then a ClientHello may be received that is outside the window in the
future, in which case it might be accepted for 1-RTT, causing a client retry,
and then acceptable later for 0-RTT. This is another variant of
the second form of attack described above.</t>

</section>
<section anchor="freshness-checks" title="Freshness Checks">

<t>Because the ClientHello indicates the time at which the client sent
it, it is possible to efficiently determine whether a ClientHello was
likely sent reasonably recently and only accept 0-RTT for such a
ClientHello, otherwise falling back to a 1-RTT handshake.
This is necessary for the ClientHello storage mechanism
described in <xref target="client-hello-recording"/> because otherwise the server
needs to store an unlimited number of ClientHellos and is a useful optimization for
self-contained single-use tickets because it allows efficient rejection of ClientHellos
which cannot be used for 0-RTT.</t>

<t>In order to implement this mechanism, a server needs to store the time
that the server generated the session ticket, offset by an estimate of
the round trip time between client and server. I.e.,</t>

<figure><artwork><![CDATA[
    adjusted_creation_time = creation_time + estimated_RTT
]]></artwork></figure>

<t>This value can be encoded in the ticket, thus avoiding the need to
keep state for each outstanding ticket. The server can determine the
client’s view of the age of the ticket by subtracting the ticket’s
“ticket_age_add value” from the “obfuscated_ticket_age” parameter in
the client’s “pre_shared_key” extension. The server can determine the
“expected arrival time” of the ClientHello as:</t>

<figure><artwork><![CDATA[
    expected_arrival_time = adjusted_creation_time + clients_ticket_age
]]></artwork></figure>

<t>When a new ClientHello is received, the expected_arrival_time is then
compared against the current server wall clock time and if they differ
by more than a certain amount, 0-RTT is rejected, though the 1-RTT
handshake can be allowed to complete.</t>

<t>There are several potential sources of error that might cause
mismatches between the expected arrival time and the measured
time. Variations in client and server clock
rates are likely to be minimal, though potentially the absolute
times may be off by large values.
Network propagation delays are the most likely causes of
a mismatch in legitimate values for elapsed time.  Both the
NewSessionTicket and ClientHello messages might be retransmitted and
therefore delayed, which might be hidden by TCP. For clients
on the Internet, this implies windows
on the order of ten seconds to account for errors in clocks and
variations in measurements; other deployment scenarios
may have different needs. Clock skew distributions are not
symmetric, so the optimal tradeoff may involve an asymmetric range
of permissible mismatch values.</t>

<t>Note that freshness checking alone is not sufficient to prevent
replays because it does not detect them during the error window,
which, depending on bandwidth and system capacity could include
billions of replays in real-world settings.  In addition, this
freshness checking is only done at the time the ClientHello is
received, and not when later early application data records are
received. After early data is accepted, records may continue to be
streamed to the server over a longer time period.</t>

</section>
</section>
<section anchor="compliance-requirements" title="Compliance Requirements">

<section anchor="mandatory-to-implement-cipher-suites" title="Mandatory-to-Implement Cipher Suites">

<t>In the absence of an application profile standard specifying otherwise, a
TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256 <xref target="GCM"></xref>
cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384 <xref target="GCM"></xref> and
TLS_CHACHA20_POLY1305_SHA256 <xref target="RFC7539"></xref> cipher suites.  (see
<xref target="cipher-suites"/>)</t>

<t>A TLS-compliant application MUST support digital signatures with
rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for
CertificateVerify and certificates), and ecdsa_secp256r1_sha256. A
TLS-compliant application MUST support key exchange with secp256r1
(NIST P-256) and SHOULD support key exchange with X25519 <xref target="RFC7748"/>.</t>

</section>
<section anchor="mti-extensions" title="Mandatory-to-Implement Extensions">

<t>In the absence of an application profile standard specifying otherwise, a
TLS-compliant application MUST implement the following TLS extensions:</t>

<t><list style="symbols">
  <t>Supported Versions     (“supported_versions”; <xref target="supported-versions"/>)</t>
  <t>Cookie                 (“cookie”; <xref target="cookie"/>)</t>
  <t>Signature Algorithms   (“signature_algorithms”; <xref target="signature-algorithms"/>)</t>
  <t>Signature Algorithms Certificate  (“signature_algorithms_cert”; <xref target="signature-algorithms"/>)</t>
  <t>Negotiated Groups      (“supported_groups”; <xref target="negotiated-groups"/>)</t>
  <t>Key Share              (“key_share”; <xref target="key-share"/>)</t>
  <t>Server Name Indication (“server_name”; Section 3 of <xref target="RFC6066"/>)</t>
</list></t>

<t>All implementations MUST send and use these extensions when offering
applicable features:</t>

<t><list style="symbols">
  <t>“supported_versions”   is REQUIRED for all ClientHello, ServerHello and HelloRetryRequest messages.</t>
  <t>“signature_algorithms” is REQUIRED for certificate authentication.</t>
  <t>“supported_groups”     is REQUIRED for ClientHello messages using
                        DHE or ECDHE key exchange.</t>
  <t>“key_share”            is REQUIRED for DHE or ECDHE key exchange.</t>
  <t>“pre_shared_key”       is REQUIRED for PSK key agreement.</t>
  <t>“psk_key_exchange_modes” is REQUIRED for PSK key agreement.</t>
</list></t>

<t>A client is considered to be attempting to negotiate using this
specification if the ClientHello contains a “supported_versions”
extension with 0x0304 contained in its body.
Such a ClientHello message MUST meet the following requirements:</t>

<t><list style="symbols">
  <t>If not containing a “pre_shared_key” extension, it MUST contain both
a “signature_algorithms” extension and a “supported_groups” extension.</t>
  <t>If containing a “supported_groups” extension, it MUST also contain a
“key_share” extension, and vice versa. An empty KeyShare.client_shares
vector is permitted.</t>
</list></t>

<t>Servers receiving a ClientHello which does not conform to these
requirements MUST abort the handshake with a “missing_extension”
alert.</t>

<t>Additionally, all implementations MUST support use of the “server_name”
extension with applications capable of using it.
Servers MAY require clients to send a valid “server_name” extension.
Servers requiring this extension SHOULD respond to a ClientHello
lacking a “server_name” extension by terminating the connection with a
“missing_extension” alert.</t>

</section>
<section anchor="protocol-invariants" title="Protocol Invariants">

<t>This section describes invariants that TLS endpoints and middleboxes MUST
follow. It also applies to earlier versions of TLS.</t>

<t>TLS is designed to be securely and compatibly extensible. Newer clients or
servers, when communicating with newer peers, should negotiate the
most preferred common parameters. The TLS handshake provides downgrade
protection: Middleboxes passing traffic between a newer client and
newer server without terminating TLS should be unable to influence the
handshake (see <xref target="security-handshake"/>). At the same time, deployments
update at different rates, so a newer client or server MAY continue to
support older parameters, which would allow it to interoperate with
older endpoints.</t>

<t>For this to work, implementations MUST correctly handle extensible fields:</t>

<t><list style="symbols">
  <t>A client sending a ClientHello MUST support all parameters advertised in it.
Otherwise, the server may fail to interoperate by selecting one of those
parameters.</t>
  <t>A server receiving a ClientHello MUST correctly ignore all unrecognized
cipher suites, extensions, and other parameters. Otherwise, it may fail to
interoperate with newer clients. In TLS 1.3, a client receiving a
CertificateRequest or NewSessionTicket MUST also ignore all unrecognized
extensions.</t>
  <t>A middlebox which terminates a TLS connection MUST behave as a compliant
TLS server (to the original client), including having a certificate
which the client is willing to accept, and as a compliant TLS client (to the
original server), including verifying the original server’s certificate.
In particular, it MUST generate its own ClientHello
containing only parameters it understands, and it MUST generate a fresh
ServerHello random value, rather than forwarding the endpoint’s value.  <vspace blankLines='1'/>
Note that TLS’s protocol requirements and security analysis only apply to the
two connections separately. Safely deploying a TLS terminator requires
additional security considerations which are beyond the scope of this document.</t>
  <t>An middlebox which forwards ClientHello parameters it does not understand MUST
NOT process any messages beyond that ClientHello. It MUST forward all
subsequent traffic unmodified. Otherwise, it may fail to interoperate with
newer clients and servers.  <vspace blankLines='1'/>
Forwarded ClientHellos may contain advertisements for features not supported
by the middlebox, so the response may include future TLS additions the
middlebox does not recognize. These additions MAY change any message beyond
the ClientHello arbitrarily. In particular, the values sent in the ServerHello
might change, the ServerHello format might change, and the TLSCiphertext format
might change.</t>
</list></t>

<t>The design of TLS 1.3 was constrained by widely-deployed non-compliant TLS
middleboxes (see <xref target="middlebox"/>), however it does not relax the invariants.
Those middleboxes continue to be non-compliant.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<t>Security issues are discussed throughout this memo, especially in
<xref target="implementation-notes"/>, <xref target="backward-compatibility"/>, and <xref target="security-analysis"/>.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document uses several registries that were originally created in
<xref target="RFC4346"/>. IANA [SHALL update/has updated] these to reference this document.
The registries and their allocation policies are below:</t>

<t><list style="symbols">
  <t>TLS Cipher Suite Registry: values with the first byte in the range
0-254 (decimal) are assigned via Specification Required <xref target="RFC8126"/>.
Values with the first byte 255 (decimal) are reserved for Private
Use <xref target="RFC8126"/>.  <vspace blankLines='1'/>
IANA [SHALL add/has added] the cipher suites listed in <xref target="cipher-suites"/> to
the registry. The “Value” and “Description” columns are taken from the table.
The “DTLS-OK” and “Recommended” columns are both marked as “Yes” for each new
cipher suite. [[This assumes <xref target="I-D.ietf-tls-iana-registry-updates"/> has been
applied.]]</t>
  <t>TLS ContentType Registry: Future values are allocated via
Standards Action <xref target="RFC8126"/>.</t>
  <t>TLS Alert Registry: Future values are allocated via Standards
Action <xref target="RFC8126"/>. IANA [SHALL update/has updated] this registry
to include values for “missing_extension” and “certificate_required”.  The
“DTLS-OK” column is marked as “Yes” for each new alert.</t>
  <t>TLS HandshakeType Registry: Future values are allocated via
Standards Action <xref target="RFC8126"/>. IANA [SHALL update/has updated] this registry
to rename item 4 from “NewSessionTicket” to “new_session_ticket”
and to add the “hello_retry_request_RESERVED”, “encrypted_extensions”,
“end_of_early_data”, “key_update”, and “message_hash” values.  The “DTLS-OK”
are marked as “Yes” for each of these additions.</t>
</list></t>

<t>This document also uses the TLS ExtensionType Registry originally created in
<xref target="RFC4366"/>. IANA has updated it to reference this document.  Changes to the
registry follow:</t>

<t><list style="symbols">
  <t>IANA [SHALL update/has updated] the registration policy as follows:  <vspace blankLines='1'/>
Values with the first byte in the range 0-254 (decimal) are assigned
via Specification Required <xref target="RFC8126"></xref>.  Values with the first byte
255 (decimal) are reserved for Private Use <xref target="RFC8126"></xref>.</t>
  <t>IANA [SHALL update/has updated] this registry to include the
“key_share”, “pre_shared_key”, “psk_key_exchange_modes”,
“early_data”, “cookie”, “supported_versions”,
“certificate_authorities”, “oid_filters”, “post_handshake_auth”, and “signature_algorithms_cert”,
extensions with the values defined in this document and the Recommended value of “Yes”.</t>
  <t>IANA [SHALL update/has updated] this registry to include a “TLS
1.3” column which lists the messages in which the extension may
appear. This column [SHALL be/has been]
initially populated from the table in <xref target="extensions"/>
with any extension not listed there marked as “-“ to indicate that
it is not used by TLS 1.3.</t>
</list></t>

<t>In addition, this document defines two new registries to be maintained
by IANA:</t>

<t><list style="symbols">
  <t>TLS SignatureScheme Registry: Values with the first byte in the range
0-253 (decimal) are assigned via Specification Required <xref target="RFC8126"/>.
Values with the first byte 254 or 255 (decimal) are reserved for Private
Use <xref target="RFC8126"/>. Values with the first byte in the range 0-6 or with the
second byte in the range 0-3 that are not currently allocated are reserved for
backwards compatibility.
This registry SHALL have a “Recommended” column.
The registry [shall be/ has been] initially populated with the values described in
<xref target="signature-algorithms"/>. The following values SHALL be marked as
“Recommended”: ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384,
rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512,
rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, and ed25519.</t>
  <t>TLS PskKeyExchangeMode Registry: Values in the
range 0-253 (decimal) are assigned via Specification Required
<xref target="RFC8126"></xref>.  Values with the first byte 254 or 255 (decimal) are
reserved for Private Use <xref target="RFC8126"></xref>.  This registry SHALL have a
“Recommended” column.  The registry [shall be/ has been] initially
populated psk_ke (0) and psk_dhe_ke (1).  Both SHALL be marked as
“Recommended”.</t>
</list></t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2104" target='https://www.rfc-editor.org/info/rfc2104'>
<front>
<title>HMAC: Keyed-Hashing for Message Authentication</title>
<author initials='H.' surname='Krawczyk' fullname='H. Krawczyk'><organization /></author>
<author initials='M.' surname='Bellare' fullname='M. Bellare'><organization /></author>
<author initials='R.' surname='Canetti' fullname='R. Canetti'><organization /></author>
<date year='1997' month='February' />
<abstract><t>This document describes HMAC, a mechanism for message authentication using cryptographic hash functions. HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key.  The cryptographic strength of HMAC depends on the properties of the underlying hash function.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind</t></abstract>
</front>
<seriesInfo name='RFC' value='2104'/>
<seriesInfo name='DOI' value='10.17487/RFC2104'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC5280" target='https://www.rfc-editor.org/info/rfc5280'>
<front>
<title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
<author initials='D.' surname='Cooper' fullname='D. Cooper'><organization /></author>
<author initials='S.' surname='Santesson' fullname='S. Santesson'><organization /></author>
<author initials='S.' surname='Farrell' fullname='S. Farrell'><organization /></author>
<author initials='S.' surname='Boeyen' fullname='S. Boeyen'><organization /></author>
<author initials='R.' surname='Housley' fullname='R. Housley'><organization /></author>
<author initials='W.' surname='Polk' fullname='W. Polk'><organization /></author>
<date year='2008' month='May' />
<abstract><t>This memo profiles the X.509 v3 certificate and X.509 v2 certificate revocation list (CRL) for use in the Internet.  An overview of this approach and model is provided as an introduction.  The X.509 v3 certificate format is described in detail, with additional information regarding the format and semantics of Internet name forms.  Standard certificate extensions are described and two Internet-specific extensions are defined.  A set of required certificate extensions is specified.  The X.509 v2 CRL format is described in detail along with standard and Internet-specific extensions.  An algorithm for X.509 certification path validation is described.  An ASN.1 module and examples are provided in the appendices.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5280'/>
<seriesInfo name='DOI' value='10.17487/RFC5280'/>
</reference>



<reference  anchor="RFC5869" target='https://www.rfc-editor.org/info/rfc5869'>
<front>
<title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
<author initials='H.' surname='Krawczyk' fullname='H. Krawczyk'><organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'><organization /></author>
<date year='2010' month='May' />
<abstract><t>This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications.  The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions.  This document is not an Internet  Standards Track specification; it is published for informational  purposes.</t></abstract>
</front>
<seriesInfo name='RFC' value='5869'/>
<seriesInfo name='DOI' value='10.17487/RFC5869'/>
</reference>



<reference  anchor="RFC6066" target='https://www.rfc-editor.org/info/rfc6066'>
<front>
<title>Transport Layer Security (TLS) Extensions: Extension Definitions</title>
<author initials='D.' surname='Eastlake 3rd' fullname='D. Eastlake 3rd'><organization /></author>
<date year='2011' month='January' />
<abstract><t>This document provides specifications for existing TLS extensions.  It is a companion document for RFC 5246, &quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot;.  The extensions specified are server_name, max_fragment_length, client_certificate_url, trusted_ca_keys, truncated_hmac, and status_request.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6066'/>
<seriesInfo name='DOI' value='10.17487/RFC6066'/>
</reference>



<reference  anchor="RFC6655" target='https://www.rfc-editor.org/info/rfc6655'>
<front>
<title>AES-CCM Cipher Suites for Transport Layer Security (TLS)</title>
<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
<author initials='D.' surname='Bailey' fullname='D. Bailey'><organization /></author>
<date year='2012' month='July' />
<abstract><t>This memo describes the use of the Advanced Encryption Standard (AES) in the Counter with Cipher Block Chaining - Message Authentication Code (CBC-MAC) Mode (CCM) of operation within Transport Layer Security (TLS) and Datagram TLS (DTLS) to provide confidentiality and data origin authentication.  The AES-CCM algorithm is amenable to compact implementations, making it suitable for constrained environments.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6655'/>
<seriesInfo name='DOI' value='10.17487/RFC6655'/>
</reference>



<reference  anchor="RFC7539" target='https://www.rfc-editor.org/info/rfc7539'>
<front>
<title>ChaCha20 and Poly1305 for IETF Protocols</title>
<author initials='Y.' surname='Nir' fullname='Y. Nir'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This document defines the ChaCha20 stream cipher as well as the use of the Poly1305 authenticator, both as stand-alone algorithms and as a &quot;combined mode&quot;, or Authenticated Encryption with Associated Data (AEAD) algorithm.</t><t>This document does not introduce any new crypto, but is meant to serve as a stable reference and an implementation guide.  It is a product of the Crypto Forum Research Group (CFRG).</t></abstract>
</front>
<seriesInfo name='RFC' value='7539'/>
<seriesInfo name='DOI' value='10.17487/RFC7539'/>
</reference>



<reference  anchor="RFC7748" target='https://www.rfc-editor.org/info/rfc7748'>
<front>
<title>Elliptic Curves for Security</title>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<author initials='M.' surname='Hamburg' fullname='M. Hamburg'><organization /></author>
<author initials='S.' surname='Turner' fullname='S. Turner'><organization /></author>
<date year='2016' month='January' />
<abstract><t>This memo specifies two elliptic curves over prime fields that offer a high level of practical security in cryptographic applications, including Transport Layer Security (TLS).  These curves are intended to operate at the ~128-bit and ~224-bit security level, respectively, and are generated deterministically based on a list of required properties.</t></abstract>
</front>
<seriesInfo name='RFC' value='7748'/>
<seriesInfo name='DOI' value='10.17487/RFC7748'/>
</reference>



<reference  anchor="RFC7919" target='https://www.rfc-editor.org/info/rfc7919'>
<front>
<title>Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)</title>
<author initials='D.' surname='Gillmor' fullname='D. Gillmor'><organization /></author>
<date year='2016' month='August' />
<abstract><t>Traditional finite-field-based Diffie-Hellman (DH) key exchange during the Transport Layer Security (TLS) handshake suffers from a number of security, interoperability, and efficiency shortcomings. These shortcomings arise from lack of clarity about which DH group parameters TLS servers should offer and clients should accept.  This document offers a solution to these shortcomings for compatible peers by using a section of the TLS &quot;Supported Groups Registry&quot; (renamed from &quot;EC Named Curve Registry&quot; by this document) to establish common finite field DH parameters with known structure and a mechanism for peers to negotiate support for these groups.</t><t>This document updates TLS versions 1.0 (RFC 2246), 1.1 (RFC 4346), and 1.2 (RFC 5246), as well as the TLS Elliptic Curve Cryptography (ECC) extensions (RFC 4492).</t></abstract>
</front>
<seriesInfo name='RFC' value='7919'/>
<seriesInfo name='DOI' value='10.17487/RFC7919'/>
</reference>



<reference  anchor="RFC8032" target='https://www.rfc-editor.org/info/rfc8032'>
<front>
<title>Edwards-Curve Digital Signature Algorithm (EdDSA)</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'><organization /></author>
<author initials='I.' surname='Liusvaara' fullname='I. Liusvaara'><organization /></author>
<date year='2017' month='January' />
<abstract><t>This document describes elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA).  The algorithm is instantiated with recommended parameters for the edwards25519 and edwards448 curves.  An example implementation and test vectors are provided.</t></abstract>
</front>
<seriesInfo name='RFC' value='8032'/>
<seriesInfo name='DOI' value='10.17487/RFC8032'/>
</reference>



<reference  anchor="RFC8017" target='https://www.rfc-editor.org/info/rfc8017'>
<front>
<title>PKCS #1: RSA Cryptography Specifications Version 2.2</title>
<author initials='K.' surname='Moriarty' fullname='K. Moriarty' role='editor'><organization /></author>
<author initials='B.' surname='Kaliski' fullname='B. Kaliski'><organization /></author>
<author initials='J.' surname='Jonsson' fullname='J. Jonsson'><organization /></author>
<author initials='A.' surname='Rusch' fullname='A. Rusch'><organization /></author>
<date year='2016' month='November' />
<abstract><t>This document provides recommendations for the implementation of public-key cryptography based on the RSA algorithm, covering cryptographic primitives, encryption schemes, signature schemes with appendix, and ASN.1 syntax for representing keys and for identifying the schemes.</t><t>This document represents a republication of PKCS #1 v2.2 from RSA Laboratories' Public-Key Cryptography Standards (PKCS) series.  By publishing this RFC, change control is transferred to the IETF.</t><t>This document also obsoletes RFC 3447.</t></abstract>
</front>
<seriesInfo name='RFC' value='8017'/>
<seriesInfo name='DOI' value='10.17487/RFC8017'/>
</reference>



<reference  anchor="RFC8126" target='https://www.rfc-editor.org/info/rfc8126'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='M.' surname='Cotton' fullname='M. Cotton'><organization /></author>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<date year='2017' month='June' />
<abstract><t>Many protocols make use of points of extensibility that use constants to identify various protocol parameters.  To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper.  For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t><t>To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed.  This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t><t>This is the third edition of this document; it obsoletes RFC 5226.</t></abstract>
</front>
<seriesInfo name='BCP' value='26'/>
<seriesInfo name='RFC' value='8126'/>
<seriesInfo name='DOI' value='10.17487/RFC8126'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5116" target='https://www.rfc-editor.org/info/rfc5116'>
<front>
<title>An Interface and Algorithms for Authenticated Encryption</title>
<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
<date year='2008' month='January' />
<abstract><t>This document defines algorithms for Authenticated Encryption with Associated Data (AEAD), and defines a uniform interface and a registry for such algorithms.  The interface and registry can be used as an application-independent set of cryptoalgorithm suites.  This approach provides advantages in efficiency and security, and promotes the reuse of crypto implementations.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5116'/>
<seriesInfo name='DOI' value='10.17487/RFC5116'/>
</reference>


<reference anchor="X690" >
  <front>
    <title>Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
    <author >
      <organization>ITU-T</organization>
    </author>
    <date year="2002"/>
  </front>
  <seriesInfo name="ISO/IEC" value="8825-1:2002"/>
</reference>
<reference anchor="X962" >
  <front>
    <title>Public Key Cryptography For The Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
    <author >
      <organization>ANSI</organization>
    </author>
    <date year="1998"/>
  </front>
  <seriesInfo name="ANSI" value="X9.62"/>
</reference>
<reference anchor="DH" >
  <front>
    <title>New Directions in Cryptography</title>
    <author initials="W." surname="Diffie">
      <organization></organization>
    </author>
    <author initials="M." surname="Hellman">
      <organization></organization>
    </author>
    <date year="1977" month="June"/>
  </front>
  <seriesInfo name="IEEE Transactions on Information Theory, V.IT-22 n.6" value=""/>
</reference>
<reference anchor="GCM" >
  <front>
    <title>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</title>
    <author initials="M." surname="Dworkin">
      <organization></organization>
    </author>
    <date year="2007" month="November"/>
  </front>
  <seriesInfo name="NIST" value="Special Publication 800-38D"/>
</reference>




<reference  anchor="RFC7301" target='https://www.rfc-editor.org/info/rfc7301'>
<front>
<title>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</title>
<author initials='S.' surname='Friedl' fullname='S. Friedl'><organization /></author>
<author initials='A.' surname='Popov' fullname='A. Popov'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<author initials='E.' surname='Stephan' fullname='E. Stephan'><organization /></author>
<date year='2014' month='July' />
<abstract><t>This document describes a Transport Layer Security (TLS) extension for application-layer protocol negotiation within the TLS handshake. For instances in which multiple application protocols are supported on the same TCP or UDP port, this extension allows the application layer to negotiate which protocol will be used within the TLS connection.</t></abstract>
</front>
<seriesInfo name='RFC' value='7301'/>
<seriesInfo name='DOI' value='10.17487/RFC7301'/>
</reference>

<reference anchor="SHS" >
  <front>
    <title>Secure Hash Standard</title>
    <author initials="Q." surname="Dang" fullname="Quynh H. Dang">
      <organization></organization>
    </author>
    <date year="2015" month="July"/>
  </front>
  <seriesInfo name="National Institute of Standards and Technology" value="report"/>
  <seriesInfo name="DOI" value="10.6028/nist.fips.180-4"/>
</reference>



<reference  anchor="RFC5756" target='https://www.rfc-editor.org/info/rfc5756'>
<front>
<title>Updates for RSAES-OAEP and RSASSA-PSS Algorithm Parameters</title>
<author initials='S.' surname='Turner' fullname='S. Turner'><organization /></author>
<author initials='D.' surname='Brown' fullname='D. Brown'><organization /></author>
<author initials='K.' surname='Yiu' fullname='K. Yiu'><organization /></author>
<author initials='R.' surname='Housley' fullname='R. Housley'><organization /></author>
<author initials='T.' surname='Polk' fullname='T. Polk'><organization /></author>
<date year='2010' month='January' />
<abstract><t>This document updates RFC 4055.  It updates the conventions for using the RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP) key transport algorithm in the Internet X.509 Public Key Infrastructure (PKI).  Specifically, it updates the conventions for algorithm parameters in an X.509 certificate's subjectPublicKeyInfo field.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5756'/>
<seriesInfo name='DOI' value='10.17487/RFC5756'/>
</reference>



<reference  anchor="RFC6962" target='https://www.rfc-editor.org/info/rfc6962'>
<front>
<title>Certificate Transparency</title>
<author initials='B.' surname='Laurie' fullname='B. Laurie'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<author initials='E.' surname='Kasper' fullname='E. Kasper'><organization /></author>
<date year='2013' month='June' />
<abstract><t>This document describes an experimental protocol for publicly logging the existence of Transport Layer Security (TLS) certificates as they are issued or observed, in a manner that allows anyone to audit certificate authority (CA) activity and notice the issuance of suspect certificates as well as to audit the certificate logs themselves.  The intent is that eventually clients would refuse to honor certificates that do not appear in a log, effectively forcing CAs to add all issued certificates to the logs.</t><t>Logs are network services that implement the protocol operations for submissions and queries that are defined in this document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6962'/>
<seriesInfo name='DOI' value='10.17487/RFC6962'/>
</reference>



<reference  anchor="RFC6961" target='https://www.rfc-editor.org/info/rfc6961'>
<front>
<title>The Transport Layer Security (TLS) Multiple Certificate Status Request Extension</title>
<author initials='Y.' surname='Pettersen' fullname='Y. Pettersen'><organization /></author>
<date year='2013' month='June' />
<abstract><t>This document defines the Transport Layer Security (TLS) Certificate Status Version 2 Extension to allow clients to specify and support several certificate status methods.  (The use of the Certificate Status extension is commonly referred to as &quot;OCSP stapling&quot;.)  Also defined is a new method based on the Online Certificate Status Protocol (OCSP) that servers can use to provide status information about not only the server's own certificate but also the status of intermediate certificates in the chain.</t></abstract>
</front>
<seriesInfo name='RFC' value='6961'/>
<seriesInfo name='DOI' value='10.17487/RFC6961'/>
</reference>



<reference  anchor="RFC6960" target='https://www.rfc-editor.org/info/rfc6960'>
<front>
<title>X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP</title>
<author initials='S.' surname='Santesson' fullname='S. Santesson'><organization /></author>
<author initials='M.' surname='Myers' fullname='M. Myers'><organization /></author>
<author initials='R.' surname='Ankney' fullname='R. Ankney'><organization /></author>
<author initials='A.' surname='Malpani' fullname='A. Malpani'><organization /></author>
<author initials='S.' surname='Galperin' fullname='S. Galperin'><organization /></author>
<author initials='C.' surname='Adams' fullname='C. Adams'><organization /></author>
<date year='2013' month='June' />
<abstract><t>This document specifies a protocol useful in determining the current status of a digital certificate without requiring Certificate Revocation Lists (CRLs). Additional mechanisms addressing PKIX operational requirements are specified in separate documents.  This document obsoletes RFCs 2560 and 6277.  It also updates RFC 5912.</t></abstract>
</front>
<seriesInfo name='RFC' value='6960'/>
<seriesInfo name='DOI' value='10.17487/RFC6960'/>
</reference>



<reference  anchor="RFC7507" target='https://www.rfc-editor.org/info/rfc7507'>
<front>
<title>TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks</title>
<author initials='B.' surname='Moeller' fullname='B. Moeller'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<date year='2015' month='April' />
<abstract><t>This document defines a Signaling Cipher Suite Value (SCSV) that prevents protocol downgrade attacks on the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols.  It updates RFCs 2246, 4346, 4347, 5246, and 6347.  Server update considerations are included.</t></abstract>
</front>
<seriesInfo name='RFC' value='7507'/>
<seriesInfo name='DOI' value='10.17487/RFC7507'/>
</reference>

<reference anchor="DH76" >
  <front>
    <title>New directions in cryptography</title>
    <author initials="W." surname="Diffie" fullname="W. Diffie">
      <organization></organization>
    </author>
    <author initials="M." surname="Hellman" fullname="M. Hellman">
      <organization></organization>
    </author>
    <date year="1976" month="November"/>
  </front>
  <seriesInfo name="IEEE Transactions on Information Theory" value="Vol. 22, pp. 644-654"/>
  <seriesInfo name="DOI" value="10.1109/tit.1976.1055638"/>
</reference>



<reference  anchor="RFC5705" target='https://www.rfc-editor.org/info/rfc5705'>
<front>
<title>Keying Material Exporters for Transport Layer Security (TLS)</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2010' month='March' />
<abstract><t>A number of protocols wish to leverage Transport Layer Security (TLS) to perform key establishment but then use some of the keying material for their own purposes.  This document describes a general mechanism for allowing that.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5705'/>
<seriesInfo name='DOI' value='10.17487/RFC5705'/>
</reference>



<reference  anchor="RFC6979" target='https://www.rfc-editor.org/info/rfc6979'>
<front>
<title>Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
<author initials='T.' surname='Pornin' fullname='T. Pornin'><organization /></author>
<date year='2013' month='August' />
<abstract><t>This document defines a deterministic digital signature generation procedure.  Such signatures are compatible with standard Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA) digital signatures and can be processed with unmodified verifiers, which need not be aware of the procedure described therein.  Deterministic signatures retain the cryptographic security features associated with digital signatures but can be more easily implemented in various environments, since they do not need access to a source of high-quality randomness.</t></abstract>
</front>
<seriesInfo name='RFC' value='6979'/>
<seriesInfo name='DOI' value='10.17487/RFC6979'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC4086" target='https://www.rfc-editor.org/info/rfc4086'>
<front>
<title>Randomness Requirements for Security</title>
<author initials='D.' surname='Eastlake 3rd' fullname='D. Eastlake 3rd'><organization /></author>
<author initials='J.' surname='Schiller' fullname='J. Schiller'><organization /></author>
<author initials='S.' surname='Crocker' fullname='S. Crocker'><organization /></author>
<date year='2005' month='June' />
<abstract><t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts.  However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t><t>Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='106'/>
<seriesInfo name='RFC' value='4086'/>
<seriesInfo name='DOI' value='10.17487/RFC4086'/>
</reference>



<reference  anchor="RFC4346" target='https://www.rfc-editor.org/info/rfc4346'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.1</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2006' month='April' />
<abstract><t>This document specifies Version 1.1 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4346'/>
<seriesInfo name='DOI' value='10.17487/RFC4346'/>
</reference>



<reference  anchor="RFC4366" target='https://www.rfc-editor.org/info/rfc4366'>
<front>
<title>Transport Layer Security (TLS) Extensions</title>
<author initials='S.' surname='Blake-Wilson' fullname='S. Blake-Wilson'><organization /></author>
<author initials='M.' surname='Nystrom' fullname='M. Nystrom'><organization /></author>
<author initials='D.' surname='Hopwood' fullname='D. Hopwood'><organization /></author>
<author initials='J.' surname='Mikkelsen' fullname='J. Mikkelsen'><organization /></author>
<author initials='T.' surname='Wright' fullname='T. Wright'><organization /></author>
<date year='2006' month='April' />
<abstract><t>This document describes extensions that may be used to add functionality to Transport Layer Security (TLS).  It provides both generic extension mechanisms for the TLS handshake client and server hellos, and specific extensions using these generic mechanisms.</t><t>The extensions may be used by TLS clients and servers.  The extensions are backwards compatible: communication is possible between TLS clients that support the extensions and TLS servers that do not support the extensions, and vice versa.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4366'/>
<seriesInfo name='DOI' value='10.17487/RFC4366'/>
</reference>



<reference  anchor="RFC4492" target='https://www.rfc-editor.org/info/rfc4492'>
<front>
<title>Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</title>
<author initials='S.' surname='Blake-Wilson' fullname='S. Blake-Wilson'><organization /></author>
<author initials='N.' surname='Bolyard' fullname='N. Bolyard'><organization /></author>
<author initials='V.' surname='Gupta' fullname='V. Gupta'><organization /></author>
<author initials='C.' surname='Hawk' fullname='C. Hawk'><organization /></author>
<author initials='B.' surname='Moeller' fullname='B. Moeller'><organization /></author>
<date year='2006' month='May' />
<abstract><t>This document describes new key exchange algorithms based on Elliptic Curve Cryptography (ECC) for the Transport Layer Security (TLS) protocol.  In particular, it specifies the use of Elliptic Curve Diffie-Hellman (ECDH) key agreement in a TLS handshake and the use of Elliptic Curve Digital Signature Algorithm (ECDSA) as a new authentication mechanism.  This memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='4492'/>
<seriesInfo name='DOI' value='10.17487/RFC4492'/>
</reference>



<reference  anchor="RFC5077" target='https://www.rfc-editor.org/info/rfc5077'>
<front>
<title>Transport Layer Security (TLS) Session Resumption without Server-Side State</title>
<author initials='J.' surname='Salowey' fullname='J. Salowey'><organization /></author>
<author initials='H.' surname='Zhou' fullname='H. Zhou'><organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'><organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'><organization /></author>
<date year='2008' month='January' />
<abstract><t>This document describes a mechanism that enables the Transport Layer Security (TLS) server to resume sessions and avoid keeping per-client session state.  The TLS server encapsulates the session state into a ticket and forwards it to the client.  The client can subsequently resume a session using the obtained ticket.  This document obsoletes RFC 4507.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5077'/>
<seriesInfo name='DOI' value='10.17487/RFC5077'/>
</reference>



<reference  anchor="RFC5246" target='https://www.rfc-editor.org/info/rfc5246'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5246'/>
<seriesInfo name='DOI' value='10.17487/RFC5246'/>
</reference>



<reference  anchor="RFC5764" target='https://www.rfc-editor.org/info/rfc5764'>
<front>
<title>Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)</title>
<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2010' month='May' />
<abstract><t>This document describes a Datagram Transport Layer Security (DTLS) extension to establish keys for Secure RTP (SRTP) and Secure RTP Control Protocol (SRTCP) flows.  DTLS keying happens on the media path, independent of any out-of-band signalling channel present. [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5764'/>
<seriesInfo name='DOI' value='10.17487/RFC5764'/>
</reference>



<reference  anchor="RFC5929" target='https://www.rfc-editor.org/info/rfc5929'>
<front>
<title>Channel Bindings for TLS</title>
<author initials='J.' surname='Altman' fullname='J. Altman'><organization /></author>
<author initials='N.' surname='Williams' fullname='N. Williams'><organization /></author>
<author initials='L.' surname='Zhu' fullname='L. Zhu'><organization /></author>
<date year='2010' month='July' />
<abstract><t>This document defines three channel binding types for Transport Layer Security (TLS), tls-unique, tls-server-end-point, and tls-unique-for-telnet, in accordance with RFC 5056 (On Channel Binding).</t><t>Note that based on implementation experience, this document changes the original definition of 'tls-unique' channel binding type in the channel binding type IANA registry.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5929'/>
<seriesInfo name='DOI' value='10.17487/RFC5929'/>
</reference>



<reference  anchor="RFC6176" target='https://www.rfc-editor.org/info/rfc6176'>
<front>
<title>Prohibiting Secure Sockets Layer (SSL) Version 2.0</title>
<author initials='S.' surname='Turner' fullname='S. Turner'><organization /></author>
<author initials='T.' surname='Polk' fullname='T. Polk'><organization /></author>
<date year='2011' month='March' />
<abstract><t>This document requires that when Transport Layer Security (TLS) clients and servers establish connections, they never negotiate the use of  Secure Sockets Layer (SSL) version 2.0.  This document updates the  backward compatibility sections found in the Transport Layer Security (TLS). [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6176'/>
<seriesInfo name='DOI' value='10.17487/RFC6176'/>
</reference>



<reference  anchor="RFC6091" target='https://www.rfc-editor.org/info/rfc6091'>
<front>
<title>Using OpenPGP Keys for Transport Layer Security (TLS) Authentication</title>
<author initials='N.' surname='Mavrogiannopoulos' fullname='N. Mavrogiannopoulos'><organization /></author>
<author initials='D.' surname='Gillmor' fullname='D. Gillmor'><organization /></author>
<date year='2011' month='February' />
<abstract><t>This memo defines Transport Layer Security (TLS) extensions and associated semantics that allow clients and servers to negotiate the use of OpenPGP certificates for a TLS session, and specifies how to transport OpenPGP certificates via TLS.  It also defines the registry for non-X.509 certificate types.  This document is not an Internet  Standards Track specification; it is published for informational purposes.</t></abstract>
</front>
<seriesInfo name='RFC' value='6091'/>
<seriesInfo name='DOI' value='10.17487/RFC6091'/>
</reference>



<reference  anchor="RFC6520" target='https://www.rfc-editor.org/info/rfc6520'>
<front>
<title>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension</title>
<author initials='R.' surname='Seggelmann' fullname='R. Seggelmann'><organization /></author>
<author initials='M.' surname='Tuexen' fullname='M. Tuexen'><organization /></author>
<author initials='M.' surname='Williams' fullname='M. Williams'><organization /></author>
<date year='2012' month='February' />
<abstract><t>This document describes the Heartbeat Extension for the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols.</t><t>The Heartbeat Extension provides a new protocol for TLS/DTLS allowing the usage of keep-alive functionality without performing a renegotiation and a basis for path MTU (PMTU) discovery for DTLS.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6520'/>
<seriesInfo name='DOI' value='10.17487/RFC6520'/>
</reference>



<reference  anchor="RFC8305" target='https://www.rfc-editor.org/info/rfc8305'>
<front>
<title>Happy Eyeballs Version 2: Better Connectivity Using Concurrency</title>
<author initials='D.' surname='Schinazi' fullname='D. Schinazi'><organization /></author>
<author initials='T.' surname='Pauly' fullname='T. Pauly'><organization /></author>
<date year='2017' month='December' />
<abstract><t>Many communication protocols operating over the modern Internet use hostnames.  These often resolve to multiple IP addresses, each of which may have different performance and connectivity characteristics.  Since specific addresses or address families (IPv4 or IPv6) may be blocked, broken, or sub-optimal on a network, clients that attempt multiple connections in parallel have a chance of establishing a connection more quickly.  This document specifies requirements for algorithms that reduce this user-visible delay and provides an example algorithm, referred to as &quot;Happy Eyeballs&quot;.  This document obsoletes the original algorithm description in RFC 6555.</t></abstract>
</front>
<seriesInfo name='RFC' value='8305'/>
<seriesInfo name='DOI' value='10.17487/RFC8305'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC7250" target='https://www.rfc-editor.org/info/rfc7250'>
<front>
<title>Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
<author initials='P.' surname='Wouters' fullname='P. Wouters' role='editor'><organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig' role='editor'><organization /></author>
<author initials='J.' surname='Gilmore' fullname='J. Gilmore'><organization /></author>
<author initials='S.' surname='Weiler' fullname='S. Weiler'><organization /></author>
<author initials='T.' surname='Kivinen' fullname='T. Kivinen'><organization /></author>
<date year='2014' month='June' />
<abstract><t>This document specifies a new certificate type and two TLS extensions for exchanging raw public keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS).  The new certificate type allows raw public keys to be used for authentication.</t></abstract>
</front>
<seriesInfo name='RFC' value='7250'/>
<seriesInfo name='DOI' value='10.17487/RFC7250'/>
</reference>



<reference  anchor="RFC7465" target='https://www.rfc-editor.org/info/rfc7465'>
<front>
<title>Prohibiting RC4 Cipher Suites</title>
<author initials='A.' surname='Popov' fullname='A. Popov'><organization /></author>
<date year='2015' month='February' />
<abstract><t>This document requires that Transport Layer Security (TLS) clients and servers never negotiate the use of RC4 cipher suites when they establish connections.  This applies to all TLS versions.  This document updates RFCs 5246, 4346, and 2246.</t></abstract>
</front>
<seriesInfo name='RFC' value='7465'/>
<seriesInfo name='DOI' value='10.17487/RFC7465'/>
</reference>



<reference  anchor="RFC7568" target='https://www.rfc-editor.org/info/rfc7568'>
<front>
<title>Deprecating Secure Sockets Layer Version 3.0</title>
<author initials='R.' surname='Barnes' fullname='R. Barnes'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson'><organization /></author>
<author initials='A.' surname='Pironti' fullname='A. Pironti'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<date year='2015' month='June' />
<abstract><t>The Secure Sockets Layer version 3.0 (SSLv3), as specified in RFC 6101, is not sufficiently secure.  This document requires that SSLv3 not be used.  The replacement versions, in particular, Transport Layer Security (TLS) 1.2 (RFC 5246), are considerably more secure and capable protocols.</t><t>This document updates the backward compatibility section of RFC 5246 and its predecessors to prohibit fallback to SSLv3.</t></abstract>
</front>
<seriesInfo name='RFC' value='7568'/>
<seriesInfo name='DOI' value='10.17487/RFC7568'/>
</reference>



<reference  anchor="RFC7627" target='https://www.rfc-editor.org/info/rfc7627'>
<front>
<title>Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension</title>
<author initials='K.' surname='Bhargavan' fullname='K. Bhargavan' role='editor'><organization /></author>
<author initials='A.' surname='Delignat-Lavaud' fullname='A. Delignat-Lavaud'><organization /></author>
<author initials='A.' surname='Pironti' fullname='A. Pironti'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<author initials='M.' surname='Ray' fullname='M. Ray'><organization /></author>
<date year='2015' month='September' />
<abstract><t>The Transport Layer Security (TLS) master secret is not cryptographically bound to important session parameters such as the server certificate.  Consequently, it is possible for an active attacker to set up two sessions, one with a client and another with a server, such that the master secrets on the two sessions are the same.  Thereafter, any mechanism that relies on the master secret for authentication, including session resumption, becomes vulnerable to a man-in-the-middle attack, where the attacker can simply forward messages back and forth between the client and server.  This specification defines a TLS extension that contextually binds the master secret to a log of the full handshake that computes it, thus preventing such attacks.</t></abstract>
</front>
<seriesInfo name='RFC' value='7627'/>
<seriesInfo name='DOI' value='10.17487/RFC7627'/>
</reference>



<reference  anchor="RFC7685" target='https://www.rfc-editor.org/info/rfc7685'>
<front>
<title>A Transport Layer Security (TLS) ClientHello Padding Extension</title>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<date year='2015' month='October' />
<abstract><t>This memo describes a Transport Layer Security (TLS) extension that can be used to pad ClientHello messages to a desired size.</t></abstract>
</front>
<seriesInfo name='RFC' value='7685'/>
<seriesInfo name='DOI' value='10.17487/RFC7685'/>
</reference>


<reference anchor="DSS" >
  <front>
    <title>Digital Signature Standard, version 4</title>
    <author >
      <organization>National Institute of Standards and Technology, U.S. Department of Commerce</organization>
    </author>
    <date year="2013"/>
  </front>
  <seriesInfo name="NIST" value="FIPS PUB 186-4"/>
</reference>
<reference anchor="ECDSA" >
  <front>
    <title>Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
    <author >
      <organization>American National Standards Institute</organization>
    </author>
    <date year="2005" month="November"/>
  </front>
  <seriesInfo name="ANSI" value="ANS X9.62-2005"/>
</reference>
<reference anchor="RSA" >
  <front>
    <title>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</title>
    <author initials="R." surname="Rivest">
      <organization></organization>
    </author>
    <author initials="A." surname="Shamir">
      <organization></organization>
    </author>
    <author initials="L.M." surname="Adleman">
      <organization></organization>
    </author>
    <date year="1978" month="February"/>
  </front>
  <seriesInfo name="Communications of the ACM" value="v. 21, n. 2, pp. 120-126."/>
</reference>
<reference anchor="SSL2" >
  <front>
    <title>The SSL Protocol</title>
    <author initials="K." surname="Hickman" fullname="Kipp Hickman">
      <organization>Netscape Communications Corp.</organization>
    </author>
    <date year="1995" month="February" day="09"/>
  </front>
</reference>
<reference anchor="SSL3" >
  <front>
    <title>The SSL 3.0 Protocol</title>
    <author initials="A." surname="Freier">
      <organization>Netscape Communications Corp.</organization>
    </author>
    <author initials="P." surname="Karlton">
      <organization>Netscape Communications Corp.</organization>
    </author>
    <author initials="P." surname="Kocher">
      <organization>Netscape Communications Corp.</organization>
    </author>
    <date year="1996" month="November" day="18"/>
  </front>
</reference>
<reference anchor="TIMING" >
  <front>
    <title>Remote timing attacks are practical</title>
    <author initials="D." surname="Boneh">
      <organization></organization>
    </author>
    <author initials="D." surname="Brumley">
      <organization></organization>
    </author>
    <date year="2003"/>
  </front>
  <seriesInfo name="USENIX" value="Security Symposium"/>
</reference>
<reference anchor="X501" >
  <front>
    <title>Information Technology - Open Systems Interconnection - The Directory: Models</title>
    <author >
      <organization></organization>
    </author>
    <date year="1993"/>
  </front>
  <seriesInfo name="ITU-T" value="X.501"/>
</reference>
<reference anchor="IEEE1363" >
  <front>
    <title>Standard Specifications for Public Key Cryptography</title>
    <author >
      <organization>IEEE</organization>
    </author>
    <date year="2000"/>
  </front>
  <seriesInfo name="IEEE 1363" value=""/>
</reference>
<reference anchor="PSK-FINISHED" target="https://www.ietf.org/mail-archive/web/tls/current/msg18215.html">
  <front>
    <title>Revision 10: possible attack if client authentication is allowed during PSK</title>
    <author initials="C." surname="Cremers">
      <organization></organization>
    </author>
    <author initials="M." surname="Horvat">
      <organization></organization>
    </author>
    <author initials="T." surname="van der Merwe">
      <organization></organization>
    </author>
    <author initials="S." surname="Scott">
      <organization></organization>
    </author>
    <date year="2015"/>
  </front>
</reference>
<reference anchor="CHHSV17" target="https://www.ietf.org/mail-archive/web/tls/current/msg22382.html">
  <front>
    <title>Awkward Handshake: Possible mismatch of client/server view on client authentication in post-handshake mode in Revision 18</title>
    <author initials="C." surname="Cremers">
      <organization></organization>
    </author>
    <author initials="M." surname="Horvat">
      <organization></organization>
    </author>
    <author initials="J." surname="Hoyland">
      <organization></organization>
    </author>
    <author initials="T." surname="van der Merwe">
      <organization></organization>
    </author>
    <author initials="S." surname="Scott">
      <organization></organization>
    </author>
    <date year="2017"/>
  </front>
</reference>
<reference anchor="SLOTH" >
  <front>
    <title>Transcript Collision Attacks: Breaking Authentication in TLS, IKE, and SSH</title>
    <author initials="K." surname="Bhargavan">
      <organization></organization>
    </author>
    <author initials="G." surname="Leurent">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Network and Distributed System Security Symposium (NDSS 2016)" value=""/>
</reference>
<reference anchor="AEAD-LIMITS" target="http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf">
  <front>
    <title>Limits on Authenticated Encryption Use in TLS</title>
    <author initials="A." surname="Luykx">
      <organization></organization>
    </author>
    <author initials="K." surname="Paterson">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
</reference>
<reference anchor="CK01" >
  <front>
    <title>Analysis of Key-Exchange Protocols and Their Use for Building Secure Channels</title>
    <author initials="R." surname="Canetti">
      <organization></organization>
    </author>
    <author initials="H." surname="Krawczyk">
      <organization></organization>
    </author>
    <date year="2001"/>
  </front>
  <seriesInfo name="Proceedings of Eurocrypt 2001" value=""/>
</reference>
<reference anchor="CCG16" >
  <front>
    <title>On Post-Compromise Security</title>
    <author initials="K." surname="Cohn-Gordon">
      <organization></organization>
    </author>
    <author initials="C." surname="Cremers">
      <organization></organization>
    </author>
    <author initials="L." surname="Garratt">
      <organization></organization>
    </author>
    <date year="2015"/>
  </front>
  <seriesInfo name="IEEE Computer Security Foundations Symposium" value=""/>
</reference>
<reference anchor="BBFKZG16" >
  <front>
    <title>Downgrade Resilience in Key-Exchange Protocols</title>
    <author initials="K." surname="Bhargavan">
      <organization></organization>
    </author>
    <author initials="C." surname="Brzuska">
      <organization></organization>
    </author>
    <author initials="C." surname="Fournet">
      <organization></organization>
    </author>
    <author initials="M." surname="Kohlweiss">
      <organization></organization>
    </author>
    <author initials="S." surname="Zanella-Beguelin">
      <organization></organization>
    </author>
    <author initials="M." surname="Green">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Proceedings of IEEE Symposium on Security and Privacy (Oakland) 2016" value=""/>
</reference>
<reference anchor="DOW92" >
  <front>
    <title>Authentication and authenticated key exchanges</title>
    <author initials="W." surname="Diffie">
      <organization></organization>
    </author>
    <author initials="P." surname="van Oorschot">
      <organization></organization>
    </author>
    <author initials="M." surname="Wiener">
      <organization></organization>
    </author>
    <date year="1992"/>
  </front>
  <seriesInfo name="Designs, Codes and Cryptography" value=""/>
</reference>
<reference anchor="HGFS15" >
  <front>
    <title>Prying Open Pandora's Box: KCI Attacks against TLS</title>
    <author initials="C." surname="Hlauschek">
      <organization></organization>
    </author>
    <author initials="M." surname="Gruber">
      <organization></organization>
    </author>
    <author initials="F." surname="Fankhauser">
      <organization></organization>
    </author>
    <author initials="C." surname="Schanes">
      <organization></organization>
    </author>
    <date year="2015"/>
  </front>
  <seriesInfo name="Proceedings of USENIX Workshop on Offensive Technologies" value=""/>
</reference>
<reference anchor="SIGMA" >
  <front>
    <title>SIGMA: the 'SIGn-and-MAc' approach to authenticated Diffie-Hellman and its use in the IKE protocols</title>
    <author initials="H." surname="Krawczyk">
      <organization></organization>
    </author>
    <date year="2003"/>
  </front>
  <seriesInfo name="Proceedings of CRYPTO 2003" value=""/>
</reference>
<reference anchor="CHSV16" target="http://ieeexplore.ieee.org/document/7546518/">
  <front>
    <title>Automated Analysis and Verification of TLS 1.3: 0-RTT, Resumption and Delayed Authentication</title>
    <author initials="C." surname="Cremers">
      <organization></organization>
    </author>
    <author initials="M." surname="Horvat">
      <organization></organization>
    </author>
    <author initials="S." surname="Scott">
      <organization></organization>
    </author>
    <author initials="T." surname="van der Merwe">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Proceedings of IEEE Symposium on Security and Privacy (Oakland) 2016" value=""/>
</reference>
<reference anchor="FGSW16" target="http://ieeexplore.ieee.org/document/7546517/">
  <front>
    <title>Key Confirmation in Key Exchange: A Formal Treatment and Implications for TLS 1.3</title>
    <author initials="M." surname="Fischlin">
      <organization></organization>
    </author>
    <author initials="F." surname="Guenther">
      <organization></organization>
    </author>
    <author initials="B." surname="Schmidt">
      <organization></organization>
    </author>
    <author initials="B." surname="Warinschi">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Proceedings of IEEE Symposium on Security and Privacy (Oakland) 2016" value=""/>
</reference>
<reference anchor="LXZFH16" target="http://ieeexplore.ieee.org/document/7546519/">
  <front>
    <title>Multiple Handshakes Security of TLS 1.3 Candidates</title>
    <author initials="X." surname="Li">
      <organization></organization>
    </author>
    <author initials="J." surname="Xu">
      <organization></organization>
    </author>
    <author initials="D." surname="Feng">
      <organization></organization>
    </author>
    <author initials="Z." surname="Zhang">
      <organization></organization>
    </author>
    <author initials="H." surname="Hu">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Proceedings of IEEE Symposium on Security and Privacy (Oakland) 2016" value=""/>
</reference>
<reference anchor="FW15" >
  <front>
    <title>Factoring RSA Keys With TLS Perfect Forward Secrecy</title>
    <author initials="." surname="Florian Weimer">
      <organization>Red Hat Product Security</organization>
    </author>
    <date year="2015" month="September"/>
  </front>
</reference>
<reference anchor="REKEY" >
  <front>
    <title>Increasing the Lifetime of a Key: A Comparative Analysis of the Security of Re-keying Techniques</title>
    <author initials="M." surname="Abdalla">
      <organization></organization>
    </author>
    <author initials="M." surname="Bellare">
      <organization></organization>
    </author>
    <date year="2000" month="October"/>
  </front>
  <seriesInfo name="ASIACRYPT2000" value=""/>
</reference>
<reference anchor="BDFKPPRSZZ16" target="https://eprint.iacr.org/2016/1178">
  <front>
    <title>Implementing and Proving the TLS 1.3 Record Layer</title>
    <author initials="K." surname="Bhargavan">
      <organization></organization>
    </author>
    <author initials="A." surname="Delignat-Lavaud">
      <organization></organization>
    </author>
    <author initials="C." surname="Fournet">
      <organization></organization>
    </author>
    <author initials="M." surname="Kohlweiss">
      <organization></organization>
    </author>
    <author initials="J." surname="Pan">
      <organization></organization>
    </author>
    <author initials="J." surname="Protzenko">
      <organization></organization>
    </author>
    <author initials="A." surname="Rastogi">
      <organization></organization>
    </author>
    <author initials="N." surname="Swamy">
      <organization></organization>
    </author>
    <author initials="S." surname="Zanella-Beguelin">
      <organization></organization>
    </author>
    <author initials="J.K." surname="Zinzindohoue">
      <organization></organization>
    </author>
    <date year="2016" month="December"/>
  </front>
  <seriesInfo name="Proceedings of IEEE Symposium on Security and Privacy (Oakland) 2017" value=""/>
</reference>
<reference anchor="BMMT15" target="https://eprint.iacr.org/2015/394">
  <front>
    <title>Augmented Secure Channels and the Goal of the TLS 1.3 Record Layer</title>
    <author initials="C." surname="Badertscher">
      <organization></organization>
    </author>
    <author initials="C." surname="Matt">
      <organization></organization>
    </author>
    <author initials="U." surname="Maurer">
      <organization></organization>
    </author>
    <author initials="B." surname="Tackmann">
      <organization></organization>
    </author>
    <date year="2015" month="September"/>
  </front>
  <seriesInfo name="ProvSec 2015" value=""/>
</reference>
<reference anchor="BT16" target="https://eprint.iacr.org/2016/564">
  <front>
    <title>The Multi-User Security of Authenticated Encryption: AES-GCM in TLS 1.3</title>
    <author initials="M." surname="Bellare">
      <organization></organization>
    </author>
    <author initials="B." surname="Tackmann">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Proceedings of CRYPTO 2016" value=""/>
</reference>
<reference anchor="Kraw16" target="https://eprint.iacr.org/2016/711">
  <front>
    <title>A Unilateral-to-Mutual Authentication Compiler for Key Exchange (with Applications to Client Authentication in TLS 1.3</title>
    <author initials="H." surname="Krawczyk">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Proceedings of ACM CCS 2016" value=""/>
</reference>
<reference anchor="KW16" target="https://eprint.iacr.org/2015/978">
  <front>
    <title>The OPTLS Protocol and TLS 1.3</title>
    <author initials="H." surname="Krawczyk">
      <organization></organization>
    </author>
    <author initials="H." surname="Wee">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Proceedings of Euro S&quot;P 2016" value=""/>
</reference>
<reference anchor="DFGS15" target="https://eprint.iacr.org/2015/914">
  <front>
    <title>A Cryptographic Analysis of the TLS 1.3 draft-10 Full and Pre-shared Key Handshake Protocol</title>
    <author initials="B." surname="Dowling">
      <organization></organization>
    </author>
    <author initials="M." surname="Fischlin">
      <organization></organization>
    </author>
    <author initials="F." surname="Guenther">
      <organization></organization>
    </author>
    <author initials="D." surname="Stebila">
      <organization></organization>
    </author>
    <date year="2015"/>
  </front>
  <seriesInfo name="Proceedings of ACM CCS 2015" value=""/>
</reference>
<reference anchor="DFGS16" target="https://eprint.iacr.org/2016/081">
  <front>
    <title>A Cryptographic Analysis of the TLS 1.3 draft-10 Full and Pre-shared Key Handshake Protocol</title>
    <author initials="B." surname="Dowling">
      <organization></organization>
    </author>
    <author initials="M." surname="Fischlin">
      <organization></organization>
    </author>
    <author initials="F." surname="Guenther">
      <organization></organization>
    </author>
    <author initials="D." surname="Stebila">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="TRON 2016" value=""/>
</reference>
<reference anchor="FG17" target="https://eprint.iacr.org/2017/082">
  <front>
    <title>Replay Attacks on Zero Round-Trip Time: The Case of the TLS 1.3 Handshake Candidates</title>
    <author initials="M." surname="Fischlin">
      <organization></organization>
    </author>
    <author initials="F." surname="Guenther">
      <organization></organization>
    </author>
    <date year="2017"/>
  </front>
  <seriesInfo name="Proceedings of Euro S&quot;P 2017" value=""/>
</reference>
<reference anchor="BBK17" >
  <front>
    <title>Verified Models and Reference Implementations for the TLS 1.3 Standard Candidate</title>
    <author initials="K." surname="Bhargavan">
      <organization></organization>
    </author>
    <author initials="B." surname="Blanchet">
      <organization></organization>
    </author>
    <author initials="N." surname="Kobeissi">
      <organization></organization>
    </author>
    <date year="2017"/>
  </front>
  <seriesInfo name="Proceedings of IEEE Symposium on Security and Privacy (Oakland) 2017" value=""/>
</reference>
<reference anchor="Kraw10" target="https://eprint.iacr.org/2010/264">
  <front>
    <title>Cryptographic Extraction and Key Derivation: The HKDF Scheme</title>
    <author initials="H." surname="Krawczyk">
      <organization></organization>
    </author>
    <date year="2010"/>
  </front>
  <seriesInfo name="Proceedings of CRYPTO 2010" value=""/>
</reference>
<reference anchor="Mac17" target="https://github.com/tlswg/tls13-spec/issues/1001">
  <front>
    <title>Security Review of TLS1.3 0-RTT</title>
    <author initials="C." surname="MacCarthaigh">
      <organization></organization>
    </author>
    <date year="2017"/>
  </front>
</reference>
<reference anchor="Res17a" target="https://www.ietf.org/mail-archive/web/tls/current/msg25091.html">
  <front>
    <title>Preliminary data on Firefox TLS 1.3 Middlebox experiment</title>
    <author initials="E." surname="Rescorla">
      <organization></organization>
    </author>
    <date year="2017"/>
  </front>
</reference>
<reference anchor="Res17b" target="https://www.ietf.org/mail-archive/web/tls/current/msg25179.html">
  <front>
    <title>More compatibility measurement results</title>
    <author initials="E." surname="Rescorla">
      <organization></organization>
    </author>
    <date year="2017"/>
  </front>
</reference>
<reference anchor="Ben17a" target="https://datatracker.ietf.org/meeting/100/materials/slides-100-tls-sessa-tls13/">
  <front>
    <title>Presentation before the TLS WG at IETF 100</title>
    <author initials="D." surname="Benjamin">
      <organization></organization>
    </author>
    <date year="2017"/>
  </front>
</reference>
<reference anchor="Ben17b" target="https://www.ietf.org/mail-archive/web/tls/current/msg25168.html">
  <front>
    <title>Additional TLS 1.3 results from Chrome</title>
    <author initials="D." surname="Benjamin">
      <organization></organization>
    </author>
    <date year="2017"/>
  </front>
</reference>
<reference anchor="JSS15" target="https://www.nds.rub.de/media/nds/veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf">
  <front>
    <title>On the Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1 v1.5 Encryption</title>
    <author initials="T." surname="Jager">
      <organization></organization>
    </author>
    <author initials="J." surname="Schwenk">
      <organization></organization>
    </author>
    <author initials="J." surname="Somorovsky">
      <organization></organization>
    </author>
    <date year="2015"/>
  </front>
  <seriesInfo name="Proceedings of ACM CCS 2015" value=""/>
</reference>
<reference anchor="Anon18" >
  <front>
    <title>Secure Channels for Multiplexed Data Streams: Analyzing the TLS 1.3 Record Layer Without Elision</title>
    <author initials="A." surname="Anonymous">
      <organization></organization>
    </author>
    <date year="2018"/>
  </front>
  <seriesInfo name="In submission to CRYPTO 2018. RFC EDITOR: PLEASE UPDATE THIS REFERENCE AFTER FINAL NOTIFICATION (2018-4-29)." value=""/>
</reference>




<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC7924" target='https://www.rfc-editor.org/info/rfc7924'>
<front>
<title>Transport Layer Security (TLS) Cached Information Extension</title>
<author initials='S.' surname='Santesson' fullname='S. Santesson'><organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'><organization /></author>
<date year='2016' month='July' />
<abstract><t>Transport Layer Security (TLS) handshakes often include fairly static information, such as the server certificate and a list of trusted certification authorities (CAs).  This information can be of considerable size, particularly if the server certificate is bundled with a complete certificate chain (i.e., the certificates of intermediate CAs up to the root CA).</t><t>This document defines an extension that allows a TLS client to inform a server of cached information, thereby enabling the server to omit already available information.</t></abstract>
</front>
<seriesInfo name='RFC' value='7924'/>
<seriesInfo name='DOI' value='10.17487/RFC7924'/>
</reference>



<reference  anchor="RFC6347" target='https://www.rfc-editor.org/info/rfc6347'>
<front>
<title>Datagram Transport Layer Security Version 1.2</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='N.' surname='Modadugu' fullname='N. Modadugu'><organization /></author>
<date year='2012' month='January' />
<abstract><t>This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6347'/>
<seriesInfo name='DOI' value='10.17487/RFC6347'/>
</reference>

<reference anchor="KEYAGREEMENT" >
  <front>
    <title>Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography</title>
    <author initials="E." surname="Barker" fullname="Elaine Barker">
      <organization></organization>
    </author>
    <author initials="L." surname="Chen" fullname="Lily Chen">
      <organization></organization>
    </author>
    <author initials="A." surname="Roginsky" fullname="Allen Roginsky">
      <organization></organization>
    </author>
    <author initials="M." surname="Smid" fullname="Miles Smid">
      <organization></organization>
    </author>
    <date year="2013" month="May"/>
  </front>
  <seriesInfo name="National Institute of Standards and Technology" value="report"/>
  <seriesInfo name="DOI" value="10.6028/nist.sp.800-56ar2"/>
</reference>



<reference anchor="I-D.ietf-tls-iana-registry-updates">
<front>
<title>IANA Registry Updates for TLS and DTLS</title>

<author initials='J' surname='Salowey' fullname='Joseph Salowey'>
    <organization />
</author>

<author initials='S' surname='Turner' fullname='Sean Turner'>
    <organization />
</author>

<date month='February' day='15' year='2018' />

<abstract><t>This document describes a number of changes to (D)TLS IANA registries that range from adding notes to the registry all the way to changing the registration policy.  These changes were mostly motivated by WG review of the (D)TLS-related registries undertaken as part of the TLS1.3 development process.  This document updates many (D)TLS RFCs (see updates header).</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-tls-iana-registry-updates-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-tls-iana-registry-updates-04.txt' />
</reference>



<reference anchor="I-D.ietf-tls-tls13-vectors">
<front>
<title>Example Handshake Traces for TLS 1.3</title>

<author initials='M' surname='Thomson' fullname='Martin Thomson'>
    <organization />
</author>

<date month='December' day='4' year='2017' />

<abstract><t>Examples of TLS 1.3 handshakes are shown.  Private keys and inputs are provided so that these handshakes might be reproduced. Intermediate values, including secrets, traffic keys and ivs are shown so that implementations might be checked incrementally against these values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-tls-tls13-vectors-03' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-tls-tls13-vectors-03.txt' />
</reference>

<reference anchor="CHECKOWAY" >
  <front>
    <title>A Systematic Analysis of the Juniper Dual EC Incident</title>
    <author initials="S." surname="Checkoway" fullname="Stephen Checkoway">
      <organization></organization>
    </author>
    <author initials="H." surname="Shacham" fullname="Hovav Shacham">
      <organization></organization>
    </author>
    <author initials="J." surname="Maskiewicz" fullname="Jacob Maskiewicz">
      <organization></organization>
    </author>
    <author initials="C." surname="Garman" fullname="Christina Garman">
      <organization></organization>
    </author>
    <author initials="J." surname="Fried" fullname="Joshua Fried">
      <organization></organization>
    </author>
    <author initials="S." surname="Cohney" fullname="Shaanan Cohney">
      <organization></organization>
    </author>
    <author initials="M." surname="Green" fullname="Matthew Green">
      <organization></organization>
    </author>
    <author initials="N." surname="Heninger" fullname="Nadia Heninger">
      <organization></organization>
    </author>
    <author initials="R." surname="Weinmann" fullname="Ralf-Philipp Weinmann">
      <organization></organization>
    </author>
    <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security -" value="CCS'16"/>
  <seriesInfo name="DOI" value="10.1145/2976749.2978395"/>
</reference>

<reference anchor="CLINIC" >
  <front>
    <title>I Know Why You Went to the Clinic: Risks and Realization of HTTPS Traffic Analysis</title>
    <author initials="B." surname="Miller" fullname="Brad Miller">
      <organization></organization>
    </author>
    <author initials="L." surname="Huang" fullname="Ling Huang">
      <organization></organization>
    </author>
    <author initials="A." surname="Joseph" fullname="A. D. Joseph">
      <organization></organization>
    </author>
    <author initials="J." surname="Tygar" fullname="J. D. Tygar">
      <organization></organization>
    </author>
    <date year="2014"/>
  </front>
  <seriesInfo name="Privacy Enhancing Technologies" value="pp. 143-163"/>
  <seriesInfo name="DOI" value="10.1007/978-3-319-08506-7_8"/>
</reference>

<reference anchor="HCJ16" >
  <front>
    <title>HTTPS traffic analysis and client identification using passive SSL/TLS fingerprinting</title>
    <author initials="M." surname="Husák" fullname="Martin Husák">
      <organization></organization>
    </author>
    <author initials="M." surname="Čermák" fullname="Milan Čermák">
      <organization></organization>
    </author>
    <author initials="T." surname="Jirsík" fullname="Tomáš Jirsík">
      <organization></organization>
    </author>
    <author initials="P." surname="Čeleda" fullname="Pavel Čeleda">
      <organization></organization>
    </author>
    <date year="2016" month="February"/>
  </front>
  <seriesInfo name="EURASIP Journal on Information Security" value="Vol. 2016"/>
  <seriesInfo name="DOI" value="10.1186/s13635-016-0030-7"/>
</reference>




    </references>


<section anchor="state-machine" title="State Machine">

<t>This section provides a summary of the legal state transitions for the
client and server handshakes.  State names (in all capitals, e.g.,
START) have no formal meaning but are provided for ease of
comprehension.  Actions which are taken only in certain circumstances are
indicated in []. The notation “K_{send,recv} = foo” means “set the send/recv
key to the given key”.</t>

<section anchor="client" title="Client">

<figure><artwork><![CDATA[
                           START <----+
            Send ClientHello |        | Recv HelloRetryRequest
       [K_send = early data] |        |
                             v        |
        /                 WAIT_SH ----+
        |                    | Recv ServerHello
        |                    | K_recv = handshake
    Can |                    V
   send |                 WAIT_EE
  early |                    | Recv EncryptedExtensions
   data |           +--------+--------+
        |     Using |                 | Using certificate
        |       PSK |                 v
        |           |            WAIT_CERT_CR
        |           |        Recv |       | Recv CertificateRequest
        |           | Certificate |       v
        |           |             |    WAIT_CERT
        |           |             |       | Recv Certificate
        |           |             v       v
        |           |              WAIT_CV
        |           |                 | Recv CertificateVerify
        |           +> WAIT_FINISHED <+
        |                  | Recv Finished
        \                  | [Send EndOfEarlyData]
                           | K_send = handshake
                           | [Send Certificate [+ CertificateVerify]]
 Can send                  | Send Finished
 app data   -->            | K_send = K_recv = application
 after here                v
                       CONNECTED
]]></artwork></figure>

<t>Note that with the transitions as shown above, clients may send alerts
that derive from post-ServerHello messages in the clear or with the
early data keys. If clients need to send such alerts, they SHOULD
first rekey to the handshake keys if possible.</t>

</section>
<section anchor="server" title="Server">

<figure><artwork><![CDATA[
                             START <-----+
              Recv ClientHello |         | Send HelloRetryRequest
                               v         |
                            RECVD_CH ----+
                               | Select parameters
                               v
                            NEGOTIATED
                               | Send ServerHello
                               | K_send = handshake
                               | Send EncryptedExtensions
                               | [Send CertificateRequest]
Can send                       | [Send Certificate + CertificateVerify]
app data                       | Send Finished
after   -->                    | K_send = application
here                  +--------+--------+
             No 0-RTT |                 | 0-RTT
                      |                 |
  K_recv = handshake  |                 | K_recv = early data
[Skip decrypt errors] |    +------> WAIT_EOED -+
                      |    |       Recv |      | Recv EndOfEarlyData
                      |    | early data |      | K_recv = handshake
                      |    +------------+      |
                      |                        |
                      +> WAIT_FLIGHT2 <--------+
                               |
                      +--------+--------+
              No auth |                 | Client auth
                      |                 |
                      |                 v
                      |             WAIT_CERT
                      |        Recv |       | Recv Certificate
                      |       empty |       v
                      | Certificate |    WAIT_CV
                      |             |       | Recv
                      |             v       | CertificateVerify
                      +-> WAIT_FINISHED <---+
                               | Recv Finished
                               | K_recv = application
                               v
                           CONNECTED
]]></artwork></figure>

</section>
</section>
<section anchor="protocol-data-structures-and-constant-values" title="Protocol Data Structures and Constant Values">

<t>This section provides the normative protocol types and constants definitions.  Values listed as
_RESERVED were used in previous versions of TLS and are listed here
for completeness. TLS 1.3 implementations MUST NOT send them but
might receive them from older TLS implementations.</t>

<section anchor="record-layer-1" title="Record Layer">

<figure><artwork><![CDATA[
   enum {
       invalid(0),
       change_cipher_spec(20),
       alert(21),
       handshake(22),
       application_data(23),
       (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion legacy_record_version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;

   struct {
       opaque content[TLSPlaintext.length];
       ContentType type;
       uint8 zeros[length_of_padding];
   } TLSInnerPlaintext;

   struct {
       ContentType opaque_type = application_data; /* 23 */
       ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
       uint16 length;
       opaque encrypted_record[TLSCiphertext.length];
   } TLSCiphertext;
]]></artwork></figure>

</section>
<section anchor="alert-messages" title="Alert Messages">

<figure><artwork><![CDATA[
   enum { warning(1), fatal(2), (255) } AlertLevel;

   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       decryption_failed_RESERVED(21),
       record_overflow(22),
       decompression_failure_RESERVED(30),
       handshake_failure(40),
       no_certificate_RESERVED(41),
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       export_restriction_RESERVED(60),
       protocol_version(70),
       insufficient_security(71),
       internal_error(80),
       inappropriate_fallback(86),
       user_canceled(90),
       no_renegotiation_RESERVED(100),
       missing_extension(109),
       unsupported_extension(110),
       certificate_unobtainable_RESERVED(111),
       unrecognized_name(112),
       bad_certificate_status_response(113),
       bad_certificate_hash_value_RESERVED(114),
       unknown_psk_identity(115),
       certificate_required(116),
       no_application_protocol(120),
       (255)
   } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;
]]></artwork></figure>

</section>
<section anchor="handshake-protocol-1" title="Handshake Protocol">

<figure><artwork><![CDATA[
   enum {
       hello_request_RESERVED(0),
       client_hello(1),
       server_hello(2),
       hello_verify_request_RESERVED(3),
       new_session_ticket(4),
       end_of_early_data(5),
       hello_retry_request_RESERVED(6),
       encrypted_extensions(8),
       certificate(11),
       server_key_exchange_RESERVED(12),
       certificate_request(13),
       server_hello_done_RESERVED(14),
       certificate_verify(15),
       client_key_exchange_RESERVED(16),
       finished(20),
       key_update(24),
       message_hash(254),
       (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;    /* handshake type */
       uint24 length;             /* bytes in message */
       select (Handshake.msg_type) {
           case client_hello:          ClientHello;
           case server_hello:          ServerHello;
           case end_of_early_data:     EndOfEarlyData;
           case encrypted_extensions:  EncryptedExtensions;
           case certificate_request:   CertificateRequest;
           case certificate:           Certificate;
           case certificate_verify:    CertificateVerify;
           case finished:              Finished;
           case new_session_ticket:    NewSessionTicket;
           case key_update:            KeyUpdate;
       };
   } Handshake;
]]></artwork></figure>

<section anchor="key-exchange-messages-1" title="Key Exchange Messages">

<figure><artwork><![CDATA[
   uint16 ProtocolVersion;
   opaque Random[32];

   uint8 CipherSuite[2];    /* Cryptographic suite selector */

   struct {
       ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
       Random random;
       opaque legacy_session_id<0..32>;
       CipherSuite cipher_suites<2..2^16-2>;
       opaque legacy_compression_methods<1..2^8-1>;
       Extension extensions<8..2^16-1>;
   } ClientHello;

   struct {
       ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
       Random random;
       opaque legacy_session_id_echo<0..32>;
       CipherSuite cipher_suite;
       uint8 legacy_compression_method = 0;
       Extension extensions<6..2^16-1>;
   } ServerHello;

   struct {
       ExtensionType extension_type;
       opaque extension_data<0..2^16-1>;
   } Extension;

   enum {
       server_name(0),                             /* RFC 6066 */
       max_fragment_length(1),                     /* RFC 6066 */
       status_request(5),                          /* RFC 6066 */
       supported_groups(10),                       /* RFC 4492, 7919 */
       signature_algorithms(13),                   /* [[this document]] */
       use_srtp(14),                               /* RFC 5764 */
       heartbeat(15),                              /* RFC 6520 */
       application_layer_protocol_negotiation(16), /* RFC 7301 */
       signed_certificate_timestamp(18),           /* RFC 6962 */
       client_certificate_type(19),                /* RFC 7250 */
       server_certificate_type(20),                /* RFC 7250 */
       padding(21),                                /* RFC 7685 */
       RESERVED(40),                               /* Used but never assigned */
       pre_shared_key(41),                         /* [[this document]] */
       early_data(42),                             /* [[this document]] */
       supported_versions(43),                     /* [[this document]] */
       cookie(44),                                 /* [[this document]] */
       psk_key_exchange_modes(45),                 /* [[this document]] */
       RESERVED(46),                               /* Used but never assigned */
       certificate_authorities(47),                /* [[this document]] */
       oid_filters(48),                            /* [[this document]] */
       post_handshake_auth(49),                    /* [[this document]] */
       signature_algorithms_cert(50),              /* [[this document]] */
       key_share(51),                              /* [[this document]] */
       (65535)
   } ExtensionType;

   struct {
       NamedGroup group;
       opaque key_exchange<1..2^16-1>;
   } KeyShareEntry;

   struct {
       KeyShareEntry client_shares<0..2^16-1>;
   } KeyShareClientHello;

   struct {
       NamedGroup selected_group;
   } KeyShareHelloRetryRequest;

   struct {
       KeyShareEntry server_share;
   } KeyShareServerHello;

   struct {
       uint8 legacy_form = 4;
       opaque X[coordinate_length];
       opaque Y[coordinate_length];
   } UncompressedPointRepresentation;

   enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

   struct {
       PskKeyExchangeMode ke_modes<1..255>;
   } PskKeyExchangeModes;

   struct {} Empty;

   struct {
       select (Handshake.msg_type) {
           case new_session_ticket:   uint32 max_early_data_size;
           case client_hello:         Empty;
           case encrypted_extensions: Empty;
       };
   } EarlyDataIndication;

   struct {
       opaque identity<1..2^16-1>;
       uint32 obfuscated_ticket_age;
   } PskIdentity;

   opaque PskBinderEntry<32..255>;

   struct {
       PskIdentity identities<7..2^16-1>;
       PskBinderEntry binders<33..2^16-1>;
   } OfferedPsks;

   struct {
       select (Handshake.msg_type) {
           case client_hello: OfferedPsks;
           case server_hello: uint16 selected_identity;
       };
   } PreSharedKeyExtension;
]]></artwork></figure>

<section anchor="version-extension" title="Version Extension">

<figure><artwork><![CDATA[
   struct {
       select (Handshake.msg_type) {
           case client_hello:
                ProtocolVersion versions<2..254>;

           case server_hello: /* and HelloRetryRequest */
                ProtocolVersion selected_version;
       };
   } SupportedVersions;
]]></artwork></figure>

</section>
<section anchor="cookie-extension" title="Cookie Extension">

<figure><artwork><![CDATA[
   struct {
       opaque cookie<1..2^16-1>;
   } Cookie;
]]></artwork></figure>

</section>
<section anchor="signature-algorithm-extension" title="Signature Algorithm Extension">

<figure><artwork><![CDATA[
   enum {
       /* RSASSA-PKCS1-v1_5 algorithms */
       rsa_pkcs1_sha256(0x0401),
       rsa_pkcs1_sha384(0x0501),
       rsa_pkcs1_sha512(0x0601),

       /* ECDSA algorithms */
       ecdsa_secp256r1_sha256(0x0403),
       ecdsa_secp384r1_sha384(0x0503),
       ecdsa_secp521r1_sha512(0x0603),

       /* RSASSA-PSS algorithms with public key OID rsaEncryption */
       rsa_pss_rsae_sha256(0x0804),
       rsa_pss_rsae_sha384(0x0805),
       rsa_pss_rsae_sha512(0x0806),

       /* EdDSA algorithms */
       ed25519(0x0807),
       ed448(0x0808),

       /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
       rsa_pss_pss_sha256(0x0809),
       rsa_pss_pss_sha384(0x080a),
       rsa_pss_pss_sha512(0x080b),

       /* Legacy algorithms */
       rsa_pkcs1_sha1(0x0201),
       ecdsa_sha1(0x0203),

       /* Reserved Code Points */
       obsolete_RESERVED(0x0000..0x0200),
       dsa_sha1_RESERVED(0x0202),
       obsolete_RESERVED(0x0204..0x0400),
       dsa_sha256_RESERVED(0x0402),
       obsolete_RESERVED(0x0404..0x0500),
       dsa_sha384_RESERVED(0x0502),
       obsolete_RESERVED(0x0504..0x0600),
       dsa_sha512_RESERVED(0x0602),
       obsolete_RESERVED(0x0604..0x06FF),
       private_use(0xFE00..0xFFFF),
       (0xFFFF)
   } SignatureScheme;

   struct {
       SignatureScheme supported_signature_algorithms<2..2^16-2>;
   } SignatureSchemeList;
]]></artwork></figure>

</section>
<section anchor="supported-groups-extension" title="Supported Groups Extension">

<figure><artwork><![CDATA[
   enum {
       unallocated_RESERVED(0x0000),

       /* Elliptic Curve Groups (ECDHE) */
       obsolete_RESERVED(0x0001..0x0016),
       secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
       obsolete_RESERVED(0x001A..0x001C),
       x25519(0x001D), x448(0x001E),

       /* Finite Field Groups (DHE) */
       ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
       ffdhe6144(0x0103), ffdhe8192(0x0104),

       /* Reserved Code Points */
       ffdhe_private_use(0x01FC..0x01FF),
       ecdhe_private_use(0xFE00..0xFEFF),
       obsolete_RESERVED(0xFF01..0xFF02),
       (0xFFFF)
   } NamedGroup;

   struct {
       NamedGroup named_group_list<2..2^16-1>;
   } NamedGroupList;
]]></artwork></figure>

<t>Values within “obsolete_RESERVED” ranges are used in previous versions
of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.
The obsolete curves have various known/theoretical weaknesses or have
had very little usage, in some cases only due to unintentional
server configuration issues. They are no longer considered appropriate
for general use and should be assumed to be potentially unsafe. The set
of curves specified here is sufficient for interoperability with all
currently deployed and properly configured TLS implementations.</t>

</section>
</section>
<section anchor="server-parameters-messages" title="Server Parameters Messages">

<figure><artwork><![CDATA[
   opaque DistinguishedName<1..2^16-1>;

   struct {
       DistinguishedName authorities<3..2^16-1>;
   } CertificateAuthoritiesExtension;

   struct {
       opaque certificate_extension_oid<1..2^8-1>;
       opaque certificate_extension_values<0..2^16-1>;
   } OIDFilter;

   struct {
       OIDFilter filters<0..2^16-1>;
   } OIDFilterExtension;

   struct {} PostHandshakeAuth;

   struct {
       Extension extensions<0..2^16-1>;
   } EncryptedExtensions;

   struct {
       opaque certificate_request_context<0..2^8-1>;
       Extension extensions<2..2^16-1>;
   } CertificateRequest;
]]></artwork></figure>

</section>
<section anchor="authentication-messages-1" title="Authentication Messages">

<figure><artwork><![CDATA[
   /* Managed by IANA */
   enum {
       X509(0),
       OpenPGP_RESERVED(1),
       RawPublicKey(2),
       (255)
   } CertificateType;

   struct {
       select (certificate_type) {
           case RawPublicKey:
             /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
             opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

           case X509:
             opaque cert_data<1..2^24-1>;
       };
       Extension extensions<0..2^16-1>;
   } CertificateEntry;

   struct {
       opaque certificate_request_context<0..2^8-1>;
       CertificateEntry certificate_list<0..2^24-1>;
   } Certificate;

   struct {
       SignatureScheme algorithm;
       opaque signature<0..2^16-1>;
   } CertificateVerify;

   struct {
       opaque verify_data[Hash.length];
   } Finished;
]]></artwork></figure>

</section>
<section anchor="ticket-establishment" title="Ticket Establishment">

<figure><artwork><![CDATA[
   struct {
       uint32 ticket_lifetime;
       uint32 ticket_age_add;
       opaque ticket_nonce<0..255>;
       opaque ticket<1..2^16-1>;
       Extension extensions<0..2^16-2>;
   } NewSessionTicket;
]]></artwork></figure>

</section>
<section anchor="updating-keys" title="Updating Keys">

<figure><artwork><![CDATA[
   struct {} EndOfEarlyData;

   enum {
       update_not_requested(0), update_requested(1), (255)
   } KeyUpdateRequest;

   struct {
       KeyUpdateRequest request_update;
   } KeyUpdate;
]]></artwork></figure>

</section>
</section>
<section anchor="cipher-suites" title="Cipher Suites">

<t>A symmetric cipher suite defines the pair of the AEAD algorithm and hash
algorithm to be used with HKDF.
Cipher suite names follow the naming convention:</t>

<figure><artwork><![CDATA[
   CipherSuite TLS_AEAD_HASH = VALUE;
]]></artwork></figure>

<texttable>
      <ttcol align='left'>Component</ttcol>
      <ttcol align='left'>Contents</ttcol>
      <c>TLS</c>
      <c>The string “TLS”</c>
      <c>AEAD</c>
      <c>The AEAD algorithm used for record protection</c>
      <c>HASH</c>
      <c>The hash algorithm used with HKDF</c>
      <c>VALUE</c>
      <c>The two byte ID assigned for this cipher suite</c>
</texttable>

<t>This specification defines the following cipher suites for use with TLS 1.3.</t>

<texttable>
      <ttcol align='left'>Description</ttcol>
      <ttcol align='left'>Value</ttcol>
      <c>TLS_AES_128_GCM_SHA256</c>
      <c>{0x13,0x01}</c>
      <c>TLS_AES_256_GCM_SHA384</c>
      <c>{0x13,0x02}</c>
      <c>TLS_CHACHA20_POLY1305_SHA256</c>
      <c>{0x13,0x03}</c>
      <c>TLS_AES_128_CCM_SHA256</c>
      <c>{0x13,0x04}</c>
      <c>TLS_AES_128_CCM_8_SHA256</c>
      <c>{0x13,0x05}</c>
</texttable>

<t>The corresponding AEAD algorithms AEAD_AES_128_GCM, AEAD_AES_256_GCM, and
AEAD_AES_128_CCM are defined in <xref target="RFC5116"/>. AEAD_CHACHA20_POLY1305 is defined
in <xref target="RFC7539"/>. AEAD_AES_128_CCM_8 is defined in <xref target="RFC6655"/>. The corresponding
hash algorithms are defined in <xref target="SHS"/>.</t>

<t>Although TLS 1.3 uses the same cipher suite space as previous versions
of TLS, TLS 1.3 cipher suites are defined differently, only specifying
the symmetric ciphers, and cannot be used for TLS 1.2. Similarly,
TLS 1.2 and lower cipher suites cannot be used with TLS 1.3.</t>

<t>New cipher suite values are assigned by IANA as described in
<xref target="iana-considerations"/>.</t>

</section>
</section>
<section anchor="implementation-notes" title="Implementation Notes">

<t>The TLS protocol cannot prevent many common security mistakes. This section
provides several recommendations to assist implementors.
<xref target="I-D.ietf-tls-tls13-vectors"/> provides test vectors for TLS 1.3 handshakes.</t>

<section anchor="random-number-generation-and-seeding" title="Random Number Generation and Seeding">

<t>TLS requires a cryptographically secure pseudorandom number generator (CSPRNG).
In most cases, the operating system provides an appropriate facility such
as /dev/urandom, which should be used absent other (performance) concerns.
It is RECOMMENDED to use an existing CSPRNG implementation in
preference to crafting a new one. Many adequate cryptographic libraries
are already available under favorable license terms.  Should those prove
unsatisfactory, <xref target="RFC4086"/> provides guidance on the generation of random values.</t>

<t>TLS uses random values both in public protocol fields such as the
public Random values in the ClientHello and ServerHello and to
generate keying material. With a properly functioning CSPRNG, this
does not present a security problem as it is not feasible to determine
the CSPRNG state from its output. However, with a broken CSPRNG, it
may be possible for an attacker to use the public output to determine
the CSPRNG internal state and thereby predict the keying material, as
documented in <xref target="CHECKOWAY"/>.
Implementations can provide extra security against
this form of attack by using separate CSPRNGs to generate public and
private values.</t>

</section>
<section anchor="certificates-and-authentication" title="Certificates and Authentication">

<t>Implementations are responsible for verifying the integrity of certificates and
should generally support certificate revocation messages. Absent a specific
indication from an application profile, Certificates should
always be verified to ensure proper signing by a trusted Certificate Authority
(CA). The selection and addition of trust anchors should be done very carefully.
Users should be able to view information about the certificate and trust anchor.
Applications SHOULD also enforce minimum and maximum key sizes. For example,
certification paths containing keys or signatures weaker than 2048-bit RSA or
224-bit ECDSA are not appropriate for secure applications.</t>

</section>
<section anchor="implementation-pitfalls" title="Implementation Pitfalls">

<t>Implementation experience has shown that certain parts of earlier TLS
specifications are not easy to understand and have been a source of
interoperability and security problems. Many of these areas have been clarified
in this document but this appendix contains a short list of the most important
things that require special attention from implementors.</t>

<t>TLS protocol issues:</t>

<t><list style="symbols">
  <t>Do you correctly handle handshake messages that are fragmented to
multiple TLS records (see <xref target="record-layer"/>)? Including corner cases
like a ClientHello that is split to several small fragments? Do
you fragment handshake messages that exceed the maximum fragment
size? In particular, the Certificate and CertificateRequest
handshake messages can be large enough to require fragmentation.</t>
  <t>Do you ignore the TLS record layer version number in all unencrypted TLS
records? (see <xref target="backward-compatibility"/>)</t>
  <t>Have you ensured that all support for SSL, RC4, EXPORT ciphers, and
MD5 (via the “signature_algorithms” extension) is completely removed from
all possible configurations that support TLS 1.3 or later, and that
attempts to use these obsolete capabilities fail correctly?
(see <xref target="backward-compatibility"/>)</t>
  <t>Do you handle TLS extensions in ClientHello correctly, including
unknown extensions?</t>
  <t>When the server has requested a client certificate, but no
suitable certificate is available, do you correctly send an empty
Certificate message, instead of omitting the whole message (see
<xref target="client-certificate-selection"/>)?</t>
  <t>When processing the plaintext fragment produced by AEAD-Decrypt and
scanning from the end for the ContentType, do you avoid scanning
past the start of the cleartext in the event that the peer has sent
a malformed plaintext of all-zeros?</t>
  <t>Do you properly ignore unrecognized cipher suites
(<xref target="client-hello"/>), hello extensions (<xref target="extensions"/>), named groups
(<xref target="negotiated-groups"/>), key shares (<xref target="key-share"/>),
supported versions (<xref target="supported-versions"/>),
and signature algorithms (<xref target="signature-algorithms"/>) in the
ClientHello?</t>
  <t>As a server, do you send a HelloRetryRequest to clients which
support a compatible (EC)DHE group but do not predict it in the
“key_share” extension? As a client, do you correctly handle a
HelloRetryRequest from the server?</t>
</list></t>

<t>Cryptographic details:</t>

<t><list style="symbols">
  <t>What countermeasures do you use to prevent timing attacks <xref target="TIMING"/>?</t>
  <t>When using Diffie-Hellman key exchange, do you correctly preserve
leading zero bytes in the negotiated key (see <xref target="finite-field-diffie-hellman"/>)?</t>
  <t>Does your TLS client check that the Diffie-Hellman parameters sent
by the server are acceptable, (see <xref target="ffdhe-param"/>)?</t>
  <t>Do you use a strong and, most importantly, properly seeded random number
generator (see <xref target="random-number-generation-and-seeding"/>) when generating Diffie-Hellman
private values, the ECDSA “k” parameter, and other security-critical values?
It is RECOMMENDED that implementations implement “deterministic ECDSA”
as specified in <xref target="RFC6979"/>.</t>
  <t>Do you zero-pad Diffie-Hellman public key values to the group size (see
<xref target="ffdhe-param"/>)?</t>
  <t>Do you verify signatures after making them to protect against RSA-CRT
key leaks? <xref target="FW15"/></t>
</list></t>

</section>
<section anchor="client-tracking" title="Client Tracking Prevention">

<t>Clients SHOULD NOT reuse a ticket for multiple connections. Reuse
of a ticket allows passive observers to correlate different connections.
Servers that issue tickets SHOULD offer at least as many tickets
as the number of connections that a client might use; for example, a web browser
using HTTP/1.1 <xref target="RFC7230"/> might open six connections to a server. Servers SHOULD
issue new tickets with every connection. This ensures that clients are
always able to use a new ticket when creating a new connection.</t>

</section>
<section anchor="unauthenticated-operation" title="Unauthenticated Operation">

<t>Previous versions of TLS offered explicitly unauthenticated cipher suites based
on anonymous Diffie-Hellman. These modes have been deprecated in TLS 1.3.
However, it is still possible to negotiate parameters that do not provide
verifiable server authentication by several methods, including:</t>

<t><list style="symbols">
  <t>Raw public keys <xref target="RFC7250"/>.</t>
  <t>Using a public key contained in a certificate but without
validation of the certificate chain or any of its contents.</t>
</list></t>

<t>Either technique used alone is vulnerable to man-in-the-middle attacks
and therefore unsafe for general use. However, it is also possible to
bind such connections to an external authentication mechanism via
out-of-band validation of the server’s public key, trust on first
use, or a mechanism such as channel bindings (though the
channel bindings described in <xref target="RFC5929"/> are not defined for
TLS 1.3). If no such mechanism is used, then the connection has no protection
against active man-in-the-middle attack; applications MUST NOT use TLS
in such a way absent explicit configuration or a specific application
profile.</t>

</section>
</section>
<section anchor="backward-compatibility" title="Backward Compatibility">

<t>The TLS protocol provides a built-in mechanism for version negotiation between
endpoints potentially supporting different versions of TLS.</t>

<t>TLS 1.x and SSL 3.0 use compatible ClientHello messages. Servers can also handle
clients trying to use future versions of TLS as long as the ClientHello format
remains compatible and there is at least one protocol version supported by
both the client and the server.</t>

<t>Prior versions of TLS used the record layer version number
(TLSPlaintext.legacy_record_version and
TLSCiphertext.legacy_record_version) for various purposes.
As of TLS 1.3, this field is deprecated. The value of
TLSPlaintext.legacy_record_version MUST be ignored by all implementations.
The value of TLSCiphertext.legacy_record_version is included in the
additional data for deprotection but MAY otherwise be ignored
or MAY be validated to match the fixed constant value.
Version negotiation is performed using only the handshake versions
(ClientHello.legacy_version, ServerHello.legacy_version, as well as the
ClientHello, HelloRetryRequest and ServerHello “supported_versions” extensions).
In order to maximize interoperability with older endpoints, implementations
that negotiate the use of TLS 1.0-1.2 SHOULD set the record layer
version number to the negotiated version for the ServerHello and all
records thereafter.</t>

<t>For maximum compatibility with previously non-standard behavior and misconfigured
deployments, all implementations SHOULD support validation of certification paths
based on the expectations in this document, even when handling prior TLS versions’
handshakes. (see <xref target="server-certificate-selection"/>)</t>

<t>TLS 1.2 and prior supported an “Extended Master Secret” <xref target="RFC7627"/> extension
which digested large parts of the handshake transcript into the master secret.
Because TLS 1.3 always hashes in the transcript up to the server CertificateVerify,
implementations which support both TLS 1.3 and earlier versions SHOULD
indicate the use of the Extended Master Secret extension in their APIs
whenever TLS 1.3 is used.</t>

<section anchor="negotiating-with-an-older-server" title="Negotiating with an older server">

<t>A TLS 1.3 client who wishes to negotiate with servers that do not
support TLS 1.3 will send a
normal TLS 1.3 ClientHello containing 0x0303 (TLS 1.2) in
ClientHello.legacy_version but with the correct version(s) in the
“supported_versions” extension. If the server does not support TLS 1.3 it
will respond with a ServerHello containing an older version number. If the
client agrees to use this version, the negotiation will proceed as appropriate
for the negotiated protocol. A client using a ticket for resumption SHOULD initiate the
connection using the version that was previously negotiated.</t>

<t>Note that 0-RTT data is not compatible with older servers and SHOULD NOT
be sent absent knowledge that the server supports TLS 1.3.
See <xref target="zero-rtt-backwards-compatibility"/>.</t>

<t>If the version chosen by the server is not supported by the client (or not
acceptable), the client MUST abort the handshake with a “protocol_version” alert.</t>

<t>Some legacy server implementations are known to not implement the TLS
specification properly and might abort connections upon encountering
TLS extensions or versions which they are not aware of. Interoperability
with buggy servers is a complex topic beyond the scope of this document.
Multiple connection attempts may be required in order to negotiate
a backwards compatible connection; however, this practice is vulnerable
to downgrade attacks and is NOT RECOMMENDED.</t>

</section>
<section anchor="negotiating-with-an-older-client" title="Negotiating with an older client">

<t>A TLS server can also receive a ClientHello indicating a version number smaller
than its highest supported version. If the “supported_versions” extension
is present, the server MUST negotiate using that extension as described in
<xref target="supported-versions"/>. If the “supported_versions” extension is not
present, the server MUST negotiate the minimum of ClientHello.legacy_version
and TLS 1.2. For example, if the server supports TLS 1.0, 1.1, and 1.2,
and legacy_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello.
If the “supported_versions” extension is absent and the server only supports
versions greater than ClientHello.legacy_version, the server MUST abort the handshake
with a “protocol_version” alert.</t>

<t>Note that earlier versions of TLS did not clearly specify the record layer
version number value in all cases (TLSPlaintext.legacy_record_version). Servers
will receive various TLS 1.x versions in this field, but its value
MUST always be ignored.</t>

</section>
<section anchor="zero-rtt-backwards-compatibility" title="0-RTT backwards compatibility">

<t>0-RTT data is not compatible with older servers. An older server will respond
to the ClientHello with an older ServerHello, but it will not correctly skip
the 0-RTT data and will fail to complete the handshake. This can cause issues when
a client attempts to use 0-RTT, particularly against multi-server deployments. For
example, a deployment could deploy TLS 1.3 gradually with some servers
implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3 deployment
could be downgraded to TLS 1.2.</t>

<t>A client that attempts to send 0-RTT data MUST fail a connection if it receives
a ServerHello with TLS 1.2 or older.  A client that attempts to repair this
error SHOULD NOT send a TLS 1.2 ClientHello, but instead send a TLS 1.3
ClientHello without 0-RTT data.</t>

<t>To avoid this error condition, multi-server deployments SHOULD ensure a uniform
and stable deployment of TLS 1.3 without 0-RTT prior to enabling 0-RTT.</t>

</section>
<section anchor="middlebox" title="Middlebox Compatibility Mode">

<t>Field measurements
<xref target="Ben17a"/>, <xref target="Ben17b"/>, <xref target="Res17a"/>, <xref target="Res17b"/> have found that a significant number of middleboxes
misbehave when a TLS client/server pair negotiates TLS 1.3. Implementations
can increase the chance of making connections through those middleboxes
by making the TLS 1.3 handshake look more like a TLS 1.2 handshake:</t>

<t><list style="symbols">
  <t>The client always provides a non-empty session ID in the ClientHello,
as described in the legacy_session_id section of <xref target="client-hello"/>.</t>
  <t>If not offering early data, the client sends a dummy
change_cipher_spec record (see the third paragraph of <xref target="record-layer"/>)
immediately before its second flight. This
may either be before its second ClientHello or before its encrypted
handshake flight. If offering early data, the record is placed
immediately after the first ClientHello.</t>
  <t>The server sends a dummy change_cipher_spec record immediately
after its first handshake message. This may either be after a
ServerHello or a HelloRetryRequest.</t>
</list></t>

<t>When put together, these changes make the TLS 1.3 handshake resemble
TLS 1.2 session resumption, which improves the chance of successfully
connecting through middleboxes. This “compatibility mode” is partially
negotiated: The client can opt to provide a session ID or not
and the server has to echo it. Either side can send change_cipher_spec
at any time during the handshake, as they must be ignored by the peer,
but if the client sends a non-empty session ID, the server MUST send
the change_cipher_spec as described in this section.</t>

</section>
<section anchor="backwards-compatibility-security-restrictions" title="Backwards Compatibility Security Restrictions">

<t>Implementations negotiating use of older versions of TLS SHOULD prefer
forward secret and AEAD cipher suites, when available.</t>

<t>The security of RC4 cipher suites is considered insufficient for the reasons
cited in <xref target="RFC7465"/>. Implementations MUST NOT offer or negotiate RC4 cipher suites
for any version of TLS for any reason.</t>

<t>Old versions of TLS permitted the use of very low strength ciphers.
Ciphers with a strength less than 112 bits MUST NOT be offered or
negotiated for any version of TLS for any reason.</t>

<t>The security of SSL 3.0 <xref target="SSL3"/> is considered insufficient for the reasons enumerated
in <xref target="RFC7568"/>, and it MUST NOT be negotiated for any reason.</t>

<t>The security of SSL 2.0 <xref target="SSL2"/> is considered insufficient for the reasons enumerated
in <xref target="RFC6176"/>, and it MUST NOT be negotiated for any reason.</t>

<t>Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO.
Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible
CLIENT-HELLO. Implementations are NOT RECOMMENDED to accept an SSL version 2.0 compatible
CLIENT-HELLO in order to negotiate older versions of TLS.</t>

<t>Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version
set to 0x0300 or less. Any endpoint receiving a Hello message with
ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST
abort the handshake with a “protocol_version” alert.</t>

<t>Implementations MUST NOT send any records with a version less than 0x0300.
Implementations SHOULD NOT accept any records with a version less than 0x0300
(but may inadvertently do so if the record version number is ignored completely).</t>

<t>Implementations MUST NOT use the Truncated HMAC extension, defined in
Section 7 of <xref target="RFC6066"></xref>, as it is not applicable to AEAD algorithms and has
been shown to be insecure in some scenarios.</t>

</section>
</section>
<section anchor="security-analysis" title="Overview of Security Properties">

<t>A complete security analysis of TLS is outside the scope of this document.
In this section, we provide an informal description the desired properties
as well as references to more detailed work in the research literature
which provides more formal definitions.</t>

<t>We cover properties of the handshake separately from those of the record layer.</t>

<section anchor="security-handshake" title="Handshake">

<t>The TLS handshake is an Authenticated Key Exchange (AKE) protocol which
is intended to provide both one-way authenticated (server-only) and
mutually authenticated (client and server) functionality. At the completion
of the handshake, each side outputs its view of the following values:</t>

<t><list style="symbols">
  <t>A set of “session keys” (the various secrets derived from the master secret)
from which can be derived a set of working keys.</t>
  <t>A set of cryptographic parameters (algorithms, etc.)</t>
  <t>The identities of the communicating parties.</t>
</list></t>

<t>We assume the attacker to be an active network attacker, which means it
has complete control over the network used to communicate between the parties <xref target="RFC3552"/>.
Even under these conditions, the handshake should provide the properties listed below.
Note that these properties are not necessarily independent, but reflect
the protocol consumers’ needs.</t>

<t><list style="hanging">
  <t hangText='Establishing the same session keys.'>
  The handshake needs to output the same set of session keys on both sides of
the handshake, provided that it completes successfully on each endpoint
(See <xref target="CK01"/>; defn 1, part 1).</t>
  <t hangText='Secrecy of the session keys.'>
  The shared session keys should be known only to the communicating
parties and not to the attacker (See <xref target="CK01"/>; defn 1, part 2).
Note that in a unilaterally authenticated connection, the attacker can establish
its own session keys with the server, but those session keys are distinct from
those established by the client.</t>
  <t hangText='Peer Authentication.'>
  The client’s view of the peer identity should reflect the server’s
identity. If the client is authenticated, the server’s view of the
peer identity should match the client’s identity.</t>
  <t hangText='Uniqueness of the session keys:'>
  Any two distinct handshakes should produce distinct, unrelated session
keys. Individual session keys produced by a handshake should also be distinct
and independent.</t>
  <t hangText='Downgrade protection.'>
  The cryptographic parameters should be the same on both sides and
should be the same as if the peers had been communicating in the
absence of an attack (See <xref target="BBFKZG16"/>; defns 8 and 9}).</t>
  <t hangText='Forward secret with respect to long-term keys'>
  If the long-term keying material (in this case the signature keys in certificate-based
authentication modes or the external/resumption PSK in PSK with (EC)DHE modes) is compromised after
the handshake is complete, this does not compromise the security of the
session key (See <xref target="DOW92"/>), as long as the session key itself has
been erased. The forward secrecy property is not satisfied
when PSK is used in the “psk_ke” PskKeyExchangeMode.</t>
  <t hangText='Key Compromise Impersonation (KCI) resistance'>
  In a mutually-authenticated connection with certificates, compromising the long-term
secret of one actor should not break that actor’s authentication of their peer in
the given connection (see <xref target="HGFS15"/>). For example, if a client’s signature key is
compromised, it should not be possible to impersonate arbitrary servers to that client
in subsequent handshakes.</t>
  <t hangText='Protection of endpoint identities.'>
  The server’s identity (certificate) should be protected against passive
attackers. The client’s identity should be protected against both passive
and active attackers.</t>
</list></t>

<t>Informally, the signature-based modes of TLS 1.3 provide for the
establishment of a unique, secret, shared key established by an
(EC)DHE key exchange and authenticated by the server’s signature over
the handshake transcript, as well as tied to the server’s identity by
a MAC. If the client is authenticated by a certificate, it also signs
over the handshake transcript and provides a MAC tied to both
identities. <xref target="SIGMA"/> describes the design and analysis of this type of key
exchange protocol. If fresh (EC)DHE keys are used for each connection,
then the output keys are forward secret.</t>

<t>The external PSK and resumption PSK bootstrap from a long-term shared
secret into a unique per-connection set of short-term session keys. This
secret may have been established in a previous handshake. If
PSK with (EC)DHE key establishment is used, these session keys will also be forward
secret. The resumption PSK has been designed so that the
resumption master secret computed by connection N and needed to form
connection N+1 is separate from the traffic keys used by connection N,
thus providing forward secrecy between the connections.
In addition, if multiple tickets are established on the same
connection, they are associated with different keys, so compromise of
the PSK associated with one ticket does not lead to the compromise of
connections established with PSKs associated with other tickets.
This property is most interesting if tickets are stored in a database
(and so can be deleted) rather than if they are self-encrypted.</t>

<t>The PSK binder value forms a binding between a PSK
and the current handshake, as well as between the session where the
PSK was established and the current session. This binding
transitively includes the original handshake transcript, because that
transcript is digested into the values which produce the Resumption
Master Secret. This requires that both the KDF used to produce the
resumption master secret and the MAC used to compute the binder be collision
resistant. See <xref target="key-derivation-and-hkdf"/> for more on this.
Note: The binder does not cover the binder values from other
PSKs, though they are included in the Finished MAC.</t>

<t>Note: TLS does not currently permit the server to send a certificate_request
message in non-certificate-based handshakes (e.g., PSK).
If this restriction were to be relaxed in future, the
client’s signature would not cover the server’s certificate directly.
However, if the PSK was established through a NewSessionTicket, the client’s
signature would transitively cover the server’s certificate through
the PSK binder. <xref target="PSK-FINISHED"/>
describes a concrete attack on constructions that do not bind to
the server’s certificate (see also <xref target="Kraw16"/>). It is unsafe to use certificate-based client
authentication when the client might potentially share the same
PSK/key-id pair with two different endpoints.  Implementations MUST NOT combine
external PSKs with certificate-based authentication of either the
client or the server unless negotiated by some extension.</t>

<t>If an exporter is used, then it produces values which are unique
and secret (because they are generated from a unique session key).
Exporters computed with different labels and contexts are computationally
independent, so it is not feasible to compute one from another or
the session secret from the exported value. Note: exporters can
produce arbitrary-length values. If exporters are to be
used as channel bindings, the exported value MUST be large
enough to provide collision resistance. The exporters provided in
TLS 1.3 are derived from the same handshake contexts as the
early traffic keys and the application traffic keys respectively,
and thus have similar security properties. Note that they do
not include the client’s certificate; future applications
which wish to bind to the client’s certificate may need
to define a new exporter that includes the full handshake
transcript.</t>

<t>For all handshake modes, the Finished MAC (and where present, the
signature), prevents downgrade attacks. In addition, the use of
certain bytes in the random nonces as described in <xref target="server-hello"/>
allows the detection of downgrade to previous TLS versions.
See <xref target="BBFKZG16"/> for more detail on TLS 1.3 and downgrade.</t>

<t>As soon as the client and the server have exchanged enough information
to establish shared keys, the remainder of the handshake is encrypted,
thus providing protection against passive attackers, even if the
computed shared key is not authenticated. Because the server
authenticates before the client, the client can ensure that if it
authenticates to the server, it only
reveals its identity to an authenticated server. Note that implementations
must use the provided record padding mechanism during the handshake
to avoid leaking information about the identities due to length.
The client’s proposed PSK identities are not encrypted, nor is the
one that the server selects.</t>

<section anchor="key-derivation-and-hkdf" title="Key Derivation and HKDF">

<t>Key derivation in TLS 1.3 uses the HKDF function defined in <xref target="RFC5869"/> and
its two components, HKDF-Extract and HKDF-Expand. The full rationale for the HKDF
construction can be found in <xref target="Kraw10"></xref> and the rationale for the way it is used
in TLS 1.3 in <xref target="KW16"></xref>.  Throughout this document, each
application of HKDF-Extract is followed by one or more invocations of
HKDF-Expand. This ordering should always be followed (including in future
revisions of this document), in particular, one SHOULD NOT use an output of
HKDF-Extract as an input to another application of HKDF-Extract without an
HKDF-Expand in between. Consecutive applications of HKDF-Expand are allowed as
long as these are differentiated via the key and/or the labels.</t>

<t>Note that HKDF-Expand implements a pseudorandom function (PRF) with both inputs and
outputs of variable length. In some of the uses of HKDF in this document
(e.g., for generating exporters and the resumption_master_secret), it is necessary
that the application of HKDF-Expand be collision-resistant, namely, it should
be infeasible to find two different inputs to HKDF-Expand that output the same
value. This requires the underlying hash function to be collision resistant
and the output length from HKDF-Expand to be of size at least 256 bits (or as
much as needed for the hash function to prevent finding collisions).</t>

</section>
<section anchor="client-authentication" title="Client Authentication">

<t>A client that has sent authentication data to a server, either during
the handshake or in post-handshake authentication, cannot be sure if
the server afterwards considers the client to be authenticated or not.
If the client needs to determine if the server considers the
connection to be unilaterally or mutually authenticated, this has to
be provisioned by the application layer. See <xref target="CHHSV17"/> for details.
In addition, the analysis of post-handshake authentication from
<xref target="Kraw16"></xref> shows that the client identified by the certificate sent in
the post-handshake phase possesses the traffic key. This party is
therefore the client that participated in the original handshake or
one to whom the original client delegated the traffic key (assuming
that the traffic key has not been compromised).</t>

</section>
<section anchor="rtt" title="0-RTT">

<t>The 0-RTT mode of operation generally provides similar security
properties as 1-RTT data, with the two exceptions that the 0-RTT
encryption keys do not provide full forward secrecy and that the
server is not able to guarantee uniqueness of the handshake
(non-replayability) without keeping potentially undue amounts of
state. See <xref target="anti-replay"/> for mechanisms to limit
the exposure to replay.</t>

</section>
<section anchor="exporter-independence" title="Exporter Independence">

<t>The exporter_master_secret and early_exporter_master_secret are
derived to be independent of the traffic keys and therefore do
not represent a threat to the security of traffic encrypted with
those keys. However, because these secrets can be used to
compute any exporter value, they SHOULD be erased as soon as
possible. If the total set of exporter labels is known, then
implementations SHOULD pre-compute the inner Derive-Secret
stage of the exporter computation for all those labels,
then erase the [early_]exporter_master_secret, followed by
each inner values as soon as it is known that it will not be
needed again.</t>

</section>
<section anchor="post-compromise-security" title="Post-Compromise Security">

<t>TLS does not provide security for handshakes which take place after the peer’s
long-term secret (signature key or external PSK) is compromised. It therefore
does not provide post-compromise security <xref target="CCG16"/>, sometimes also referred to
as backwards or future secrecy. This is in contrast to KCI resistance, which
describes the security guarantees that a party has after its own long-term
secret has been compromised.</t>

</section>
<section anchor="external-references" title="External References">

<t>The reader should refer to the following references for analysis of the
TLS handshake: <xref target="DFGS15"/> <xref target="CHSV16"/> <xref target="DFGS16"/> <xref target="KW16"/> <xref target="Kraw16"/> <xref target="FGSW16"/>
<xref target="LXZFH16"/> <xref target="FG17"/> <xref target="BBK17"/>.</t>

</section>
</section>
<section anchor="security-record-layer" title="Record Layer">

<t>The record layer depends on the handshake producing strong traffic secrets
which can be used to derive bidirectional encryption keys and nonces.
Assuming that is true, and the keys are used for no more data than
indicated in <xref target="limits-on-key-usage"/> then the record layer should provide the following
guarantees:</t>

<t><list style="hanging">
  <t hangText='Confidentiality.'>
  An attacker should not be able to determine the plaintext contents
of a given record.
  </t>
  <t hangText='Integrity.'>
  An attacker should not be able to craft a new record which is
different from an existing record which will be accepted by the receiver.
  </t>
  <t hangText='Order protection/non-replayability'>
  An attacker should not be able to cause the receiver to accept a
record which it has already accepted or cause the receiver to accept
record N+1 without having first processed record N.</t>
  <t hangText='Length concealment.'>
  Given a record with a given external length, the attacker should not be able
to determine the amount of the record that is content versus padding.</t>
  <t hangText='Forward secrecy after key change.'>
  If the traffic key update mechanism described in <xref target="key-update"/> has been
used and the previous generation key is deleted, an attacker who compromises
the endpoint should not be able to decrypt traffic encrypted with the old key.</t>
</list></t>

<t>Informally, TLS 1.3 provides these properties by AEAD-protecting the
plaintext with a strong key. AEAD encryption <xref target="RFC5116"/> provides confidentiality
and integrity for the data. Non-replayability is provided by using
a separate nonce for each record, with the nonce being derived from
the record sequence number (<xref target="nonce"/>), with the sequence
number being maintained independently at both sides thus records which
are delivered out of order result in AEAD deprotection failures.
In order to prevent mass cryptanalysis when the same plaintext is
repeatedly encrypted by different users under the same key
(as is commonly the case for HTTP), the nonce is formed by mixing
the sequence number with a secret per-connection initialization
vector derived along with the traffic keys.
See <xref target="BT16"/> for analysis of this construction.</t>

<t>The re-keying technique in TLS 1.3 (see <xref target="updating-traffic-keys"/>) follows the
construction of the serial generator in <xref target="REKEY"></xref>, which shows that re-keying can
allow keys to be used for a larger number of encryptions than without
re-keying. This relies on the security of the HKDF-Expand-Label function as a
pseudorandom function (PRF).  In addition, as long as this function is truly
one way, it is not possible to compute traffic keys from prior to a key change
(forward secrecy).</t>

<t>TLS does not provide security for data which is communicated on a connection
after a traffic secret of that connection is compromised. That is, TLS does not
provide post-compromise security/future secrecy/backward secrecy with respect
to the traffic secret. Indeed, an attacker who learns a traffic secret can
compute all future traffic secrets on that connection.  Systems which want such
guarantees need to do a fresh handshake and establish a new connection with an
(EC)DHE exchange.</t>

<section anchor="external-references-1" title="External References">

<t>The reader should refer to the following references for analysis of the TLS record layer:
<xref target="BMMT15"/> <xref target="BT16"/> <xref target="BDFKPPRSZZ16"/> <xref target="BBK17"/> <xref target="Anon18"/>.</t>

</section>
</section>
<section anchor="traffic-analysis" title="Traffic Analysis">

<t>TLS is susceptible to a variety of traffic analysis attacks based on
observing the length and timing of encrypted packets
<xref target="CLINIC"/>
<xref target="HCJ16"/>.
This is particularly easy when there is a small
set of possible messages to be distinguished, such as for a video
server hosting a fixed corpus of content, but still provides usable
information even in more complicated scenarios.</t>

<t>TLS does not provide any specific defenses against this form of attack
but does include a padding mechanism for use by applications: The
plaintext protected by the AEAD function consists of content plus
variable-length padding, which allows the application to produce
arbitrary length encrypted records as well as padding-only cover traffic to
conceal the difference between periods of transmission and periods
of silence. Because the
padding is encrypted alongside the actual content, an attacker cannot
directly determine the length of the padding, but may be able to
measure it indirectly by the use of timing channels exposed during
record processing (i.e., seeing how long it takes to process a
record or trickling in records to see which ones elicit a response
from the server). In general, it is not known how to remove all of
these channels because even a constant time padding removal function will
likely feed the content into data-dependent functions.
At minimum, a fully constant time server or client would require close
cooperation with the application layer protocol implementation, including
making that higher level protocol constant time.</t>

<t>Note: Robust
traffic analysis defences will likely lead to inferior performance
due to delay in transmitting packets and increased traffic volume.</t>

</section>
<section anchor="side-channel-attacks" title="Side Channel Attacks">

<t>In general, TLS does not have specific defenses against side-channel
attacks (i.e., those which attack the communications via secondary
channels such as timing) leaving those to the implementation of the relevant
cryptographic primitives. However, certain features of TLS are
designed to make it easier to write side-channel resistant code:</t>

<t><list style="symbols">
  <t>Unlike previous versions of TLS which used a composite
MAC-then-encrypt structure, TLS 1.3 only uses AEAD algorithms,
allowing implementations to use self-contained constant-time
implementations of those primitives.</t>
  <t>TLS uses a uniform “bad_record_mac” alert for all decryption
errors, which is intended to prevent an attacker from gaining
piecewise insight into portions of the message.  Additional resistance
is provided by terminating the connection on such errors; a new
connection will have different cryptographic material, preventing
attacks against the cryptographic primitives that require multiple
trials.</t>
</list></t>

<t>Information leakage through side channels can occur at layers above
TLS, in application protocols and the applications that use
them. Resistance to side-channel attacks depends on applications and
application protocols separately ensuring that confidential
information is not inadvertently leaked.</t>

</section>
<section anchor="replay-0rtt" title="Replay Attacks on 0-RTT">

<t>Replayable 0-RTT data presents a number of security threats to
TLS-using applications, unless those applications are specifically
engineered to be safe under replay
(minimally, this means idempotent, but in many cases may
also require other stronger conditions, such as constant-time
response). Potential attacks include:</t>

<t><list style="symbols">
  <t>Duplication of actions which cause side effects (e.g., purchasing an
item or transferring money) to be duplicated, thus harming the site or
the user.</t>
  <t>Attackers can store and replay 0-RTT messages in order to
re-order them with respect to other messages (e.g., moving
a delete to after a create).</t>
  <t>Exploiting cache timing behavior to discover the content of 0-RTT
messages by replaying a 0-RTT message to a different cache node
and then using a separate connection to measure request latency,
to see if the two requests address the same resource.</t>
</list></t>

<t>If data can be replayed a large number of times, additional attacks
become possible, such as making repeated measurements of the
speed of cryptographic operations. In addition, they may
be able to overload rate-limiting systems. For further description of
these attacks, see <xref target="Mac17"/>.</t>

<t>Ultimately, servers have the responsibility to protect themselves
against attacks employing 0-RTT data replication. The mechanisms
described in <xref target="anti-replay"/> are intended to
prevent replay at the TLS layer but do not provide complete protection
against receiving multiple copies of client data.
TLS 1.3 falls back to the 1-RTT
handshake when the server does not have any information about the
client, e.g., because it is in a different cluster which does not
share state or because the ticket has been deleted as described in
<xref target="single-use-tickets"/>. If the application layer protocol retransmits
data in this setting, then it is possible for an attacker to induce
message duplication by sending the ClientHello to both the original cluster
(which processes the data immediately) and another cluster which will
fall back to 1-RTT and process the data upon application layer
replay. The scale of this attack is limited by the client’s
willingness to retry transactions and therefore only allows a limited amount
of duplication, with each copy appearing as a new connection at
the server.</t>

<t>If implemented correctly, the mechanisms described in
<xref target="single-use-tickets"/> and <xref target="client-hello-recording"/> prevent a
replayed ClientHello and its associated 0-RTT data from being accepted
multiple times by any cluster with consistent state; for servers
which limit the use of 0-RTT to one cluster for a single ticket, then a given
ClientHello and its associated 0-RTT data will only be accepted once.
However, if state is not completely consistent,
then an attacker might be able to have multiple copies of the data be
accepted during the replication window.
Because clients do not know the exact details of server behavior, they
MUST NOT send messages in early data which are not safe to have
replayed and which they would not be willing to retry across multiple
1-RTT connections.</t>

<t>Application protocols MUST NOT use 0-RTT data without a profile that
defines its use. That profile needs to identify which messages or
interactions are safe to use with 0-RTT and how to handle the
situation when the server rejects 0-RTT and falls back to 1-RTT.</t>

<t>In addition, to avoid accidental misuse, TLS implementations MUST NOT
enable 0-RTT (either sending or accepting) unless specifically
requested by the application and MUST NOT automatically resend 0-RTT
data if it is rejected by the server unless instructed by the
application. Server-side applications may wish to implement special
processing for 0-RTT data for some kinds of application traffic (e.g.,
abort the connection, request that data be resent at the application
layer, or delay processing until the handshake completes). In order to
allow applications to implement this kind of processing, TLS
implementations MUST provide a way for the application to determine if
the handshake has completed.</t>

<section anchor="replay-and-exporters" title="Replay and Exporters">

<t>Replays of the ClientHello produce the same early exporter, thus
requiring additional care by applications which use these exporters.
In particular, if these exporters are used as an authentication
channel binding (e.g., by signing the output of the exporter)
an attacker who compromises the PSK can transplant authenticators
between connections without compromising the authentication key.</t>

<t>In addition, the early exporter SHOULD NOT be used to generate
server-to-client encryption keys because that would entail
the reuse of those keys. This parallels the use of the early
application traffic keys only in the client-to-server direction.</t>

</section>
</section>
<section anchor="psk-identity-exposure" title="PSK Identity Exposure">

<t>Because implementations respond to an invalid PSK binder by aborting
the handshake, it may be possible for an attacker to verify whether
a given PSK identity is valid. Specifically, if a server accepts
both external PSK and certificate-based handshakes, a valid PSK identity
will result in a failed handshake, whereas an invalid identity will
just be skipped and result in a successful certificate handshake.
Servers which solely support PSK handshakes may be able to resist
this form of attack by treating the cases where there is no
valid PSK identity and where there is an identity but it has an
invalid binder identically.</t>

</section>
<section anchor="attacks-on-static-rsa" title="Attacks on Static RSA">

<t>Although TLS 1.3 does not use RSA key transport and so is not
directly susceptible to Bleichenbacher-type attacks, if TLS 1.3
servers also support static RSA in the context of previous
versions of TLS, then it may be possible to impersonate the server
for TLS 1.3 connections <xref target="JSS15"/>. TLS
1.3 implementations can prevent this attack by disabling support
for static RSA across all versions of TLS. In principle, implementations
might also be able to separate certificates with different keyUsage
bits for static RSA decryption and RSA signature, but this technique
relies on clients refusing to accept signatures using keys
in certificates that do not have the digitalSignature bit set,
and many clients do not enforce this restriction.</t>

</section>
</section>
<section anchor="working-group-information" title="Working Group Information">

<t>The discussion list for the IETF TLS working group is located at the e-mail
address <eref target="mailto:tls@ietf.org">tls@ietf.org</eref>. Information on the group and information on how to
subscribe to the list is at <eref target="https://www.ietf.org/mailman/listinfo/tls">https://www.ietf.org/mailman/listinfo/tls</eref></t>

<t>Archives of the list can be found at:
<eref target="https://www.ietf.org/mail-archive/web/tls/current/index.html">https://www.ietf.org/mail-archive/web/tls/current/index.html</eref></t>

</section>
<section anchor="contributors" title="Contributors">

<t><list style="symbols">
  <t>Martin Abadi <vspace />
University of California, Santa Cruz <vspace />
abadi@cs.ucsc.edu</t>
  <t>Christopher Allen (co-editor of TLS 1.0) <vspace />
Alacrity Ventures <vspace />
ChristopherA@AlacrityManagement.com</t>
  <t>Richard Barnes <vspace />
Cisco <vspace />
rlb@ipv.sx</t>
  <t>Steven M. Bellovin <vspace />
Columbia University <vspace />
smb@cs.columbia.edu</t>
  <t>David Benjamin <vspace />
Google <vspace />
davidben@google.com</t>
  <t>Benjamin Beurdouche <vspace />
INRIA &amp; Microsoft Research <vspace />
benjamin.beurdouche@ens.fr</t>
  <t>Karthikeyan Bhargavan (co-author of <xref target="RFC7627"></xref>) <vspace />
INRIA <vspace />
karthikeyan.bhargavan@inria.fr</t>
  <t>Simon Blake-Wilson (co-author of <xref target="RFC4492"></xref>) <vspace />
BCI <vspace />
sblakewilson@bcisse.com</t>
  <t>Nelson Bolyard (co-author of <xref target="RFC4492"></xref>) <vspace />
Sun Microsystems, Inc. <vspace />
nelson@bolyard.com</t>
  <t>Ran Canetti <vspace />
IBM <vspace />
canetti@watson.ibm.com</t>
  <t>Matt Caswell <vspace />
OpenSSL <vspace />
matt@openssl.org</t>
  <t>Stephen Checkoway <vspace />
University of Illinois at Chicago <vspace />
sfc@uic.edu</t>
  <t>Pete Chown <vspace />
Skygate Technology Ltd <vspace />
pc@skygate.co.uk</t>
  <t>Katriel Cohn-Gordon <vspace />
University of Oxford <vspace />
me@katriel.co.uk</t>
  <t>Cas Cremers <vspace />
University of Oxford <vspace />
cas.cremers@cs.ox.ac.uk</t>
  <t>Antoine Delignat-Lavaud (co-author of <xref target="RFC7627"></xref>) <vspace />
INRIA <vspace />
antdl@microsoft.com</t>
  <t>Tim Dierks (co-editor of TLS 1.0, 1.1, and 1.2) <vspace />
Independent <vspace />
tim@dierks.org</t>
  <t>Roelof DuToit <vspace />
Symantec Corporation <vspace />
roelof_dutoit@symantec.com</t>
  <t>Taher Elgamal <vspace />
Securify <vspace />
taher@securify.com</t>
  <t>Pasi Eronen <vspace />
Nokia <vspace />
pasi.eronen@nokia.com</t>
  <t>Cedric Fournet <vspace />
Microsoft <vspace />
fournet@microsoft.com</t>
  <t>Anil Gangolli <vspace />
anil@busybuddha.org</t>
  <t>David M. Garrett <vspace />
dave@nulldereference.com</t>
  <t>Illya Gerasymchuk <vspace />
Independent <vspace />
illya@iluxonchik.me</t>
  <t>Alessandro Ghedini <vspace />
Cloudflare Inc. <vspace />
alessandro@cloudflare.com</t>
  <t>Daniel Kahn Gillmor <vspace />
ACLU <vspace />
dkg@fifthhorseman.net</t>
  <t>Matthew Green <vspace />
Johns Hopkins University <vspace />
mgreen@cs.jhu.edu</t>
  <t>Jens Guballa <vspace />
ETAS <vspace />
jens.guballa@etas.com</t>
  <t>Felix Guenther <vspace />
TU Darmstadt <vspace />
mail@felixguenther.info</t>
  <t>Vipul Gupta (co-author of <xref target="RFC4492"></xref>) <vspace />
Sun Microsystems Laboratories <vspace />
vipul.gupta@sun.com</t>
  <t>Chris Hawk (co-author of <xref target="RFC4492"></xref>) <vspace />
Corriente Networks LLC <vspace />
chris@corriente.net</t>
  <t>Kipp Hickman</t>
  <t>Alfred Hoenes</t>
  <t>David Hopwood <vspace />
Independent Consultant <vspace />
david.hopwood@blueyonder.co.uk</t>
  <t>Marko Horvat <vspace />
MPI-SWS <vspace />
mhorvat@mpi-sws.org</t>
  <t>Jonathan Hoyland <vspace />
Royal Holloway, University of London
jonathan.hoyland@gmail.com</t>
  <t>Subodh Iyengar <vspace />
Facebook <vspace />
subodh@fb.com</t>
  <t>Benjamin Kaduk <vspace />
Akamai <vspace />
kaduk@mit.edu</t>
  <t>Hubert Kario <vspace />
Red Hat Inc. <vspace />
hkario@redhat.com</t>
  <t>Phil Karlton (co-author of SSL 3.0)</t>
  <t>Leon Klingele <vspace />
Independent <vspace />
mail@leonklingele.de</t>
  <t>Paul Kocher (co-author of SSL 3.0) <vspace />
Cryptography Research <vspace />
paul@cryptography.com</t>
  <t>Hugo Krawczyk <vspace />
IBM <vspace />
hugokraw@us.ibm.com</t>
  <t>Adam Langley (co-author of <xref target="RFC7627"></xref>) <vspace />
Google <vspace />
agl@google.com</t>
  <t>Olivier Levillain <vspace />
ANSSI <vspace />
olivier.levillain@ssi.gouv.fr</t>
  <t>Xiaoyin Liu <vspace />
University of North Carolina at Chapel Hill <vspace />
xiaoyin.l@outlook.com</t>
  <t>Ilari Liusvaara <vspace />
Independent <vspace />
ilariliusvaara@welho.com</t>
  <t>Atul Luykx <vspace />
K.U. Leuven <vspace />
atul.luykx@kuleuven.be</t>
  <t>Colm MacCarthaigh <vspace />
Amazon Web Services <vspace />
colm@allcosts.net</t>
  <t>Carl Mehner <vspace />
USAA <vspace />
carl.mehner@usaa.com</t>
  <t>Jan Mikkelsen <vspace />
Transactionware <vspace />
janm@transactionware.com</t>
  <t>Bodo Moeller (co-author of <xref target="RFC4492"></xref>) <vspace />
Google <vspace />
bodo@acm.org</t>
  <t>Kyle Nekritz <vspace />
Facebook <vspace />
knekritz@fb.com</t>
  <t>Erik Nygren <vspace />
Akamai Technologies <vspace />
erik+ietf@nygren.org</t>
  <t>Magnus Nystrom <vspace />
Microsoft <vspace />
mnystrom@microsoft.com</t>
  <t>Kazuho Oku <vspace />
DeNA Co., Ltd. <vspace />
kazuhooku@gmail.com</t>
  <t>Kenny Paterson <vspace />
Royal Holloway, University of London <vspace />
kenny.paterson@rhul.ac.uk</t>
  <t>Alfredo Pironti (co-author of <xref target="RFC7627"></xref>) <vspace />
INRIA <vspace />
alfredo.pironti@inria.fr</t>
  <t>Andrei Popov <vspace />
Microsoft <vspace />
andrei.popov@microsoft.com</t>
  <t>Marsh Ray (co-author of <xref target="RFC7627"></xref>) <vspace />
Microsoft <vspace />
maray@microsoft.com</t>
  <t>Robert Relyea <vspace />
Netscape Communications <vspace />
relyea@netscape.com</t>
  <t>Kyle Rose <vspace />
Akamai Technologies <vspace />
krose@krose.org</t>
  <t>Jim Roskind <vspace />
Amazon <vspace />
jroskind@amazon.com</t>
  <t>Michael Sabin</t>
  <t>Joe Salowey <vspace />
Tableau Software <vspace />
joe@salowey.net</t>
  <t>Rich Salz <vspace />
Akamai <vspace />
rsalz@akamai.com</t>
  <t>David Schinazi <vspace />
Apple Inc. <vspace />
dschinazi@apple.com</t>
  <t>Sam Scott <vspace />
Royal Holloway, University of London <vspace />
me@samjs.co.uk</t>
  <t>Dan Simon <vspace />
Microsoft, Inc. <vspace />
dansimon@microsoft.com</t>
  <t>Brian Smith <vspace />
Independent <vspace />
brian@briansmith.org</t>
  <t>Brian Sniffen <vspace />
Akamai Technologies <vspace />
ietf@bts.evenmere.org</t>
  <t>Nick Sullivan <vspace />
Cloudflare Inc. <vspace />
nick@cloudflare.com</t>
  <t>Bjoern Tackmann <vspace />
University of California, San Diego <vspace />
btackmann@eng.ucsd.edu</t>
  <t>Tim Taubert <vspace />
Mozilla <vspace />
ttaubert@mozilla.com</t>
  <t>Martin Thomson <vspace />
Mozilla <vspace />
mt@mozilla.com</t>
  <t>Sean Turner <vspace />
sn3rd <vspace />
sean@sn3rd.com</t>
  <t>Steven Valdez <vspace />
Google <vspace />
svaldez@google.com</t>
  <t>Filippo Valsorda <vspace />
Cloudflare Inc. <vspace />
filippo@cloudflare.com</t>
  <t>Thyla van der Merwe <vspace />
Royal Holloway, University of London <vspace />
tjvdmerwe@gmail.com</t>
  <t>Victor Vasiliev <vspace />
Google <vspace />
vasilvv@google.com</t>
  <t>Tom Weinstein</t>
  <t>Hoeteck Wee <vspace />
Ecole Normale Superieure, Paris <vspace />
hoeteck@alum.mit.edu</t>
  <t>David Wong <vspace />
NCC Group <vspace />
david.wong@nccgroup.trust</t>
  <t>Christopher A. Wood <vspace />
Apple Inc. <vspace />
cawood@apple.com</t>
  <t>Tim Wright <vspace />
Vodafone <vspace />
timothy.wright@vodafone.com</t>
  <t>Peter Wu <vspace />
Independent <vspace />
peter@lekensteyn.nl</t>
  <t>Kazu Yamamoto <vspace />
Internet Initiative Japan Inc. <vspace />
kazu@iij.ad.jp</t>
</list></t>

</section>


  </back>

<!-- ##markdown-source:
H4sIABF8sVoAA+y9a3fbyJUu/B2/AkdZ64TqIWlRd8tJzitLsq1p30ZUd2fS
6dGCSEhCTAIcAJSsOJ7f/u5r1S4AlOV2T858OFpJWyKBuu7ata/PHgwGUZ3V
s/QgPr9J4/MyyatFUdbx6+Q+LeNxOlmWWX0f985fj9fj92VRF5NiFv+YllVW
5PFouBUll5dlegvvvx5H02KSJ3NobFomV/UgS+urQT2r8P+jrcHmfjRJ6vS6
KO8P4qqeRsvFFP6uDuLt7aeb/Xhnb2OnH+9u7O5GxWVVzFL6bmdjbw++29ze
he+e7o6iKFuUB/GiTHe29vbPy2VVb25sPN3YjJIyTQ7il2melsksuivKD9dl
sVwcRB/Se/hrehCf5nVa5mk9OMbxRVFVJ/n0IpkVOYz5Pq2iRXYQxXF5NUmn
VX0/k0/jGKZtfs3yaZrX+kEF61WmV5X7+34e/FmX2cQ9PCnmc3jXfZvlsyz3
3aQf68Esq+oBNHJZzOCxQfHdv8A3sLLzZLHI8mt+NlnWN0UJgx3Al/ST5fD0
yTA+S6tJUc4S/Zw35AQG0fqqKK+TPPt7UsNeHsRn5y/e9GGJJkP9Pp0n2ewg
Tj+U/19ZX82HMPgoyotyDm/cprhSZy+ONkcb2+7X0VP5dWdzf0N/3d/VT3Fv
9dfdnR35dW9nSx/Y29ve11+fusb2N7Y23a+jPf11tLnrft3TMeyMRvTpn3ef
0gDoR0h87TS/4tED7dbp5CYvZsX1fTyID8dvh6M4zSfFFJY4PlvOkPTGi3SS
XWUTfqG4ip8nFSzjSfBY3Ht+crbej4+SvMjh2Vnr+yP4PgZCi49hZ+HzZVbd
pNPWY8fw2JqOGA/GQQyEvamfuB2P/e4BRZ//MDjXz6q0zNIqg0max07H756c
nhwdxPv7mzuD0YG0+eenu5ut9Xm/vJzBBL9P7+Oj8n5RF9dlsri5j18UJfGH
F1me5JMM5jhOy9tsAsM+zadwAvFE4wMns1m2qKGJo2V5m8KEr7Man86u86Re
lml8OIPjn9U387h3cnQ8PmzOePT06f7DMz58Oz59cML4wAHMb7iL8zx+5b/S
ab5N72BoZTrBfa3g5ASzdSNqDwAohY7ZT0N4/+oqS9tfvRnGr9LZbJ7k7jud
2d7eYGPXfWrGHp+enJww801kTEBvllhhbYFr9uMfh6fng83NOB9iQy+P3rQn
d5Yyj5nym9BG/HxWTD7ER9niBnj6m2IK2wbE/G4BfJKP/ktggVn15KhYIoOk
R+IetM5k+/LN4dFaYzZARXuD0ejLSwXrcYysOMu7Zm6ef3s6PpcjBxTDlMhT
2N/YGGztHwPj1xVxzGd7Y195wPbWtv/VsRm8WZQzwEXiuJN7dmdv17GOp5uO
UY32HKPaeDrSX3c2lantb2049rW5teF+3XG/bu96/rbrmNru5p77dR8eQAod
j1sHsX1wxnhVJeW0H9/K5bvdYhajrYePzltaT2j2NAdGVC/rFOlAW65os88d
W+zHPwzHsHvpIilrvLTw4SOkrXLiCL9zL3krX5y+H8fvf3gej/Z3B9vwLR34
R/McJNz6v5nnrOAwMEOgvdyvl18it3ItRr1jjsMDfAn+y7xpgO8gKXSsyWH8
JoWRTWkR3l3WSZbjRdGaGm8Zr+DAr2B1X9XpvFo9zYH/VQSHMxAc4FhV9UMP
HQ7j8U0yz8qHHno9xDN/OJ2lhgc6Frg/8Dda5yohgS1zOfrEp5AIDoHTxbfD
eHPUB94Xg7C4WAzj0ebGAIQAlFfG49ft6wypA75wcuvqBWEh6ftssYhfZZMP
lnvL0UnrapIs0ub4jopyMWzO8ukOzHKw8ZTHtdUclw5ra7jhhvYVWwW78KJM
s7S03zx+kF1Nvh/G3yflrC7y37bNYnLza4fp1nIXztVghELB+emb07cvW7t8
ls4L4GR1NsczktR1MvkABwMO/qLE6xREsq85CcfD+DnoAzdfeqZczmfp/YO0
/MP45O3pnw+8GjW+ny+KKlvOW9wDOfefdzZGD4qs51Zkhes7hwbppLNiMyny
nGUa+BqJjGUcUrfwSp9VbWFr68EJkHQJstQQRgafopgy2tptEfSa8sdQYq6I
fa3g721Jd+MLki50/vBgUYjC4cFH78ffD16cwj306uS4g2BuM1ZfN0CPLKoq
u5ylQjhxdhVPZhnedjgM+FelkAxoajYr7kByn8JuAqlBJ+0reMf1lpTXKeh9
N3W9qA6ePLm7uxuiQjyE2TxBxWqQlJMb4LlP7tLLJ6AhPwEiKaHDJ/PqerS/
OdoZ3tTzVYzB0CRR5NEQVjeFi6ta9QQKpkV5m9SrHjgfxrdw6U1RAEzLu3TV
cyATjCdFje0cvXo1/pEVsmCFD+8+3CE5vAKyqG6SD/DZe13neVYBOU9ukLXz
Sj+B7QShJr7NQC6HlV6x/jnuVT240TbjOYqp8LHfz/32fuz9Jvuxubm1v/lP
3o9/xQfuZzDd33DHxq/fnb9qX5SoekxKEKOACYM4Rat5yJz0AFhdmnxAgj9s
7cj563E/Pv3+pE+CyHj8ahWnbQ7pe+CgN7Ajya2/apvPvBzGr9MlbkHHucdb
BPUKp1iX2SWIZVNhiR08N+69BVEbaWJ3vUUmqE4dnhweD17DJXPeFshfw+1S
k1pmFoGVeGRquBw/VKksyWMXAW7y18v7Dx8fWKT30EtZ+XvZUrEScXU9LG+W
s2EyGS4/PPmvD4snMIbB4cklqHPTariYXnVO9+j7juvmEMTd+yojwQtY9uDk
4wQO3HXqBBXREm7SrKQZk365zGZkyaBFh3sdXsntdfOFdQDh8yjJ07rOVj3x
CoSJMrmb/P3+QxctwOAmaYpDoIGfLOFv3Ba8VkbNydMnR0cv2U4UzP5djnyq
HoBgsigL4FSpo6OvIOyj4iYfvCzKabGStL/MHkCMfpmUoKB3Ej/ddTjKZW3N
tC9wx+XuXSlr0BX1/PmL7//StQTHxV0ONzRw1jPoDDnxhMi6mxh+y+N+hELV
35fVh+SBJ2CGaMB9gKl+X9zM7tKsWrmywA3/AtQ2myWD5+n1Mp1lK4cEzb0s
0zR/BM3RjnheA/zA7QrpaGV2m0zu49675AOy9HU9heHW4CfH73562tZlGrwX
20wCTvQBBKxUNujR+9IyZDUfeM9XzLuirCY3xUPr/lOGhveulTqGX67zqg8E
OxWV1UqCLZkUFcRXL1+MRzttY0F5j3yGZN/30FBRJr+vQF7/CCR2dKpXVpxc
g8Zc1V/Di4G2Xs2SJcwy/fAgOSwv/SybD7wAAk3yDzfQzuqHjvA2hm1Kq0eQ
FasQ8U9w01U3xQLp6t3VVZpXIKh4fSDzbQWnfHz68k3busCfkl79e/g9H8BC
Dt4cTn4fJwtgewnIZnXRoC6mkoGYNmkP8T5c8p2HTYEUAArXV/KFr+PrR2f/
/v78napLwXTpkyOURtssDY5OMadZuNsNx/8jdGSN+0As6NA6iDcGZ+fnfeR/
y/nCnbbjdJbcYxvBQfwK8vpWedBIcZ3fr5IG/7uYVkMUydI0/biYFWU6xF9J
rJ4WkyVaDp/s7Wzv7oz2n3QyvBcvxz91bBtpjEV+lan6y7dQrLcQyE/omJgn
s/gcJFQ2UeKwT+eLWaCCys4+dq9gJ15kwAgeuBjgoL9cQn83q4/5czrm82y6
csPgiZ8S0CShq+x/3mbtdW/W6z//5cWrjt16s5zV2QL0O6fzVX58/nShoDfN
yO372O34M0jJKwVDUJL+vFz15TFsZJpfr/r6LyAIICU9wJxeLf/nbczTFafo
p4778kWC9h9yMo4P8fRUcE/XN7Qb79PyKp3UeIZIWYdBl+nk0YLuCxhkBvzm
pzSbWyMfGWvOUlT+a1yp6RL60AVp31JsJj07+f7k37Urb/qCASUVjh4vmNfZ
VVpDX7jkCc4FGQDKwElJLqHY6i74giW/s3QAAhI2RZdm9p9LT4DhRP08lRkc
Xk6TmfOat79/jrJkqfzWEsrh+PSQLi1j3vL2rsEIP3t+/OL79+/Pxn/5iz9V
bgWAk6W49WTZJFoqbnU99EShww+2jyI2HjWlDmG88cQhun1m5GUYvIbHltPu
51oCeXtxmuJ444l/RRV3xSjwOxAo/p7mH4qV4zxLKhAks+7v3wIPvkvm993f
rlYEWgOBJftLlv89A4nzplh2bfVvwBP2GhQy2h2M1FnStF6lCzjV9TBLJiXx
CHz6yWi0t48exedv3px7ZuDFoGskpXTaVNNpREhRLwu4S+Xw/GrqQjUO1Mey
rozxv/3MG6/ZNr78Ab+E8a14F27N84RcNHn3NtzC9KwltslrHrmcO0+2nm7T
ap63DyZa1+nGG/xQWQUcFm+VfQio9WQ8eHn0RoxEViL5EgcKOczXLkinCO1u
oOASeTSp7ezS2qDw3iVxxz/k2QxNV8lsUBeDN8t6CaTV0GGRd2czWD6U0axk
F/fu8JI6XBg5DjSSI7YLd1ohA/muNaWHVuQQduToaLzyUl65BHve3/sVWg4u
Wpe0ixT17j3dyxplR4a2b5ka2sHi8f/+z2VRP3v/tRPcefJ0b1UoziPUuI5H
fkpTincAeb9DVDm0RoFs0rrNlSFxaOFoI36xnM2EmaYDkDhLOG5IRU4Abft9
216axxHGSqdO97qNth+5bnB0j4s7uHdWyqC/jS4CgvC4Ti/hSLoN6Dq0/8QN
6CTf87N3b7/+HG7sP/Yc/t9Z7hcvOzxkZ+liltw7gxXwsb+kcFjP0IA7OC+z
RXyezSVW4Cip0uYm+DXuUKjazq+vYRIrPWYdq78Hq78qQvEb1xZv3uffdywd
222A1tinTRR4ll6lJZmqnchs9H+7cM5V7dbt1y3btwh4v4W1HGj5OTQMMtZK
+8JblL4vUfbO9Kpuh8SGZ/7kY11yCCLNAk/zcYpTYQkGqfHV98cv0LIBi9xe
uY1HrJwXQTa+gtI2nmzuPpathtfRm2TSQUVut9B7jH5nMlEghZD57yscydcg
qywvMTgavcZ310842r1apJMnsPagaD4ZGTfUlw2FMOCjpKxvkuz6Bo/BWVqN
9pLmDIDpzjDkJSnvcZAJkuCLrEyvio+O2N9k0+ksvYRP0o8L2JG58aX+1h7y
nY2no6/xkNtQdZ3kZXOSbwrQUyao49cZ8FPcr3maVMuSjnhcphUI4W3b9281
pdHe02+Y0vM07963StlTfAnbBTNUBvXTyzipgbWcv4hHPh7my9PC/ceD+yEt
zfTSFO0GSHxP0PxdZgnMr5pl07SC63uDMjOqtKoSzs948shZYvBTmv8tAdpz
s2xt3OF0mknwpBKjbFZ8VRZz0D3hv60gyt9u43b3v2bjGlP613GHgPoubxmV
dGbIKv/th9Oj+FD8Tj+lyYccVjal4PL33x+NfzeKb0fDHaMP/rfJpLhU6Pcv
gSlNUyCDaZY8gQ+e3IKEkaLzqAa16mYJilbOAuvG/pPN0ZNzJIJ/W2YTEUps
4MAX1u98GP9rcr1aIPpXsoXfpflK9QCfKOYFaO/Vh3vcg8O8yEf73WzbmC7w
elfT80f0UyEnHNdlmszRPoQi7N8fMpiRObRY1vEJR720+f5+17asneZxtbyc
492KuSSFudX2hxjeHZ8cn56/O4MdfH1yOD6Jf3h/fHh+Ep+/Oh1rg2cnL07O
Tt4encSHL85PzuIXp28PX8dv352fvjg9Ojw/BWG4h+0NtgebT9eHXxFVgot3
Py+WVRQNBoM4uazoWo+i8xuQ59WeHFccrQdUeusTupykuSIXLOJcMHX1DWNa
VwqNqxoBXUlDgZ+4eM80KvAB8htKThaelCS+A6EYbr4aw+2m5DeGTYVXF2V6
i0NOk9u0mpYFpUL1ozqZ470Gv9IhnCM3u6agFKDG+2FzwpJwhvtTBUln+DIm
J4ljM3b5ZxE9anPQ6NGnu6NhHLYNzLUwK5qnd1GZ/ucy46vKOqI24ywUUoe0
S3O6rKMo+l2Mi8KWc2QUUQc5nZ28efcjktNJ/OLd69fvfjp9+zJ+f3h2+PLs
8P2rCAW1qliWk1QEYBwp6m24rsA+cwwph5WFNX+Z1a+AU8Tj5fV1WqHNSmII
ogoOxmwKdxSTeo3fJVW8QLUPpwZPg/RdR48QhIYUOF8uJbsFg3Px2OBGL3DD
kiq6S2dATCdwbaBfYaajiDEQH4YwT3J40Iy4H18u0d93j6PDRD70AURiQPJD
n4LKsQROPOUOmQvgBYJcAVPtiEgwVjiboyh1LTZQfCyrmPSKW7gzgTgrZj4T
Zj7Qen2XptDqXRF50sZ2Fymcp2fUXZHP7mNDCHz94Teg6aXlDH0SUe3OGvqm
Y5TskstZ2ofZDoBVpWWfRbyKGNvQh9nOZvd9bCxqDE3mr0PH7q4KPKI0Ojg+
aVkDlR4Af2jY01jIlwNc4cvCD7RpioOFY4pSVxAjwPOV4E16E20HC5YCZvfN
x4dNQx5u9A2wDFjR2ywBkrifz1NMnownYbRILx1eD/vk0fr0Cf77+XOfc0vg
T/qXPpjyB5I++PnzegwHIUFGorYKjJjpvR9/vz7EZSBXM+Z1AvEBmzvgq6Si
vBflVboGcJDgE6B/2KWsuhGxGqeLu43RqBjpCrSDWxPHaT5dFHDmqiGR1bRA
/lDU8Y3uzSzNr+sbXWnaamBCRBUYdtiHNvCWur7xTdEZSqSbRcKWwpJuNhI6
iGzwO2BlRBrcB+0a8jgMcLtNiY1LzLgGzUC3V0Bb8JjYf2rnMaOFQoZ9Xf6K
JcIdxmlf4prMiylr8Zf3EnoNR4bPYpUaEjVHGfhHGuM1oCEnV8mEvYG5ayK+
uymAiipSGpCDw8lEXur8GjmHjfaRk8EFMymzS+Yqnz79H6CVrZ0doJVhNE5T
+KSSO2+ga/H5M/HTBIYvign2AecSKFpTpLAXOMEpKO91rC1EfkY4SdgrGBc0
WLN57a5wDAgbLXLKEabTGfuAZ71z496nT+7TgX6KJE4c1R6zijcl5E4JjQOp
Kk+vCyB4fG4SGALmLlQL3atwDmF3+O5zW8rZze4oYcuqZgyJiXQMPLzV4X1Q
CjKkOb3Hn9FmTsif6/ZUSIBpxxE9bATloeEEieHih25CwPivyCZUmxng+hDp
3Md32CQeWuFuPnfiDt6ivohByyiGvBd8wIKN4I/au7CsZPFN937tiO6ZO3Qs
E986eDDdaXSXTXM7oQWaPa95c4DTDC+AyjWzXACtY3SXiLNAfbQLxDf6IF5x
YP4d0MAN7hamugNHRr4InE0GBaNfqlseN0DaBiJQ4sZLwgt/Zv99c8+A/V3f
pOUATgrwCxc6hlwimpHISZL1Qm9jviSTkobCs8WPK5cYeVPcQVN4VwqDjVgc
u8dvTAfJdOrOZXwn4RDP6CGgySzPmICwcd0b9b/zM7iEaQk3SU3bESYqRBM8
5ldy+jQic0r8epaCBMbXQvy35fTasgw5FyWdushJiEVJHMKPnoirXObh6rRE
3Wl6BRJeRbMw0v0w/ukmm3ldKOObaEqZQnBJq60FHqGVQbk7A0VC20AmAOKf
/uUkpRwICAQYXLckkm+JI6Q4/6yaC0kFegIzGJY1KreuyCfhlNxH/iwnRPIw
A50JnFrgkTj6arlAwYkP1GWBQ071Jgl0nSU0C2KgcDUn4LdnKHMCQpjMlhTW
7tdvkyUK1ATglgA5XeR+35yKmEAOH9I68vPnDZGrRtKR4TrBwZToDMDEVrj0
adWxEfdmFLxZuqhECttcVB9wIJ8+ucWaDgj1Aq8qUXci6g/VHfgMVomu3nvV
it3ZBEbHORQU1jkNuGkUJtkCs4mfpxMMc3WUpPI6tolaHHIDIvopGpBTOJ9Z
rYgfsgKgeuEKtC7i9CNtaVkFa6xqCZ7Bd0fj96rtcS+TpCxRnJBYhpINa0F/
qOB9/hyF28/fgD7XMZJKboRPn4pJtaD1riY1igegpP0Oc1VzVEpZpaHc6XKe
cYIeKxUf6KJBiWztzQ/j87U+/4s6Pv5+dvJvP5yenRzj7+NXh69fu1/0ifGr
dz+8hu8j+c2/efTuzZuTt8f8MnwaNz56c/jva3xhr717j7aEw9drLDdlVeSV
1pKu0svUszRW8oJ1eH70Ph5t81IhxgcsFQvWo71tWNA74H7cFYm//CddsijN
JyVp9sA0JskC05crkr3gTr8DeR82ShQwr5/AQOa8qUiHIAUxt2DNRAXgWPi0
Ne74Sxza9H9gnJjTsAZ8tZj73qhxRlKPIv39ID7JkKKsegMyoKhIRVN+gDfd
jY4WKBnozB0m26emujk2yOzdyFhNEYL7y0rSelEJp6XASAvRrZGBcEwEjAR5
IQ1CJ4P8H/oVrZiuNZYHJ8sZ7JQ+BgSEr64Ba7oS3lzbxVcTDd4dtdGeYVB/
Q6kFRqld0IrA7ZICEwjH4lrhb3EwIojAGxVKCSueV8Wobr5SUhcBmfC1M81Y
fHSXeyfJ8KFmC8Lr4toaXtTucnzy+kTMePH45AgPFr7Y+24dZRu59B0r5FW7
y0rDZnlA88RZBZrWIDLnwavMu6B1drhv7kfRIUguiWNL8D/klOgNwQUHTTZm
BVa0DHlvD0VXZh+DPxH7QRXmMqXNVwUSzcwVsCl3nV7odbhGFFUsUcPd+Lix
tbFNsvCbJcwi9daaWZrky8Uwdt3uklINRIUCGO3cfbFE4e73tZHSUR3XG4Su
vvYA/Ex2SAifcrDaTZqIhpt4XwOpzrAZNEJgxXDQaQRqhWQF9vDtoRuwa3wb
vzqTLaHxHr3aBAEQFBG9/2HyW9r6uJinjcZdU1vcVL6cX8II4RK4IDVJX+Vd
zNM72L4aUznE24qfTDCnVTR8nBryRM85KOkY7cdVSlGv6YxxMgKRk/Jr/Afk
Lr93w56B0F2TSYqBqYhdk09hvqxYv5pM0kXNAsAc1ZKQPtGekVRZWtJaHutN
YkT82wQDg+tK51rhUiG0lZrgKuNDQdUZoanGh34rNmmXtFd3nHCmYreYirUU
XZugT6Q1I9m4rUfTBrODC7M2F/X9gsg9ZS8MNON2oHK7Q0vuxSwmy8Tok+O3
p/rwe6Q92BW/kWjFEiMk/PXq7CxsF75Nod17kQ8v8gKDFuQRRDK4TQNrIQrF
c3Lh0GbDsBZFTlszmRVVCu/XuLs4RtiY4LNeohfqTTK7GtB3626NR54SQTAe
8HBiHk5VyDVEqUD8DWp0VVVMSMSUNYEe/aog+4F5DFvHXmV90eKRsQNdY4Co
F3a9DvyBMBVAvtfEfGrwB+KFbGcBopzADUcbiVIELIqYH8hF4MjOX0BIZ+TV
99L2/TB2QElyr7S4sPuEKRgtzAN+2Qvnnmg3tN81TFO/cDO6QPVwzVBIYKVo
pLQ3VMnYrej4BpliHs+SS3V7YSDG4OTjAsXS1/ix27e7lMjwStQJtAbmqKij
cgcURKO4JEwobf6YVAxSb/HOQxwjFFw/VO6Js3SQ5nRdNIbcna1PZjpiLcj1
pwWSB2J7sKldNC44yjfZZcanDGRCf52kZVmUQ3Mm8BTz8cUtxPS6C8HD6+sV
X+DNQinhRW5cs/egjAxlb1K+OvLiwlgnLrwGhFTJBvpPn/4XYjRtbaBeIPc4
egtgCkBMnmuYlkN6a1lRScZDg6+zkIqbVSlo9BTbepVUNyiVIL+8uE1mSxTN
F0viBCeqFwU3SW4vQIrWSQeUy1HjeblOW28OXT8cUYtJfcVIjaq1xwKg/UMW
lrFKyC4vshdNlxORTflMEt3laTqtRJ9QfQxanRTFB5RIPJtjVxA5cj13PmOX
Er5Pty7fFDNCMGGoRLvu7H0jxdDBciARs0i7Zrk++0tJKkIfqj+JTDjiYCKd
l41yStNoDgcpg7dzib6xi0lyQYqtLuM5XqewSmJ3uyqTOQulxvPHTIcFi8lN
OiFrEsvxc88yYVLFjALS4jW5HEB3mt1foExzgW7nNVbn/KdrzpYHLc7SYG6u
Xb6LgM1dFFemRdmmxLBe9Z7qq0hdKJ+lHBTWRVu026jlYrD/dDlLDb+gc1st
4KbHs9661JS3rkEXLB9NcWnXggsEmJTLzwwmTodUVKYe8LnrgmMtTk7QrJ1U
Thp3e1oT84JHgDFs6Bh5U1DViReMU4OTgWOXcRq9E2GCiwdu42vYaBT85eju
mykvUaPApSzvjRhxsag+eLOq8wwid0bxAbl4OqVpiUnbSCDzpEJnSkULP3RL
/CL7GFcKBXaRKMoZ8NG8hr6D88LTH+rxw9mUuF20jsjyyfvdENNpCDihGeoG
KPbI0CvQRs3s98zs+Z59AQeRrNxM+24RhLH1rdnLCxOwRBeXGVndr7J0NlWW
RJpNDbzgqouF4Lc2+T1QtNmPYdjlPPloz1WV/T2VzoAqz+ncneDX6NpC7KVQ
aOfZqX2KZiGdNlinhp2W6TUr1vqKSqhpCS9Jf36XsEHzJ7yNyCYgrByJ8SuO
u3mDURz8GvHyMpMfOjWEzgkLkhVdDkZIdRLoFIEkoC0jbxgzP9v0ApH7VVLO
ixxXM+R9lxhcM2HoyWqZ0Smq8RhdH1CrhsyB8MglpaoHggRhsCn6+fFRXnwk
T3rm7qYAArZNu/tJrMxAGaxFTTD9BE6bl7vsa/5mIr1hfMRyItkYicGaS2rY
VhjgbgXGkaFSJepakQ8KEosD/QJW/W16N2b5i3e+83Xgh8C6SNmTe8idJlyF
t+NzyyHhRPHlz5vkZH5eLDpasAz+rO7yNt8itonqtfbAyKTk2gC1bDw+HIDS
yaRJTnUHP8hRwER6orKyZaFGQr8E4eaOMBPD+E271CR5nIH2di+X/5AvfLgK
yIhNm5eHt1qoX6TQHUgLWUGWuLzwB01YDccFkRpbO97FV4TTxeTRobSO8LDf
p/eiczD8mnhWma6YbmnAGGAJ+tbA/xlTzDYwgjtQkY2UMk/hs6ZpKLg6UZ9h
6wdJO85T5qzYZnxWvpEDJ1qVPvWiKC+zaZeARUTh9SGSzIkoZsnH5j1N8gqx
fncCDePf0eFYCqruQYf6SEZkF3uDRuS0nGW5ZzR89baHN9SNYwGFd0gQ17ys
Ek7SqtRV4zvrhyTBx7kNMm+HbSKLySOwDy5cB+kmviLziSdD2FN0qfLCXy9B
ajDqPH5dAiW6z0nkFMMpcDA50BIURnvw0jzKO0QZz3eYeHpXyTYhWCXcRZfL
nJ21dH1VVuoq4Dp7f/b2JVldhg0u0xJFibT95DWIBO2l1YKoGclUKBd3X7d/
29s1RMaXTZsV8GjZuFRwEddkc0WAMzft1CHbsBsM/kH/O3m+JGYlLy6L6T0L
6lndaJ1X60QNO407VUUNuqX5AkVJ1zEW6IGlEJA0L6+WFUuOwh+HMMcKlXaU
6rKajWzu3scohiZfdyLaG5341MEqVZTOnc6MTZ1QeEmWJYY4PENkG5ID8e4i
1yexonpW0b8NrT2dTKsE7/aRF92bRizSxzkm5ypBDFm2wAiDorsWDdccQ42i
GENnppaq8F5DKxIKXcDZWdWSZpzhFJE48Itl/iFHD49YehI6S9gzrwsSGslH
hH1ONxeZHf3VRTKnWilB7wj0An5Er5hBeMNQm8HjaNcIGJ4xlDvvidN5vIVd
vGDqYyL2MWMkOBwy2cdYkpBZ/Q0/dVaM0kmp0MLQymRBJLlLtNNuxeL40+l7
Dto0HHfL7646jAo2qY3VcP6S3L/D1tnoNNSYp3onR+vHr04ckwcOCusIHAbE
L24BF45AF8mWcQOz+tB1hEkvXpY5oXAaGnQyJ2utOd1xH2kCqO+XBZYXkDNj
7oUxnLhl1RQFmKmBTCrsr0u8cuqOqgrBdUsQWrTdbQUlJstLoCQevzIqokYu
oEKmTO/vaVkMFglbmfhso3bBFiP8i0SaYYMjGlGbgwD9dEAGGaPAfoLqnD3w
ibBbUVzIGHh2ZqiEDOjvXdwqGq50ELiHofDbGFAip0g1GMOYnGmG5CxlsGil
rFnMQZgvnjjLAM6+i2vaYRqufagpWmHYNNy8r5lr0ZnLSrLA6S28MdyJkS7x
sXUj1zqlOHZKcSChwDRYvLxJqpu+f5w0B3mBVdQJQYrXxXWKHmDhlvC/tnAr
yjUzNr4EZgpYMscIJcThpTaJgZA0iqYbED8+hCxxsSxBHEmpcAimfaBxqxxM
kiptcGuKakqLBVl+EutIRIZF3hKOpwkuC7UEsljQdOB5GiIHwXuMScZBHb04
e8mrUcX/269YxQZXtSJgjMllFpAU+6iB5Yk3DFdA9Q56zRsvSZsVcy6H08IN
wrKdtMhBrXQ26YS8+jC9ItO3490iQNPstRsy3PsL2NrunWeBfYIYkjmVqgie
HbMAgcIx+QHkIC0KFKjk/PyQI003bOBkexiyGe0RNnO7aqzdmxeQLaFEfr9A
KqA4Exw282U6JuICSuTKVd6HlrrGFiyBCxuRLu4lZIpHoiNrmUC6xCkqPMN1
TxIbZoRsVTBs+hyGVilHohSvlmgvchwy3YYFnc0h7WgIYthqtDCmTv++53ob
T43iCs+eieJqiBWpoi3lB+Rq6OeYfJKORILLY0H8kzImiFZg2V4tr4t+/KpI
a5CrmX08/1uRwj2o8BydVIreN43aZG8iO3xgPxmIzzsr5bEjJgZccGvipcRc
steQvILRdBjAZkIP/IGY8iHSoHBxMWVXfNiBUaAvPZ1k6rBKLnG41lg8XabS
h2OA6GGyjmi5BGVX4VRxEA2F+VO0h0b+cetE88KqFjBVXPPxq8PBSAID3Da6
ZXxzfuoZdmUoYX/Fjt6lCQMGo3CJJwEpHtUp4fQrSeHN8Q4jHMN4Nje36eJI
q86BCbXMNLY7uU2yGdmeEV84vHs5oBp9XSpIc//oXUFLZTZfzpFAJPlG9p+s
xcxA4UVqlQ7c5sb2Pi765s5uXEzq1DXHAsxUqkeY8+C9dIn3yk0wEeJ6WTrY
c3L9+FPaqbRhsjjK+0f2ZUudxj555aKnLsK+kNBuC9DZJw6EWriaPH6DUsjF
tMhVNEOmbE0hLOngLdHwwniLoug4VsNRsiE7Nqc3OK9Dlc6zQbpAQ1eJ/rVX
wioTf+dogBczYyEbS0lliCQZ2L1RHvsXNV14nZHZq0qATmK2bE+1y4JOvpnG
rkh/5FuNz462A+GHTHTdtjkW+ss0/XsKl/zUnUKhO46cc5c3cnpL8WIowzUz
4gHOUe1r9oITe0R8+qMZ+U4wcqyR8VUjzz6Kh+XNWOmW9TQj82hX27yAGAnL
dyGBKftcRWWelfjL8cTbCTBZc00lTMdS2wxfsZxpctdx2YiygJIE2YIwkYRc
85QNgoRJS5Z+5Fph+IXEmHJoawG7QQNIgAWzpJySR5Y8BS1BAkjdr6D9wh3F
eVLH4TO6RFvm8Zdv2BRl+AAGyBoWeXJ05L1JKAiS3V5ix9x+41RbnJaz4bzX
zGpC3gAHbM55wpHpYVO0/IFd7BOfnD6rLZ/hBDlUKXiv/S2dL6/6554yW8Zp
XnyKb/T32u8tUXHgEsIWEs9x9nUiChklCcyeLkyC4Yj4B0qNQeTDsqphBVAz
v25p9nYDTHTHqkd8sBVD2r4KHGer3kK7j7m7Ko2UZHPHsUQAYTwA7ZXYM5tR
vZTZaDXROb1+tcwnGrxnWhLDbKQZswYLa4gR4RJ7igpOLgo3Gos/IvQyJw9p
HDiWhUQN7D6eU0Cg6YU9+BLZQYzLJRP45EPjV8W8sksyF5dLDMjH2x0hkPwT
qNWKMqbKRIrSxnUyoZQV1Os4gQNrK3JYNAbRrwKNU7vkoQ+9opy7Hu7HuhV+
aB6yQeRmm2Ao16J2g8bjIqkoZDLiAMKOBBZausCh6jSmKnRQu1QjVZR8oS2f
PMFGEmqQzzUXlUuIo7KNU6MvnLmg4WJUGqEXX705POLzKhcuWaTQXkymlz4a
kzgIpCQwpRrBlDAMzUd8g1IEyj+QNkoWFNrVsDn0YzFOTAomDJQxEs4IYJtd
kM43QFSh4GCFaNmhzEcWFCIj5uTTZ+yxFPMS4pTCNVelqzch53QmYhpXgt5a
MXqrWn+7bh42pDRtOgllu915NYNIiRyxdzOMIuBMdE+WxrjuQkbEMYaRnyhC
BsYhFSyhsYqjasjYUKp3v2FgImdZmv+tuOdr0SblWmJj40GYKehP9AoKCld/
oLmIfHrwwuZPZD4u1NVHcYGeZxIlUXkRRYiD8l14KimLfMb4GBuCYRglIOMB
b7OALlF+CcfzNYCX4hd6AHoo6q2zcYSODLsxfSo5ReJnzl4epmGGUSyOm+GM
SYDOXWAw20slRxOz7wvlaCyjhKII5VZdzZa49Y7aKgwQJ7N/U1SKe0DUqcaX
GU+Yj+kNhDs2HLoMJLbJGaarFCz0hItKQAwuqLrTwFf1dYhxOt3c2Rk9ZW1s
ur2932dzGouA06GBsKEDGwhPJos2YzjKK1BiSkYpFmtFIGx5zwFOhOb2jlTj
MANXSInDKDw7Zc4Lw2CYAhvSmVCloJa80Ge+ry8jjxJDA2UZVNbL33dYsL6P
KHaWEM25xBu5K3jAZ7s54nJaxNQtDVvEE9cC3b54GVr9RkytDAGdNoMIRC10
UrLLIST3KiYjcj6jN4l6d17clIjFZ9CO+c6nTn7lDgYUwMnHCCaIkBX4L6fB
oreDD7S5hskEgJYN5CImFzNkRKQPcio8XklMNEi5qB0G4hnrWlPOy2FRCSVI
To9he8tSHrH5jIhi0ufTSDUegEuQI1GQFEBix4LNgY0GP9yCD9dF3PtBghAO
rxA1nJC0vaDXlXlaYTKuAfKgvfF4EHAdYUNRI+7a4ypt9gOyR9FJI31J9sOL
IlI5VYs3RNF3IBjoTnujr7k4PJFmrcxD2WayM1Ce33c2BMb7FSqKfNH8RpOe
6R4ZeEYjDeHh6cyvMVG4jUQCFYyCVEyWvnSKmhxNJxlXDO9bBUPUwGWSPy8C
zZ0PNpn2ffdmnB1xhZRKYSPZ5dZP1MRHavNUVVLerA5fDDn4cXoSZ0mqJNYY
fBrYDyndKVNy6cd1QGWSeoN0Rpk4CMWQUehEC3VHjl9kDwRlfFcE8qDm0YHP
XJEUTw/F++4Wa8+md6zUhIzaJOfZGOIGIgvXoxRJSnL/bYa5N9MK66uWlw5U
wADStMOUI2MvpxuV3GQNzAc2KlB2P3myohUADbKlHXgKScuO3I84WquxHvaG
tcfdqDhmJP0oAJVQQAmvNQS4EtG7XLznfuyZB/voGzCIZcUPWswF9NxGFlzh
JpT92cIlgY5AAodwYWUzya8Le8UbnpilWxW244K6cX3NV1Ea1eKo0ZyAIFE0
WB28JEkOwjtAXDgqS0W9T5/oAwsyMWSgBeEn2F2ZkuwjEZpeb0AvFEGJqIO/
11BPCLsl5RxXjKCvU3VC4+EJxK6Ks57gpsPoZfmdiUtaj6JPnxBY8Go5m2G6
eUqhCjdIVCKcQVv4ZYCvkMIA/+u//kuRzATp++t+WI+IIpSd4/+wbC1CE1D8
j/hffC7ed9wVftbF6szXGJSMr+mCXtCCygO3+EAQv/6dG89Afv4Utcf6FRPi
ewEm9L2vNvuVP3beOClcjq9vqmOmt1/XyqeO8KzPODXdu69rre1g/O4zbkn8
Hjly9asWyzaKrf3HV7byqZV5ia38gww8v5YO4k8aAPz5UUv+B6U8+utnA6NP
xqPvfuEm/qMx2QjHCEPtmoJSux1J+NOi9la/vzTH96dVD0aNOf4LAuJpcjWI
fmhDrW/ubXC1WhZYFG/8GAsEvu1wAofNjr6zHSl3pmT/rF7SAAcuKrfdjaq+
T2zaBYUNC6AQ46bRWFtdf/psunZKdBNwhy6wVseCsCEmkfhnzp3/xeQgypV2
ISkkzc5//uU36tx1bfPrws4v3hKn/3QQ/07vCUb3/OPaG4VvxDvjiozDck84
uPO1z1FDdBE5mfHRyFiXVOpg5ktxcUMaZM+lBEViKZA8HvQ/36brdEeGBcZO
mmJJQx6RUIWZyBK4OKtkw2F8AhzunvN91BIHogsNLqasBWOCY7WURLr3rgk7
HpY9jADnnsKGeiAHNiEr0P5urcz9DsnHyTIiVvTjtJ4MJaS0ARNoTdY2kKtH
QCBesvFDoKq7BCkmtkv2u5kKbwSx5AU7BZqD/k95x4IqIbR0fTtHpL6qqdSg
+MTfq163rjSuuaPooETwOzQaU+wtJ0JHPasb8TfrzygUTfM7mjJx9cx7OSKD
YEgWgScUooF2b9ivDBEiRerCiFMi3YZkZsJfesLc1txVbjWxT5/gY8Y1hOn1
fYMNuENJ53GNNXLvghb9q2iSHrivBEoRsZaekc1pUdRsoUUp36ei2mRNiwct
siW8+QRtfhpqj4gYZPu9pAxhYugPGAWHzAeE6AS/Im1tPpHUNGVBXL42FpBo
pSqn4Y8GIAT9TkjzmoUv3m0ghwgjna241muaEtaV1DxKCPuIFbXJdBRZrnHO
eG+XDTXC0rea7OwAGlP2JABNnl45YZ00hQCjkYxubEuguTYajsxR6SZF58Th
Bfh9FbvoiahB3vTus/BhRsogmJJLV1uUci84ZDOpCPmLlyFSH6ycEpqbywds
zCt6aF6WBTRPReQnJ7tHGjVtp2p1Og7lC5R6hk4pTWgaRm8LzZNumrzwCkN1
VRU0DVLXuFMy63BYJIaBMsyZETLustmMYXqRo9P1Yc4GTVc4410RBCJ4tdsv
h71woqhDYj+IDlwot6nL1LBfNUQfl6NEHgVHnbx4K85gX245AW0sKrZ9SasC
tTxRqxPcKFhjylqQhvFff/70yd2qnoVVnz+DkNnWH3Bq2ZVtQy26nSAHgmZZ
4mXK17/82WYk6IA0WYQSyCvyDt3+hQR5Yf+reiOoPu6C52ZHKiloNLUXmTOa
dYVVOuNAA4LXRUQSAJ5DsKTjJxeKIx+07t5zelJzerxoUcf4ydcD10HPG8sb
TzECcEWOLcJLiFKyE2PfQbDCemRRkA+C7cR9pJn7j/SkOmAockLn9xR/aZ+z
kalxc5/cLjkjH61ndsXyvZmK2tySMCqSum2gDFzZphSpCg8s+s7a6Xu9+mZZ
WU7kQulVCnJwqVGIuayJJWY868PY8KUrEH/u0FlpEh0I6Q0BQT5/jvVOTDAM
Nsa8Y5XcbCYVI+nuPd3cRkw9cqQFjNesKHEuHqgw4HB4FEMkXgkOvqZfOXiV
vDx0E7MvS+zZ7irBLLQBMhqcCBBd48A0eQDrukg6ibFaO2BjXMTSKh4OAhV9
rrcSIUwTCYclQf0OXUDuNNOz00c1f7mD4LIG+Qo3aJAcAWeHFNdmFLc0UeUT
pM7zrN8cHsU9VcJaxfqm6frq1WidFZHxq5aQ348xxb8KZgObJQlZ9xwRQl86
6FSkQ/ZMZrlLQiJfblV0oB37QdHUr9RkARP+dHBZxqBC/rAgf5/CzgVkoxwu
YJ4tka+xPpF/C8PQQBI+ahz6DkguPG98qNPpOk9QNwSNz7VoiAzI94DRWwXA
FqOPWDnXmJpAdXU3snCjIMgTZQNZ/sioiQKeSPkG3joAWjZhk4cV41MXxDSM
Dps5PYqCSVILR+NiCrfksumWuLx3VdciCRxAuUoqLZAyj9tM6VdlXQ+wA9hr
K3DdEeat4bKobHRnG7mBOOqIAgFvxY3Zp7tk6vDQNWNcD2s/Imf9skQ+yNh7
lbjMKH4jXDv0YIjb9VSd2eTRp2hF0Iat1Em+duQFcuQogXGJFhf6tltKF89v
VgvMbSrY9dgJBXP6+AEcHeVmKlggfL/MA9zdmioQ4Mqu94OkLh46H8t5VnEE
ttxC7fhKVCbNvBycEIakJJKI5I+AJuxada5zsgZvNMMaWdfI1zeHuIp5ocjC
KxVBsS95Ta0fmRkSIXP+whdH5xJzjKfjG30djVZYRXMfGrt/8PY3eSZa2/a1
Bmn/Y8b3f2Mm/GOV21/dSOdMHvfT6RT56ka6fCG/cjoNr8C3vB66D37daJzH
4evpbKXrozlOO8KHx7/KAdJBiKscIA33R6cDxFrIHfdbYSRP2EzeYD3KbQNl
FK3neCseNAIDDXCRQXJnti3ZLZE5l0/arFulBbSOqmxaUvahswdhRaQw1oQL
RymCm48YQuvxPPs7xjBJQIZqb+w+dgOnkKYghKcOYs4lg1Mj1s/CPBwsWzv2
ZWupFEz86XcdCOsgjM2kAAtVaEbjjtwLNrwAA8VgoJfwWj9yD6lR0z6ZNTOu
cp9rGpGapHE/3kSTCECse7a3VrUi19bwdl6jv2EB1vSu5So3FDxhk/hsoZRp
eHMnOUEwN5L4EgueoPieTt/hJH0QDrBYjA/BVVwzQ00WyYWjcN6Oz4WyMbiB
zZ4c3jLhkh25RHQkdTgGjCpckqrm2mxErmC/8G4kNGRgTBH6Jj4N9G8WdZj0
4WtjLXSx34oRIDbIxq5kjVIq7ATJPChAUWbXlGAZbrsK6bpmkUt8aa9Z5iH6
L4uixsSfRYcpjQIVI4Ni2GQVQ/Sr2BQLCteQUCufmUERl5wkzAImiHyO9k6P
KwImjNwnksy2ZuscDOPnaLQ0QexUA0xg+OlAaHpHFNnz5RMD1DoaRLfYSkeN
kPhIQuIZgtJb0Dlp0xvE+3hkbG/JrMhTTQGINAVgVlSSVm/j7Z2foKlIDDUQ
xrATKtYgwTAJuYCwYUO2auZlNkZhXLbcDp8+pRUYQcFYqBhQ9xsG0JwKvTmn
60HYbCArrZLMftv4l1/bxK+Wy34Dqey3k8m+SSL7TeWxXy+NPSCLdU/voXF/
RRjKY8cX/9xEj3Hj+6ZIlmjs6zR87YH6zn8WuqR+1Xy7f77tkDUH9hsEqP3T
z6lt7b+FvP85MVMNlcHcOSs1h0ZeOlwuqCAcVoFro+q0MbNsBLK+K2bI5jRr
UOeCi227p7N2/8TIA1pT5YpKjfhBRdiT9iP1b7jKKvo571d6oBV8SfGxIsbV
DD5DdIsZOiAba3CFiXiYZB6RKBuKS31y9IgPy3hYQ+Pwgw7kQDBFgbZY5bAm
+CGQSnpBsZz1SEsAaF+rlmBahBKTbRwlvGUVscDUIdWA8EJ7Q4KYRK7fEiBD
Q8tRMdmL4yqdaKRL5JNCYSdamZ74LtvQXOiH62koymp0wJTCDhcMWF7Wg+Jq
cOliiWRkJtiFY80wEGaCyN8ghWuSveL7sBBNWqI3liJycrFweJMqkl+nubwl
STQBsuXPiHy0sb/7y5Bz9jj7NAxkl9C8BSgfWBDKhY9DW0CbA+2Xa/ZWqkFz
DsEwPgwfkrkheIy012cfspbfwe3PWHgvtbxmJUmlhcdUZqzlIaPyO4M64cXG
K7zPVIO2oCKS3HPbi9tMXEWQEUoHUa2WNr8j0ikgURhVWOXW8BpJKuVT4stE
sjZKEI50MBsWWdoCTFQsMPQA6yYm8WW5rNMBVZKUdnR9dH5PwggqsSRw5jGl
Yn/6Xeh5kKPTVeGOpWSW4nsS+lVcSilmPLwlh8wVZcRM1lkI3CzW+760QVhK
T3EAyQfBk4hYhVC4NAZQpwfWAhXb16rkqJNgN621W9I+xbXDXjrX5pCuDmdn
Z+1nAxcG6/HiswatCsjpb1hvJoDLIwCEyAYAGkWIZ6FVLj2MgHXI2ngFF1iW
CL6k4Cs07GQ4Y38H/FON8x7Cu9PQ/Z39tDsLIXhihSDWa0km693Cx9f/fKuC
9htJj98iP/7GEqTd1K8eiR3Uf5fVu3eST99dOQin9X+6Zbs5n2+N7X98cP83
Rvd/W3h/3Fv/9SH2YYw982wpAPCFwP5vSiv49ryCb0os+NbMArp6HvCa4LXN
GCExYYS4WaESFJ2+ef/u7PzwLYUpnByIuN9C/zCFCRisFLGR00TEkTzivOUr
ly34gWJfJJ2Tbs1QzjmIopFEB+o9iaQVyOd1X0Cys8qAA6IlFc4AQUFEFLml
6+cDlUx0KuzVJl2mKJEQAcfXy6RM8jrlpHVE/ZFqV65apTNYV8PofbtyvDxO
sy1Br0DhU6WVkb37I2dJRjkniL5h7GuO8OpT+JdZXads8jmNinYcr8P9ofqv
N5SlT9vhZzeMHY5rSlIvLnzkSrZLpJUufyOqhaU2rRrtUnBDYZmgVwkroGka
tkm+IqgIlHZFgTb3HBFyr7qhE7EuFMTsgqvB+CNn1geEXymS7rDBploCLAlc
R9kwHQYOH4zEiySKhEpBOkGKqwXdZZPUGbvpc9+cIPrkkRPFNa7P1munIgz2
qHBxWMb/8eQR9S6lsjBTuGcWtOi+4BwFs69TSWQku8EGSZo2QJ09gwuNm3d5
Ck4jwmF/+mQKu8H76k6srLPCW+UNXPGSy6cwni85auaLhCJVI6kxR0nk6Ges
NNg7fg3S2xKTeluoCaABe72YIytrqRTFtOgQMlBNwMNm2h020LYoOJe9paSB
KNzcJKm4FIqiFthGPGwz0IKo6gr29Zzaek5V48YIax2xIB68L4BYPNw6nfMZ
86UHnI7J5M/jo03ncnRUjSfjCP/LewSoYDrdB1W1rkBnebOc1dliJt+aftDA
j4hXQPG5B5LAp6o+XyBae71ENUI+w/rp5EOr62I+jF+oxw3fiyrEskcc6HiO
vQ6oS+wt7iUI6ZZiYo+oKOnHBL2o6zh43DpY2B6z3SM8VAmfkktk73K5cQjr
H+MeNvvzxi/xH/4Q73/Xywej9fX4H/LxyH+8iR83L8nhcAjP0qPw4i/PhKho
pA4Fk5Jo/AwUPZlPOEc/MR5lDmwewen86xHm+WTXA4zJS3IhSgf/llUTYLlJ
noL0FUVHVEyxRtiX60y8bGtP/vodVy1L1WK19tfvnmCNr3cqf6H/GfabdGVC
02Ap7vIe7zZxutVYKQ0aXfvrz3/9Of7rL3/9ZQ1OzhIxZy/LRKEzx4SbwrNM
Fd1f2AGXJLBFrt11jVz2fpFGxSL5T8J8P4y50OAsg9vj/PcsLuQebIa+Pefo
fz5EdmPP4ZVnkazRW0L+q/iwMLkr5TBbxaYywXBiLCoh/CWMdX99SFhes6TE
chryZuTe5BUTeiOCvso+ptOB4CcCq8pSfw5ifz4IOCpqYJ/Q8AZ0EAd4EKU4
PZks0DinA+Sz61mNDsuPCCsY8cp4iZDmQ/8d7f68+cuz9ueb2z9vdX2+tfnz
dtfnu9s/7yPJ4woxUfdjFmeQ3mYVMLy09ClEKmSJFa9MfRlpXgFL/nAJObJf
57PAeUo8IM/3fPzsTfpR1nljFG9sxhtb8cY2yjoYZwvjSz1CDyIrzxMZdTza
fbrxdGN3Q8/Vj1LxMEIcG/w17jEi0GCazVnxwP0ry+R+nVEVmVORL7mYF2is
RJsRkUnKiUYV3w/EX0WqkLbnJN8Z619Su0tJUHkxxQOeRAYaARG4J5dwxuAe
wn/m6RAEfZWOJi4vUygRje2UxUhxQAyRCreksGctIu6+cKPu6+7xYEVo4kuK
8CxpLBTXnFAcBtJgHw5gP9Za4Ul4JmTWcubpFAcn9+ccSeoVEA42ExeTyXKB
hyiXvdXMYQr0lQuC6Szn3uZ6Q8kyUwkIlPfFzCrjCDfBoVky4Ji7VXJETZ5K
Rz4L1p89uXf6qFwv55YlsVjFCdBo9wbVhaDyeBqEU0lmTs1fdaK145F9CZs+
FkG43RZ12sd7l8ONYqwqWTMwWZ7JHV55HsAcll/Ds86fPvlOmg75Mw/0uyf6
Ms8QB/PzU32VXt4KxrQltxwfInw/+hGDyOCuCGkgBG+6vA+ICS3pJRdxviL4
pJlCpfc5YLqCvtAq7XUrvebjv/4BlEwg1uEkzRCK/a9/Ek8XPFWxsiUby1lj
XJ1OCUOAYCpDHr+vFP/f0R/NUcjCkFWkmYAuEq6cc9yPnC2zVRWDovIyJ5XN
0AM2MiMtKnID8KdeYcl7Mr116Ru9FLedK62x0I2ZKgwVK+JZxZhmMgJbnk0O
f3BOG2v8p2cPHQ5ff4OOqIyKOAQVPdfUI9VztzY2KKl2e2ND1kf5hcgImAmM
GkCOAYuuShnvRMck5YSknIApXC+Ry7Dvq4IaRxRFvWsaNJEC3RUwokgC5nhH
K4qWG4MKMkMtsa+lt3B0vgGupLdvphMxzCksA06SR2LYLuXa1Ho5yOxO64op
l5PbZjMHkp1EMDE+eF17DMNYOJjeJjv3DBE3nA9GpJeTlqRH6QtVqyZ3NS+7
yhBSV5YzHKIkHu1ZloDPynTvKE0OT8uMjvh6i1M5wvkDkMRwCEv1p2ehDA78
J5gq7OKm7rDXxpmOPS+TAfBe/QFa3u9smQ4GLBlu0Wh3gJjoTkokcIRUOByK
DSckh6Fsh6JDUBS6WiRllTYkTleWAO1OlK8Dh7ooo9S1M4xPEKaLyyqrEzAx
GjhXI3mHeSP+LaIuZySg7oSMkkrGLmDVCaWxMi6G2zaiAzMITwP6dqLGIaww
mIL2QrjnHeG/kTAAPB8KG6Yk7tNBXUdqxiVpT5jzfSSBgb53tM1wgKsMg/Ty
e37NUxAt56c4HfVuR+v9ON3s3W7Cv6ixwV957xbkyp9/7se9fP2XX+LP8XkK
LOwFB7IaAzOqHlMt8Km5hHpn47ryBUahwSwED6PTRnq5VlQ1thgmCDrl1zka
yrRcm2iHUvIXrwCz/bJmTOkVF8Ijs+ZdVpHilNv1dLITXjWItApkOEk7bjCC
0qSziHl1dL8ks0hvZrYkirDc1D3M4LgFthw5+4EHl8Z4DqxJfu+wzYSlHxWz
or1vQAC9LdivS+i0t8PoDXXa21uHraI3YLfe5UzaBuxEZAilUQcfmlEJPBd3
XCeUGMp+Z1zku2xaBydNXzQ1zS3KrpDxgyLhOdoJmU/L/eOvnw45Fm2tRO2U
BwaDpRdunMFg1I83+cLQl7WShoGitOTZWtMKLte6h6cBwxx6eBwuUfsqe9vw
a29rc2NjA9eXBv6MdWZMpvSH1RzexNMamaAJlLNYeHsnK1oiDFOpnFPrTnbL
xEE+9/F/wrXFEk4LP1MibQ2Lwj2z3burhKnpkkh1jEQvzYZRFE7WYltzVKOC
7zzazGsUjYNAZr3hzC0q9YSVUuC/fzT9PtPbA3N13Xt9kWL9HRS+7990t48k
7/XlyphLWQS8b/zOOL5IYQH+DhCMVsN6mGmKFiQ2Az3WRHdqjmAQnmtJvTaW
V7xPuPYpwVxU0hafNJfGiOsJEi7JqEnu5VUntpv6YQzFj531HSI+K/RwUOC0
ZQXIbjcJonMLGAu7DRYltJYt6MgDcwEC0ng6hAmlyjPXaoNk40MySdvnIZn2
NoDy5+lNbzQcbu7gMUD8g/ve5s4OnoQ3RTF9JmaBI7rolmQJp1pbUTR2hQ3Z
9iL37MQ8yUEvigkuz3G1CKwrkiGZ8z0fBRYSr7JT2klf7zwpQBaq4aGEgLw+
mmUfJFkDluDIT50HFn+yss75KL4aBdLP+WZ8tRl8Avdm8EAeX+XuAWAZeHmS
ni/FrTr1EEUeKgWwPvCNwX0Gwl45lYcjnh+cYl3kKv5xRK3/uOnMEpqeJNxE
4C6NVEKpFILHIt07f4yvSykb51mQHxYuOOhfSPd9RZSQpadL1S+0l+gI9NYf
xiGWQjb3wvBqk3kcShSRYXBOI2M2LrFHTAmuOAzQIpEizhsXXcGc3KJXLXlP
bDByUnlua39cYzdmfvBl4gAGtf+MmBIMfsQioXjboZ99w9Xa1MPEwZY12a4o
OpaLofKbi4MmTG63qS5ejpAnUD4COflasTKqyC+4uXLS/DYri5xD2NhpPGsr
M25zyGrKLSpuNi1+AWuHLbvBMIkqwcizcnIT1vJr15u7LypHQ/xAUmuLv9da
feK6c/EQ/CkBhfEEPF42MEbPjqUd0lsF4yhCbsrmQL3pUAMVI7PYSQOH0Uy8
Yb8Jg3iAQ1DLvDS9k/WwdfwhWKV0dABi+AjE8qt09Msvz7of2sSHNumhzY6H
muPwL+b4Yk4v5o0XP1tqvUVe5g/sQfPawNsvpYujoKsLJCp4TWj7PLl+9uBa
iurJ1oNgEKLzctlRVEpHoJPimdODrZquP23Q7ejL3W1tfrG7n0cbbNOD7phX
dPW1+XBffgmI4js3X545I7CLIT62ihpomQ9immHX97z4BzSqFVsZdEZMyKeA
OGzxJp6l0+5Mkl+Yy+jDUDzoI1lALFad78jXfyk9RJiKthjDYJE/xJqNt8K9
miqTRbWc2VACAmAruSgINPB+lmSSEUk1DrjSB33g+auaudBRq2h9zHysG8YC
eziYJFEzpNaLreODKijeScEBsbshsVIEwoeaR0gSvqYgKiP2OxB5LiSd8YLT
GVFHsU+k+fSiuLrw4X6oJYYPSGTOhVfne/vhMwaVpzcarfzuQlBieqOt1c8w
qk9v1BiGot/0NjfCLzBikktF9DYbcxOKucD4/R6JpfZbEk49kTtCO6cz99AB
DR6N59X1BZ1T/ArOvUlHx6/DO50dhMIVrKJCrzqdVtGHwpf18Lv+h9r3qsNv
6ebAf2cCebuZgqUp854JUFpxqzSpiV8OgzVXvdqms4O4o1hT1f1+B51h5+3k
xS++biZsX/9yt0y6B433OFuo+22l6oPwOw1h7X6pfajp9WbeX/fL/rgEfX6f
3nNhlJWXgCM6OBuunoTjyQp0aWJcJaHZlxXBROKbdOBBGgZ4MMU97+Ltyd7B
gMYVO/RdYYtCqldgWYtDAhcSZswYR6TkteqFSbzRMk8/Ljj+ikNCvoh4s+Zf
uZC21hz0zduuopgmmMHpDMD8qSZ3EtZogbWAKzUZhKW6pV7H70J84DeaAUA3
bKOYmrkT9ZYNUSl9un+ySAhzFsRpxRAwSFsmKEzTI7qLWZgqTqR0SfAqo+zp
GGxliu4sB+1TUi5+h/pYkPX/1pc3iiS/X6DMgsds3Sa6kNFsEyITUrioKKKR
tzBeFUss4Mt2ONYbiOLQyGk45AEX6dPaimERvC4wXKox6dLFPFgypvsgXLJR
PhTpUKpfDKknU1yHkavWEIfXAzcN+FPELzZwtR0D0bw5fj6KV3cspQxtEl4v
xGJudaXxiVHs+hGIZ4poKDjYAsPoeOur1NX95El2lKugXrtLD31prt210doz
JiQTwsaQcTSho3sPI0Y3RhE5wEdbFtQDZhNQ4tRFcbFzooFFQvmmMYykMzem
e0T8xICegGFF8ReWp11KRfzGbOIgz0LsMonQ0hPCiZj0WJJBkgaoCBujOf5B
9zvSM8XyNwItUlJYfVNco4p+YDvAFD7JWaACizPCW0sie9zQnxsStavxySlp
SHntJNGIibujgtMTC9FJOBaNpDHkBensSu1LvGMKtVKKdYAMvLNk4fzuzPTo
Spp2nGYHdC24dE0IugDw2Pwd3lhR88aK13w+g5T7IRQdvMqAPJ1P/kJvBH+b
hXvtFt/scVab9FZHA5jrFGb7UhFTh/iCuEmuWgHVnBT4wWglsRtov6RWI0uf
AUNmorBZGBUBfo0U+BW7xYebsCvohFLSoRlhXoBunMLItxmvAdAjH4A4wq/g
0pqZ9AVpANvkztFNbXNrA0skNkrX1+ql76JzwzMUXZduNjwlAik/S1ckUssQ
FILHXG/9Jok1M7PbIFnAkEgzGJT4qQdsXjc5S415LSeoKbOHSidp1pbQ7ZXF
iFcJptXqmtJnG4xfjHa2uY6KrEklNz/XkBJ8dQwyJhBLpJN+68SR01EAAeL2
VdGJpx6MiTNtbXdMQI0uLWB6G3+6lcPMhn8yG0to+4Ajs7SdEPw+mA0dYEUY
oll10YtvshM0wYyx3YMgPuPHFkSh1wAtXu9Gk0Vxohvmd93Aeju4py1cHRvA
HAfl9fq+MgWuP+VLmbYjKkBrlpIzdWiPCgwFk0AGba6yoQqgsESxlh6tMbJb
ce5b5J8R+KjELNhSdKZQt9S58KYwn9vy4EXTRkX3baz3I8e4V2k6vEDRyutj
1d1BLJBvEA3l6iru9jvy+fEYOcM2CuEytMofWcMEeY0n0hfmenbybz+cnp0c
u9RwZLVBbYyKZHZuCenC4FC7BfLUrwgfpoW7xsG/oUBCYoOszzR0AvVgtRgU
kaYk8DeKutA26PjJCxw1W8RLCu5BE9/NQMHKslbWqkgqbxEV5tfmnUCtXKJV
2ZQTV1luF35Pn5p0A41Ii8hKQECDJ3mNASge2E2veLqsiHmcYd1d7WjNG4SC
G/7TJ/qCAAcGykNZzoarHG/7u0RKb1M2anzisvSdYwZVXba5UjGi9o7Q2rkC
rLCEk6L4kIW3o+vMY8O5RN3uFsla4ub3wM1w5arAXN7TDuBdvfSvFpdXy4pW
T4w5F2xoQBQ7wrUQP3/ENYd6PkpnnYsbCwZEfi/FOtQ8TRCYTixolzPxZaTi
QKnlSs6m4CXVWO67zhhnzpZiDmPB16Qq81qglDD8/u7+Dtk4tFS0JfZQI1HH
NteR9O2YKrW8PQKayBgqqbU/dW3cc8nJ03RO0BgusykedmNHIHycxPICU98G
K0oQbEU+tXangB/VHElHU0QvYt/Jz1pJk+EojA/gUVanUzMsC8OZcA5nszUv
cYZVdqPG2HUx7BzIs99cFZkEiH2JrL+XaRsFpIgRwk0ENL2cJaV/GdHS/RXo
wRJ9EAjRkYfgP4iC5JvRrnM5/chdOSOluOI49fbnLczOCdNtpHY7Ujnm7uAX
T75rmJ3oDHhvN4YJSRtdroDGUJoliv8Yb3zc2NrY0q6ocjaCVIaGfUkW5spc
Xd5FaVatvtkU/Zpbm2GsrZmdHOgLtlL9YXM43PyP0e6g8ULYuCnBDpQHl9G0
+gOG8/zH/mAUvudM8SbC8w/70od59nPoaIjCxYkOiEQaJKpJ5QreSV58ZMyk
yaGC31H+XHijzWYiSSe7vkF9xb3ByQMtfVvU+ghnhtFSFDN34/CqhC3l9w4A
R6LCOH3eVmeHJjqGh0FriVbRWNMHgCILONdY63nNF0aytT9gQn9TddDFp8YG
xL4tkWj30I7MlhZBig9l1tQYGyk6EFS8foVSjw53YUq1O+bbWQc8uODdAwN9
QEV/vjk6KnqTEhqzN4EyCPgMmQQDitsIN/WKfbaIAItT641JIkUENAQcGAQ1
1z5/lnAvYGOzCkVjkLv00UZ5tvUo4mMJ5LolIfGKoyXXk5bI1pJ7PCB5BmNy
0XGGownrZQ0wQbSSsZgod1OOZujOjD/5MI4fw6MCK3UlLmxi456+k7gLWhkv
zZQtYbyiSOqXqE/M0/JaE9RDVGnZ86wyBCZSfwfONOZyHDrB2/WRaMUdj7kb
xbTJtIxo5HRz4AMgaHlEB54dkP2UQoAoPvU0Jyus2TU2Q8n4XOE9JDzTirqs
0GhDiQ0oICOIt6vbUBjXQXN4PAFqQ6mB1GkMYN/aNCnKEm3JMWPWhiTkggqn
TPMSj9Qyx7TTbOLKVCS3RTZt1Vq7yj6y/FlQCJ4WEeMwVNgb0nTY3Iyl5mC4
KmetI0G+U3biL2Y5b7RPlLERBh2KOmq0AXqIJmpTR1DpC26f6MDFm3oLOTG5
RllJ54Np1eTQAIi+T3/VkpwS9LEwKB4OqK/nHVWxqcQuwxW0B65j6QPsmfrR
aUMpEei041Iu0AZ7NAtX2czzRAe/bbWnquEsomzFgMEbm9ekuM6zv2MAL8+e
DZ08tIYlB9qgHZOcB8ZmCbsSSEGHgAHCu6hzRU7hzkhpCKEwjH/kMGKbRUhu
V25wwA0i8nVYrYWA+hLQvPDs0wHpxH8MQC+nt2h7wTusxisRSSFPG+qHtaUl
8SvcHJNxYAEXPXfsEF1Ws8mQRZpXfeNa+DRe8aD0YQvgKHukMyCRqpQQ5O1U
DaMr8VI6WrSZmrxHCWLoJ5Hcj77cgnLgfKnXAK2eFK98OZutdQwU/c2xVARq
iFlDNit0agAVq6vsxhD95D6oXBZMum1Ijh/2r0u62oWzV6miY0q5+dVT2WtO
IIAyLgf6jhiSND8zgyr0VOL5pbF37SSp1oSKKlIb4WlOWIky67auZ4+NyWLX
h3M2XYrrUw64rZcTtOAWvmvR+Riyw5CKQsWmCnTSFJegJRaNhJO1hbGgnp2q
x7QB9OI2tt4lKXuLDpkfM5REvKwPZ+tI0BpLVzej5szIEG2fTES6c5f3WhUL
BqNQMNi7yROT42MzUNecurEmyB1MmgGzsiUxh6Fku6R6mwWXw+QT5rrLKp8b
Se6ccPj4dXHLWYqFNWdUHOOQMj6nPTWhHEJLvUrFYcGQ18by82XuboNpUMZR
q74RUkSDuTE2cJK3FpMqXXlrjqfbqINr6vp3kGbkY03YXu4ZluuwRwkr1E+X
ZtD3WgwHZvo0b58vj1glcqjtumrvIF68Ku5SMg+HwmKTNXS97aysmJvZXCjN
MengkhR5w+dnQgYK87J4GjHqZiIyi0bgcH1dV8K8TCM83qxD+DgUtgSt2Asp
30DAM5KwZYvPGFYpNhNi+Ii1ROOhG19D4hl7jNJeK1+WI8czNRO7ub7tWE4z
BUVY/SUlA0aZ0cs7KN/curbMb+pFjWHU3ESG3JJ8K4G55bmB6jD5IFZ+ZHiY
4BeJBBI6VrRN8Qc/rKVGlAjFBmaqpWaugKTBtX1ZPWItib3uZHwOkkKDwhRM
RGXCvBDMHrJXPyDBaG5/VtsYE7h5M8sWYoacovXWph1tSXG4uunFX3ktx2vT
FFPXL9KyLEpjeRROfct5/Gjh9CUl6QqorA4bslHKlDHnTSs9toqzKFy0ujKC
eAhGmVBnyuG/d80Ck3dpWW35xQ5GENg77hLyHpFz0ELBFh3eBO9agoX1mMFR
w+MqLaMtW8PC5elmfZWo1yr5uC6AJTguBb6ig4qR6K2gQ/GxSdFrnuWn3wVV
24My2t6nHVSwzbQcPIPBJV2rFnFgH4bYeVnZwBxficOuw9OZG7NVJL5Okyvg
XfcBuHdYZusxFuL/STbai3RyU3yNoTZ4iC3WK9kDDvvLRtndLqNsEMX9TzfK
utiIDgNe6BMZxj+gKaxeor9kJuYZRMRWgw7eokk2Y++t74VZoQESaFs68Q8f
eNZh7XSJi7/eyNmXBfh/ds5H2DkFVApNAilJcTwANUxh4MNdiX7ePIikpuVD
ebahuhm1kH8dscjCG+qNIWEvPDFXAtqnKWaNpTCKLu6wvA/v+afCeEaxeFl+
pp21LbzENyKG6nWASUHANhYFb76lorsTCEkRdacVASyhWdQobtNcJSPXXLMS
OYlfSMBqsu2yfrbQRKkOH1qjcilvwEVvl/O0ZQ827sfuBRDIoZilDWcok9K7
IhdZd2+ITv/l8P62+YFCh1nesWxZtkJweQJblWNmIVE42ZoMSWR6sFsfmEcf
Whnbl67EnVRJVgzkb5zoygsGZn2ocyYjL4+OuqP8YmJORDYbTeuAj5Y36isf
cRuTR20RTIcCMJlWYhPJYDG9fFZC3coF0IqGeCid8CEGmbaDGtVoJWk7rDCp
RdXcx9wFMMcjyfLrbNBzv9m9MUuJhtAZSYIRWF0xP1zuD6PUtCKJ1gJBM2y7
0GBYk4SjL4wSQTmV7MBUAAnaFhpURw6Wlz7VKPGCgCOSSiFrO68ZrenqLvCo
20nTEbyh9odGeQzPpMWUZRaeeT52GYn0Jhctvc2I2ULCwl7Hrw4Hmzu7aPtd
a41gzaUwH72IN0fx4XG8tx2f7MRPD+PdUTwaxc9P4tFxvH+EuJmjk3h3J36+
Hz8d6Vub8eEmPjbajfcO4+fP8cmdk3hjL34K/30an2zGR/vx4X68tRU/PYqi
HxbkuJP67QjKKEvAwjdmF9pEvX7TScQ5Th4nRlOCLDY5gyddMUoa1tmtotr5
q/rOh5DVzQymeFUQsBTExVPFTr9pcZfDCZ2m1kvjs/FTECOmBi1SA5REHnFe
tKadgLhDU+enK19EgjxardFIMB7zzJbYwdSQlVGwUg5jnSNxOuSNtknq1/Qj
BEqPOJLb3o63X8Q7e/H2Sby9F+9s4icboxUjGbllWDEk3HUZdKRfBM7WB0Yb
d4w2esxoNyJPGhNnQPbkbXmm8QI1dzZqWFu6R6swaCmikdDFIYWKNBtJtQNt
XkdkK7Q9spPIdcIETCgk4iK5anIlo3H4zYpoZmi5RncMCzmEwb3U6mQ2irTj
uo8e4VZhsdafPIl1rBj6HaTpRbsWgj+8CjZfqNgLo7hNRRTzgZORiEKaw+rS
jg5iBcT3C/J9eq9pjn3P3yITyNdR1ddBJNmcHhoVXYeixiiUsq/j7cBIBAhb
EvF93a2C4xHZ52y5j7cbi1W1IDUEcQ/x3xSktDlV/GaBzadjDqNTI7tq2H0n
Q6RbHJEAQI45Gx8qbMLQVzpXH7pkcZGQyaWJN7d3sTZVRWF7C4R5wioHFLLU
oO7I1vEy1Q1IogtQC2h3CUWcRURTJsJUHwtDBL3V1/rkqM+WbNsleUm5uqDN
LyXqosjEkp1KZM5q6W3j4Sib9EBLb+8sDIaJfMwnrAKscnxyfHr+7uwgfv/6
5HB8Ep+dvHn340l8DhLWi3evX7/76fTty/j94dnhy7PD969a6IVoki+Tq9rb
VET0oU/VcKBR0EWJgpDYuRqQVsKgMJDSXfhqD9OjXXgQ62Z+AOVOgzaHU9Kk
SLG5cIQafiEkQkLmLRIT/pX0JYpeK15EnpLhPTVLxD+pbdBc8pT+MBUDEoP5
ES9I8oi8PxhJl4iQKOkHmj3AtEGSWKzC4G9l0WzZLK8ywhGyUXat1AxnSrAt
ulOuCoNBwTWmjrhhQ41C+3V8WIWJY58+BaZcqUDXlo5vEiMUi5uUpK8ORUTt
72nD+NdfoYr3Ayslv93WG6PAb1V5JVHK2CVocRnGznvXQG+L79JIZt5hdq9v
ymJ5TSw4SPCh3A/awztyr+HiAR1PamMePzdCpdV5AvWuU7FLsDaPC7w0Cr4T
lcQN1XRjw2nC7ktXV139FrD7PlxMoQkDysQ0VCIDYm+BNtORb+JjqnUiyPSb
lb3I40b1l1AXiNR0EGbJtzPf+97Kz3ko7AiLjDuZdFZNqBCGxn8GydJDq8ws
GB23I0OlJeiQ/BW1LaiPpNSom1LVhB7cdx1nTY9JbkOpAj8W3NdlzTDShHvq
3b7WdMu6eReFDV0gxYO3XPSQXKciZps2GM2Tw8uq5YwsUUgeIkC07WYSDeQc
e+6yZpG2g/xUZwsLKWmwoMNgCiOVOV8L86pbPLrVwzpKcN8I1mGCHZsEphuL
OAU2LoTtPe358jXK0TYs5jOYyjRcxvPOl00HQRpLVoVlPVB8pJSvjoAeOWOd
Hgd8hQ9f6yjiV86MpN9afAdy8ap9qq/MoGNywRoaUYSYCpFXWGm2aoXvScil
pMdgXLoCbOKaO5NqkJPE4q+UijUDcPGxErAAMgnnV6WcfJLMJL7Tgc5UvpAQ
Il3itx5HWOg82MtH2mcD62z0JevssBH6A3RB+Keiad5HDag0Ol+2N5JZrfIM
A6drn2DyadcC8aSXdSaa01LadkWMYKNRVaeLSJYmyGeoOV9SRTkEe+Vc4QKl
HIrOXR/GyPIjP8aWdW5ieV9D1Q5M383cxkCbNnJPIvfdg8fXZFKsZijRajWa
BQpnNlR6dc69VdlnnSKGKanuvFCpVFJuT7YvgX6dtoAWIMQj7gxx+9B9UA0F
gN/b4EFT8MVsTGKtD/6qk2uJDBpwW1rrxdY9deB5w4cd9a5nwlVzLVy0UBDF
4+6fwMAJ9LS3nd2uzWcPwOuJFRXBaQmQ8qGfJ9+RgrS7sbvbiBCYJx8vrsrk
GuXSC14UQgn/ulbQBLCsHFTezkPDeaCVBpJFb7R6XtLK9vbTzX6893T0tNlW
B1IPQfh1t/Xzz4GE/ssvTQi8Kr2oynrRG21/Yand0Hb2drcbrdyABlpfpklN
SIGPamV3Z3Oj0Yotwkq4kRfOmGD4XW+0C11IK3tbG6OOBYKVtlBwmPUJOzmH
We4Hw9OxPN1tBpgIVl/QChB+b/S0PT8dy+ZOc0ZCyq1WNjv2f3UrksLb21xF
vx2t7O7vNFsJfFm97YcaewThGIzK7c0vn9IvNdfmxr3tbqJ+VHMsavW2v0zU
j2quGx+nt91F7I8ZnaEHhPTAY5xhe3udZPGl5kDiurjKZmgM6W3vPzzjx0y2
qGpTjRkH2NvuIPtHNtfFsOhE9HZap+ARzTm5ubfzxePwiOZ6uzs7WxZ5NLj2
pGobif9r4RW45hMDBF3bpVebcCSuERG+zcALLojUmqNc5pgWZXFtBun70uq5
T45pfCmx9FkuwsvX4x6ehN5oNpMQXpDKD1PNSqer8YnTHK9AhhexFI1EEUWJ
NZzbf1tWLrOVo5AlYNbHvLDpmdu00CERKnwcHubn7KJe21q0s0A2YBWpmajZ
DPfXhVnU73K891dItRZqx+PknDd675iAyvdtoFTvbuZADCd2Hv67gqMg1bCB
omsAQf8UsevgV5Z5VVAdDlBTWnp3C8pUd9ZqfiZ1joYSTTO0pXHlafLwoZu2
YYR31jIaRMc2RCIYI9gFlV+dLorMAG45/JaQbNrL2o86bWehwSzA5+qAq2gE
AHBCkgnw7DMIv4zxS0aSaA1W3V16rpFQr2GTt3rQLdCWz6Hg6qTxdYaRZH4O
8+Q+YteArSdoCqxKZcGD+OhV3DMHBpjq+FXUM6QPn5ycxL0O+odvjs7hbU9t
+MlZ1GvTL3zxFlak16QmTvx8dQYvtc1NbALLG6EURum3M+aU/cykb3ImmQvg
JJJxJkYNcTUeCnmyloWrHhGi/5CLN4r+YQKBv/Dzj9jnoMFf0T8OBo/9+Yf9
4wBetSpU/DPIg6iT/LKqV/g5ekVbjK926E3dTbRfDZWlBzr+B792dEbkQ682
NCR6GbWf5ssdvXbIF/Q6OmJ/6X716IxeVeWHHwe1pnONOnt1Gg9PE5SZFe+2
X32cmsMrAOrNL91TXqXi8HhAofmlc6FX6DXcG6gev6we9wpl5jGvigbDj4Jq
smqd9VV+nV71dlIs090U5oJXscMx/B+YCfcaaDwPvG8GPOZeuwX+ribaI/aa
0ReG/A9ZIuaMtDtsL/7CTN2Ij8xkO6zT3c2012mFOvLAbM0ZMsrHw+O2CyX7
01Y0uptor/FKpeIxg2bMO2d0toURrxqFKF3pcQY+DT1OLEWx+93Wa1zlqWuF
kz4EbmwjfC/ZbcMBT00U0SAt55ykASdYXaZcT4Ps+pjD7t9W2AdXT5OkeZIi
jBmU0tmGivgtKbw5lYdyUXYN2d6gc1HJKKwl5G9Nincnc3lmYVAIqBXPmHFJ
bwzOzs8DXFJyXxVV0EcTztV19SyeZ5VEUVLul8QtR4zjg+yIexD/yyrwOxbF
ylQqnVzWQDI9imlGcaKQj9Y5bTaZNMDTsF5lqY6lyIU9K2YkJsYI/AsLK+lH
cplf+0+ZDngC4jfEal1wAOjMkmtwumRPH5ZRuSVFzSHNN4tbhroegiotZ9MI
q3rDmjEOEoZbFEtysaSEuYF9ocgIgzXlIFCtHaNyh+CKXhBtgmkk1whDja1a
YY1QqDGrkdBici1GyvV1G5KWlLxFjTnLlyhikuMPu04IYrxC+RDX52pZgVZD
0JSC22G0cl1RAkMThbbvBkEim66Hgx9RIRFVdA200xwOGyAbqOdeFZa3Z5gX
W5IdwOjV3BUnusPwEO5QYqD6nMLsiyAidXPc0L1EyMWSVELVPik4Le5Bbwif
A7+vs0+/PXm0BMyTPFtg7R1hAz5qMQ6UVV+SEMNu3LowKVFFy+uknFJJV2jF
ZFZrZ1HMkL7AoG55HhJlZIoNlQXMl7J83l3VCl+eTGrve/LrairtNYvaZ/li
WSv2RuRrdjjpXjyLmuPuw4E4LB06ASUTSU3gXdMUW8cDIBkLfhjioBHlIWEc
lyuvkdk0GJNVCSNIcZ7HvK+Cs+w0G6wd7xc5uUtKFwfv1wPLoM1kir5phxhl
wdKRsMKQSk6Ol6BKnwVB+MAZkGtZC6xkSoFmjE5qr0cNARs7GBYFdXnYk/SN
lXKaT9BPM41UhR5C19vZ/pN3MAUNh6V0nnzHymfLhhPaCFd22vQ2rizX4lZM
F0wK0X4hmVET+sPQoNoHLUd8OTThJ7JGLYkGkv2q9yX4jqwFfG0Yom/VVYg8
Go/rP7PIdC1haA7ynnxfUjl2zb8sCaq3HaLZEYxhcXvhQn1IGgpgcztAOlzC
3L3UD0upeHiYK91jHt4cR19ueDj+iHQhOBsR47gIIMPVyszdoFgog115iabP
aBzqgNbo64SL9q4rnHVWhYSidREZmCtIy8DeMA5jRqUVJc6xPSNvK2HLoNyg
Kudx2E9nigfjMDQCuKIgGlrzHK202sjDhREJDg40hqXh4MZ0YRndCAPxspmU
0wRhbARVtnvoXs0GeG0QcROkbqCULVH00QNzY3f8itxsn7bKZcY5kq8zRM3a
+W1tIbGNG1jIYRjSQq26UhEtHA0zWxArjJimIxM0HC5UL1XdlagZgcLrSe12
msgokY9FnsM2kqHNBYA3UNl1rA7sQwkvu4pQpUFp1rA7LIuMZeipkGInV1Er
m+BR3RRFRWAKTmTsAp1xQabhqTAU6s+rYyMd4DcuJoZTLBtMDPmGwJnqE0Kw
Qojq7tHRUUqARl6HOVjVA3gpugSU9I4R1cbaO9SX3N47E3294soyG/3AcGyn
zmXhYahAqfkCxRt+ztdZA7uA4RZ7vGJoO3Yw73XTm9M8nw6cSSC8egwsvbne
iAkV1Bu9E/zY3NJKDKPW47LltmygVC+ZeS/KvQZu3RL1MwEjCwgTlQTxkAgr
mYZS6frwQUbWCO9yWIVBF91M69uZU9dmKYDhlxrqiDGz8DvKTE0KtqBUarWx
suv55kF4VFLXo6LRUEL+XXxMuSUqJp5qFsnDmSunwGROjs5P371FCxViztAO
o+KH+Ww+ok1ac+olNto46cTfYJio2KtQ0gQtbefAdItczPkiTEBDsvO4kRsf
9642NuJ/cDMOtKSr3kunlP2F9G1KYs6oKPgEVBLOzBntSSD1pY9ukyhJHM5o
hDYwH5yqqTXNuSO7T64wq9pfNVyAI5lIMGw/MtgM99KrD1e8DCH9XXENsuA+
rA9JwBwbexnVuwXVTd+BlsC/VMxU4/oOGQwImyWozssSrsyU7TCHFr7My/lk
HWjoDraOfInTlUQfAhDFZ7MSjZoJ2UDzFLosP2AsMobrx736ZqnZhZoFnVSC
AnRcjAnYULPo1ocuT44Hnc0Qfiq9Ws6IdtFY4cPUBwVifXMFBAoQ5gtdrHP/
B70aW9t7ilySayVrJdr14QPrALxhViRTru0bVnzDo78UesEXs1orm1D+fkcc
vyQfVnAEaQkQipxqBlsHO6ra04KPE5Wa0MeZpVSuQEMD5r87WJVJBRFmZHU1
epuMYBiWS45iNEFek13FWcVxWcjc7W7ZVZkeJjLAVSTqco6LjUUIqldrJmRu
jN2ywoRpG5fLmY+l5hukkRITSZkJVnQciC7Llc6+3lgtoK5gYjgotFCuio6X
BKOF6NINKBdrvROQVVBhuneDbaQrAgc4OvsuNMsHMoSqDBM52vxSVnbVA4sp
de2ywp5NaiBLflK6x5c1orQ9RktFgkTTHOJG1GI9ZmGUyq96MhLIZtDnyQsg
7i5N3IGLIKhv5PH+JOEiiGqHoxohBDm2GFQeisdZPglyttQd3zxEsY9j552P
gpwyMwhX5rXgOG3eNa/2dC5G1BB/KsWs9sYtl8R86DxLPlHeJWkjJ7aYlYXD
rmKYSZR9fRVM45k2NR4J0Tq7zrB0k3uW44Sizoqc5OGy9Eau5JSvM9cAEq5x
6VUu8mlFlU8TwMLjhm+uM8ook0AIHqpz+KzqtaN+WBj8RAkolEWPTwdj9PUM
EWDqKrKIvUSYKux0FI6snBGHS2ciZxyaFG1jBs+qSvRwzOrmhBgYzfvx2Eyl
HwVxcgIGQNiN3WvY2hcjeEe1VrP60vLz9DsXV/aB7qdw4bx+wnuHXoMybVx/
1i4cSbJXq3acMa11j1Ty0cThgSv7hWp0zTqJN4lWLUU2303iATnWX1tzc56R
5tUKp3LVB+rM+1gr59x75K5iOlEylRpkDPHbxHiRg+8so96brKWNDdVSzm3z
oMpB411Cs8RkxliVNMSZXBW2fPTQW0QaUq4FzxC9NApVxLaBRAtE2HThBUYH
EgARYTqQvy9CQaFAKM2VtN1cQF3sZigsK98OCsSi+TrVLXJ8eTxBfIfXaAgh
BdXgTbZzSTAcfnw4Hh8O3n9/NB4NbkcXO3YLQkN/WSUXiw+TaoRe+s2dXTQl
bG+MCDyw+6Gt/W18aOfBh3ZGm/jQLj3UGN3J0TEwopUjSidTaAnu2gUMpwzH
tRV26R+FQZXh6FY+urM5KsMxbrXHqCs4HgfFnAlNe3k5k8LK706PcdoSJYjn
pWNxq+oC/k3NPPY3tjuWzjwnk9jf2Hn4OZnB/sZuxypPH17l6ebOzugpv77X
WKvp9vY+f7P/LUtjnuxeF/y/XZan3dOVx9yqJA8+5hblsj3214wk8rjTMMJm
NptkLoTkvu4iHoZlB0kRq8C8x9jYZkdwzd9i7BFc3tDMi5ONjeEQ/oWfsLee
fGj8aiFTePag2t142ERMdTGvrjJdrQ6RCz0LMGGIBaFwC3wTLtLG82sWdYc9
zckMjXn3WPLTPewkzzUXmuOEL/VaZZV6aEF0/SlVJwTVtDPs2G8vtGVhG/DJ
j2ixOkGLR3Nt2PSH1ubKFZnpEr2cXqf6oAjvAl5yS1IgC3+3vrKJL2gQ1HRh
+2ZUXAWlXLznoLNqOMWtVIQ8gTEAaJ9LysusLpPyXmHSHdIGKAQuzRnRKa6p
SOhho0J9BC8baED0vhf+eeOlN3njuD8EWFIy/MeND0tQ6cQ7x+h7P4MQ2IAN
WlwOhu5LNHLFHFQuwbG4LwoK5K9qH+MjUQloGnro9iN4YQ0q715cjhxvN0K+
vf2N0d7nz1HsPbxhHH5zmlVYJeJ/jV+N/3j87nQ42hjubmzuP3l7Oj4fvjh9
Px6O9jcG21g74tyAgxFWLFbYropZypkFRv0Qz6WzFgSCFWmmsYeUsBWN2TLN
sV4c4CPwHDpYFNPwdKEqThE5EUdqt8C/EUo9sOqH8YHd8q7gEj8kQOEAHkJw
dB7aqClNPHqH+cVPn+hfxbUJdhPjtJYl41KZbTx8Oz6N//x0uLsJb//56e6m
AHXgNsaj/d3BNnx+PB5jm4pzE389nQgtmBlIQRwPNE34OscnZwM1C8N4dp9u
wHhoUgNgcYMfGTpQU5iG/nzAtQy/nnzL6YAmzLEQcM2k+uCRiMnTJBj7sGOk
6MfKVpamOD2+1vmSalTyjpQ84jgxjoUjCf1XnUXM+xLk56CEbAVE7dybAbZe
+BzcK8jtBDnCzct16mpWGckIC0kkZcnFdSiGNv7zcGfjaVjUXNMw9I4LxUyU
rmAGFGywv8HZa9Nfew74Rbs6xDdoW7eQuNHQg3GCywmqU0VZhb7ttLIr7wPS
1t5Dd9T6mpW4NI6UdCigZdymNS7zkWNZSEufoZD5/8jzK8mTx0SRno8iyJXk
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
FFOuRb1p174RJq42OSsyLwVgJDqpTBM9AI1KoF2Jes7MqcDmVA4JymIH0JiS
Ii8JinS18tIHBeWgHUC3f3uO28r7pFF4l6i0OUeG+VbunUxo8ETJdbF4X/lK
pCmjg/BONQTFh/fxQnVdz5mYUW5pbiAUlKKsHU5o2tbtkiwSj0LGH7Bya78+
efDJb5svwoGFiHbVrBzsblGhGHe0uKts5SAwsXB5nckGQVG6QLxa05SDOUdG
m93AQfpENBLNkgtXXlNyyiYl8VSzdbwDJxb75AXupLqpeV+TxmHQkmW1C+nu
hJRL5WZUJ3l0LMjXkrvPKiJqMuP6d5wIJcqQqPS6yVWinN/gkumf4WyN+hcv
f+q8SbLj5OjX/Z9/dDsP7t+fPbh3cnTv+KS5d+9kdnL06N7DB49OHj2k///k
6D7/1/2Hnz98GP/fvYfH8d8fPMCv9Ddt59Hn+m9H1vbR8a/7PyH8oIWckOhG
KaUK5QVq3RRGJxf4ju+u6Verp+pWwrID1izV8SdHX28DVIMbQB5XJc1jGPSU
tdIIVb5GDsiZOLwyd0bPpVT0fZF8lboHx/kshD79EfvpMrKru8coxaO5Estq
wKZOiHgUHJmbse981cHZO7eG8pRTDGNMzAh7tBKF0LI5yEdeKQl04+Y/RTjO
hqYg+M106yzdnozNBX+JBnzXePZFoQlueOGPx87I9xTmjJPJaJZiM/UqxJ9O
T59MXp6eej/rcOWSPvvN09Pjydvjswc+eKQK9GrH/PAdyjZfMUKXHRgQnrvx
vc1rKHrQWGT0iiU5BNykBXTqnpMQwjoVBTDTCVAZkH6zqgixcFa4yDh51IUX
IXx6HUvqbDfVwmNAuq5ZBdl9mHMmkZ4kY9MOv+sgDHH1HyPCUnJE8lTLBtvh
hVbHuEgwh1A5YDBN5Tv9O1RmqH9ycxm+B9bOZGU2P6CA5sNlizBA41wScsCj
SllkpUsVBr/hkmA9evV/BldK+dQFclVZ6QgEn4qVKrL3WfWhbcWqFVSjvAyz
BINF1NOg0cWMIMCf2N0f44a/Zms7PlH2dAd1jWwaJiGQFG+F/rSc7zuSYe+Y
xh9WCJrjMjcILXJk9CaTvmubgwqCUlx/yMjmpBukIjagguNA93nzmmuAxfc9
N5TlHhu2N8BWmtjxymIbm3ct4WhtkDVuVgrnQ2Qoz/iS8GuzVyAk1yUUmCZD
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
/U2RcOa89eO43evXvArUO2xGmOBXIHCCvwnVIN1Yk/w63fbkUpKtIi12Ia33
VECRGsnxX3RSAkNflfoLREaauuuaq/ih+VhSDRuKYFP2PQPpV5dx6zXryTIe
Zc3WQQmTDZhPMNk6cwWhFoFssjJrQ+eHZoQosfSp977SHXkrnjdUhL7xnRkU
Qbhot7njs/vCI+2Vl8iY738eLp/xM86fOaM2uZ6q/3ftjCpbSEbROlNjKLDE
oyDpVleL+XzZnLfvuWrxSe96KaR91Fds28oXSWuNoxro6xDZNd8yCHKy6XD0
/uhYnBGhyBUUJpE+Ew00unO5WDacnZTKbeTcBee76eVKWwPZi2ycMmnEfN1e
A3iIDd1wsV2zamlY4D20Np0RHFY20RFkZBCgugc5ZCH9Ys4ttE8Tl7JnZTvD
TUUQk7jPo5JAQ1oDDnDe0KPoC5WrC4ChKawuMQcPS9PuyEY5uCrzRTIT1BsT
Awsu8bF1KF9yw9i9d28Fm9yjLhOvwq6GQymR92+udu32YLGBjINYPQkIJLPi
zMdDczJcOQBZ0ciGMULWoAEF2iqCIpdCAjgxW0l2M3YSdumKFwl/ghld2i95
9nRWlEAfKggagwksLZFO/Jrk8yPXSIoUM/USg11knw1ue+yYhORAu6UAb/8y
IwFZms2iSRxwBO1LvDMM/gwEgxKXpn4/lXeIDTBeQq+J9KdX+hA+fFjEK26i
KGcuhZfx/Ojr35LYt1rZRCBtl2aGes73JF+fsR8vNWIW9JIyNmu5ZuN23q7e
wFt38h/H9zXQta5omaYGHnhOtayUWMrXHNPKzJN/BzGBa1G/xUWIvO8lnO4y
HTQbdPZvNAU5u69ELuJGu8nIRwBHOg1eDNKGFZRSQv8CNrk6mJA5QREH0aew
DQVLniqWesUyCnI8a+Pyd/wCSPfkHhmYSZoiXQI6l6ykdqTpE9O2aiYZDxNy
b4e+7qq84UpdNvVbVdh81Q95UuBMjVoAgtlcNjHsDOnihb8RVSJqtoJuyzFP
7twGN4P/ellm1Pks9qvpbf3vruPso0QaMpLYzYfEhquqBX7pMjU1TARVu0bj
8/HUaX6lLIZszxvykcUZiRIolbLc7BcHe6U+ugeB4AOAGc1ySXXsaZcdIzIT
9vWcK0pfXI66ycbcJz0Wv5oaW94SJccrTRHE7fA0TW+T55SaNVFCexM0UUbY
6oOknSgaKWywUNiI9KySMEkwGPB7BNGcgi8fPmBqDcaGmFX8XuydLpNhta8W
KJr1LZTHOQwcZ9NIXqxk578Tm0InTfcHPhQSrLGOsHlfg0CO0q0TgEUvlyEt
uLyX0ifiYdV0wpYsimk/E8LedumwputMq/+b1itk69VryNOscB7RDVdPJYaw
IKUFNZPOsUsh3lPLm86yKNZX0WSiWGTV/0Qy5/RjkEQiIm3hdDVhPAzLXVmb
sM9Bv1ghpa4k7+1raYcnxSPYfocnx/lfTZYenhScv2Xx2uHJvf2kwOnS2+/4
dw9Cvmc5pGpg/4lLVAV944yn5kwKV3tJrscPBc5pKGlVF+gv/iAM1Dj7nykh
lcwvTgkatGQ99BUjb1yiDIyiRXP7aFzNwSEoUyzr9p5qI7YYrbd7R/c4VLm0
6zUlNzICbWVUTIVtIXFI0g1csoJXyiXDKJ5hyStKTbOSXjON0Y9N1OMkPjMa
i221oGsMsKXkhDpvuLvHe+xiTtczMt0+3KuOn5PQ5jZy38DLHdXLknZNt5UL
xySsF3wTeW1AjSLde7ZYR/2cS586rBBECS+23AOHmq01Uis7JZFlG8lWGlH6
St83yUyMgXFISd0klTCh2JbR4aT6wHmHl7vKI5bd5X4PSPnBhiOV6CJ2PGFu
aI9lwJDMnOzk/FRTvz814ZTCu8IjiT85Kw3kr+YZZc1cvF/zpl7K3SypqoMH
ii548e9YTivuH4G8SZEx7xJKqZZWls5mshXmy37hbXpfalL1jza++MdNuyaY
hjE7pi1lTALeSIfDTkflGX/tCHOBPx8xctzpt9W96RFfsFoJh5RC5NXVszfk
jSZHQkZxafaKQ7cdPrqSrIa6YZUlcgBrcQebGZdYpJGcnrVDJYNee+Nt1W/2
HnXuYil+Ez9qpasi/zP9TPkSU07EMRZAuFoGUPLHCZpYCGvZL6A47OJ/Ttjp
HDbT+Ztk0wcTEt91zlg5Dpd1QiqBayqeoahZRBU1s3ISDTfUg3drOgOrRJfb
riR7ixJBKH9z1vQ/FhAS3dTrTdn+jsptzi+GahKyAGEubjoFn3GYyIV/05RF
rxDqKFzXoxRMn9e0Jzl/E5IUbxfNO4FrZdB8YdQwB7jkqL5Mo/bGupv5i+1K
6mQgOpacf57NioMIZY01/voUKgwkK0unZrBNwhBddxkAYEYNSajV7fV1a3f0
LugLumZYbeLVuWqpBAJcQQdPsrRvoRM0IZuCG1AED6rDJ8+fPBtJIvjxMRjm
6E+u2wqTCYcOS7omNYsDnCe2AV/beQzjbHEe4EKJ7ovsrLmMBr+SGQYyHoBq
TkEQXfV8zR49tnZtU7ESuV4kySqgGNC9Tix9xkDJKfiO+trK49trmaVkHN0B
lEZ8JfuVtlvVSVIOP4N91/2FXz5rL86kI4Xy94KSqb0GeEcdljsMxvHqy57a
/Lj69LfVyb3qt5/+YjU3tsYiGG3Qzn5L8jZv6Vb119ZLWv9LfsgG9eD0e5wG
WQnRFmg9vi11H02BKehTEZAA/bkEK0gvSd4bUvJWwmVk2ReS2b6u36UsdMlw
1Hn9DeXqsD3JQdBppq1nOyZ5McvOZX7OVpMlxALDjqEaDBeKVw/BervSeq4J
Wp5LT6/qm1BVCfqQExCbWs6ieb+dUiN6caKbJD2qBfpklA8Cxs4hWcQSCWVY
yKnNy3GT0IulZqHuUNtCV3/ncoTj1XTDYdqFXZVI9+ekYKJjaEiD/fCBf5zI
OXFsUXopxCly214mvt3SCP1xMMi+Ot9VLq4m1r1YPhuo0Lxe8dAclqdpxHD/
2w1i+rm1IeSDFnyj6ZzNtlGtu5JLoF53rJEMXwZcIU5LGC8lroPfsUOo44Z3
2BMdvOmw3igoUPm+1xZsdsgAM5lkolgiTJPxl00sLbzCICWbLu6JxVI2oL5m
sTpPNd614iWt12wZOrW4mG1CJW/oLmKjMDO9rOhWQ0R53UeeEm32dAbJkemq
gANwXKmVcxC5q08pEnKOXBmVt2WoInc1r8U6/8W2n5OepXBVjvXKgLG2V0aE
hcZNoOnu0vx4OWxU97PtxDS/2FnnI4+BEIXqQphee+5YHqF5ON7Cyo9w0Dr9
XUUEIGyjxsdvt1L326i3J0LusVHLiZUFokG5Aj2KBFkQHHUOqFrrncikaSYz
MuQTxMipBpyavHKESMckXTPUsph+xIkYBwnWJDC+FBu9JQhZmV192cze9Hm3
pKawOpkeB6spZFUS45dkGAemKFhJpOs3Z1LImDKG09+ZqImreBYDmEsdeXno
R0k4k20ZsvYXbyvcR67p+CfJekDbXDAhW9ohvkj8jWaWT4YGlljJjLo7AB9V
C0lvCmJgce78JfPzz7vR/0pdZ0jC/pL3IStg8HgVnEYlRla+qVQKQAe6bWM+
a4AbLimkHsWrV8fpskYnUTQTYJwifgY9JgrB57V7bJh0CytIn+4Bei04e8SM
j6mXHdKOm4Aur4jHtsnwzgeUeC3vY/EWz0onA991nVJ9SJR2Wm4n3GmO1HY1
54ShoqPBTwaS5zKQRZT0pY77400ZorB5guhVEHdvOS5s6WWFnK1OrcRJzUpc
hwGAuVGxcyWJnNKbCk0NIYJrL95SAkoOHhLcJWI9jd+8uTqngnzk2dkhop49
N1mZgW5Cjspvh0lGmJTLj5+rRWX+EgWCzmV0UvdyZS9lG2c9YlBKc5KJngTh
8VZqh9IsFrjW+MX1OBSiJsmgfBKkdFu0VZFGHprWPEJsnACteLBMOal1gJZm
h2mCChIeDCL4VV4liHyLZSdk1HSQqNa7nNP+sj3jLx9SEs3ZHdYum4GRJYYX
A7gDNvYAqjORn4k4vapn6fqOukMhCRWaSfVP00CMOXnlNBkvT8LJgweCQXoX
13kO/MxWwZAYz06+038E7TQff/iF+gusOphVg5et1pj37wMTXQFdks78rjoW
Xh/gzDvnw++y9jDnaRYpyyXNnSAnNuuJ+PK+hzLw4RO+uKlijchsgAKR6wKU
dy+sb83ctrakQlISOPur5/A4UgKMVj/joPnaxIGWLSu5MeZYNp204fgNaZdz
mTWEzd6sgRZF2JCBHuS0AvZ7pV4Iv5K1lOw3moQqKpYkgqNuNnBamyq9DnqD
g0q1w23NwF8VpCqUvTyi1fBJFgqgWzyIq59XRfC1pXopGnjh3bq+nu5KHsu5
HfEsAgFZ8yl9TGTguiGdgrIVXMHYR2KcDLtkQRwJFqI477hpLbuJ0FiAr5Kq
t/UmExsnEMKIzLBIMhyX78++e/G9OFjiosb/fPJT8gzxZXDo9OQR5/LmugpN
T9l+tPLenknZu9s1sNRYMsRD+Jl8inYJ90RNsmK4jh0W3TBN/n7sUF8astHM
g4HVhPhxFET6wZIKw/HfQvssB5N1K8MXgatifdX0YLmP+XjKmVd/UP84qfK6
WA3AKfHtBBJuB2hD838hIT+40lCmptM9pa+f8NflrYHP/vTDjz6Ln7I846kq
zBH+fN8mGffz89YtMLVeWbo8/SZQDnHHx50ieybfFh6Cppx1q6SFuBfGOi0B
zRZBJD8DGkjgTH0FKegpcgSqqfFC6peyIAzUR+X4VOXGZ+cr844tymJ1YUic
Dq27DLnwULLK05UoaJdKuORfV2mn0AjtOa+ERuS0wgRhyCEf4ECyF8HMofRc
PJ44QNuVjCV54AB9XiQumX2QBABtwGl4qTAdtErCgDboxSX/7crtZHfbCvOP
5DsnQ4lSeIcSzCBSkmtHLmKqxaKoEx+MojHOHStzjHRVKbFZE6rqLG2tbzWp
t0hAM2Ud5023IDoadTyDqKIryhejRrolIX0z6eBPAZ6lLTVl0Qprm8u2Z1TP
GXv1z+VfL8iVunhLB4zxfKiKkDhn3za75syS8r72cQJOe9NcfQE7RSnpnSbh
MViggXxptaSupsirvtgj+U36q/OrxWOglqsCB203LeUxw2qzSh21Z/vRZSt9
fCwQiVyRTrlrTpfvO9v7Tsqwd7jdrFbYJGx301qRfdnC805HP+lU7F8mzMMF
YPkAjAK8O+x4SSXJ/6huoCEnu+UV8h7VeWPK03eoO15yCFuLDBcblVl21i6E
LVrGHoqQiYcfgEA7xDjRwe11xQnlPkoSOEoyMpCGBXE4RtNFYWey7G5Bm6Xj
9nqFTKkg6dmQrjwRuVwo6qjoRv+v7WL2RgpQeHGDvgPLtNuV2sqmxwalerSe
K886ZyGpdUPh5Dg3mQfIRyykNmHnXrGaS1r5UC58Lwi2o1wh/MIibj5OJnAS
BpN1R5Kn6eMtctSX/YCXEFRPeKtv+Srd4abb4S8/NruUjeqghpgFRlWn6BQG
dMxqmMF86nknGC59S/SPBAfHZ/AvUbt8ePTw4V8dcYGCi/KCI1zGirINKjm0
Qh5h6eHYp/j8aaMJP+lCZcRHVmK67evXgMdgouf47iUVUZKAlSAlybfASDfv
49+ukVOLP583N634ZrpZq4e+JGWzGfWZLlwKYgEeQDFfaxogBbS0Ht38a8b6
BEJXoipfNhZHLdkZvP4kUdJNHnkOUpWoGhgvpClgKaiFTA7cWb7Rq6iwhG4j
8FdaVSImKj2I5ml1qbApfuZbOEE0143vf3YEh3SbLNWSTaEMZO/QY/31k5rj
dJvEr61RR0UdSHh/lWK4OOxn0UK/NfwpQhr5I3OuvTJirBxdIgerSr7O5PVi
qccKa+jqC+B0FXQKitgjiIhcXRztLTjEvn3x3YtXp9Hm0jB6QOarZHDznZKg
rxIfNFFUCYSyufVcFc/1ml6gEs3DJ89PaT6eXtbx/xKpMqeVVe+a+s0K7Oz9
2g9O1AvzVmobpAS8jwXhLW2PgxGNajmq1nnhvI3dmfzL0+/GclGd/MfJ/ekD
nHYobLbfDutzuqhO7ldXcc/FXo2CwCqm+aWNI5PrpTDADd40zbUkEMZl2dzE
t9dEn0Z3Kzl1oqxjP9DJf0wePMJh2JkyFedwxDitwO/8yk3npy/b5c3xvaMH
pocNWaKCbk5+jFRwGLhjydWGaYNv+ZNKtMZUs/3DylSMvBTLCD9VGru7n4WO
aCt8pjco7Irn4E1TEIyM83SWruAGqbvQS3EV7Ew/+0yE0KshiU+8pfoF2UCm
72Ev41HOABXGSk58Vn7w+GYjUpdcXQumTHDaFkPt9TMjpERDyJkoBWTBNV6U
ehao1mq2pHry7ouKct+ZcdOYnNiBzn8gbSJl6PHyaV/Ifr4Si1fkrmqEeDlw
gnIH7Eb17f8GCcS/ET2VJIiIj5RKLuCoyMonDBKirpYWhxB04NOIDehIKCiz
aiQP1E23d38VkC0KsC8F57qbCsVJpIN9mEg124uJZjUV9w752NxEpv6irpdE
lOtwoVCJZwoLMeH3gfVWIs2s/FqxibCz364D+lq/0wjZmeLEOAs1iiG55lvH
qvU5vuC8XRXDmCZQbk9XhOajMHjdKPARoEAUTD92APFTI7pgmcsBG4/l7rAz
SMPTo4VZeHn6TdeD7RR2gMTSwLeYTI9H8SYDXJ2eU3bZ2IGlGEG3MXTebIlc
UYhUtrE8+Jb2/JfAc8tqJ1w2vj90oQ/+nZpRmG0DGvzj6s2KFKgk57rbPpCc
YHG3sNbRJXAR0vt4pLIP+1VwBE3TNQE27UWC6KBsraZynFsvm8RXYOAJCToP
vjQydbjwG6/PgWu59pzb3U3cyu+rQ2ZnESeC17fxsFNS9QNaTcgVXOKDWVEY
kQ4u/NtB/YZ3KdEAJWo0N4QRVbD57jJKeKtpGDN1HggVa6CIdddc1Sv9QcrF
dLh19ezr5xUAy6GDVZPqeCx5mPJooJqzu41gL45ZWcQW7fY1WaEAjsPuPTxR
CLnqo9uTj/dUv3kxXpbA9e3Fw+PikTxa2auQK4J5vYq4hL8o2/Tw/sAHHK7f
4f2Tso+JWjx7riity7EB37Zvmvnh/fu7n4kjjzdUfObB7me2fLQP7z/Mn+kt
4eH9R2Wv8ebZrD68/1lRJAgX1Nm8WS3o85/nv/oNfvjgqPdjIgQ+fFDUJaqA
0Cydw0fF64s4leSORDhA9crDR8flU8xmI1/5rNeIC07GVV0uKVv+8LNiigju
Mo4+KqPx2jj8vGjkagHgkjOzneK++3z3urvHyv3podfPVnE14iMne3fYGamK
2+5MMaDiC/eGF++6e3Om8PnxqT0bRcpu5vGpYh5W7Zk3mnWNDo/Lk1SUhuJw
P0tK6/7cenc9LVkglD+6prwu/Lj44mM2V6unohuxDpsRxqkmqdRnFFFg8Uiz
Flf7tctZdQIQYTGB/Q6WwlK/bRdzVBErilTFKFJRHHrRpcWffMvib4vGQJ4E
t7IEc0RAVUktKc2XYK/IDEoQtH2mBaBPKIqeQPJwgWeocnV9ALynqMqMg8gO
wt81igVCU/F9hZzzBQGGGytEW3QehB+tFbQbOH5E/ErsmzpFo0GzQgGhwYwh
DOZFgmAW+lyaiNQft8wZQHNhRFBSBIDIkgSZuglJePnnTeVxisuG/EspNQ3z
0rmz8KXcnymB9bmgctbraD9R0IzLBVFmxZi1gtCIoChDwPXMF4L33DlEBQHa
tYf6Oyjs30G8YFxKGqWh4YtRZz3Gm6FDll0qkpRE3aOzWin3Kic3GdrAO4Ep
Db39rYkLMoEJQnlwGtTpoHsln9jQm9ixYv8IVKqiJUKbZwSgpETzHgjmvma1
lMIXFxeEJdWuBOOznu9Yx2mJmhWbq9UNDu9xWTZtniarIjcO+8KTJeDFfCuo
b2pTDSwP7W8xfOBylI2FeWJzzPaagwEZnm8eIuMqStacuieCqwyVXEnJpEmC
13jgZMqmFeANEWCnWSYvPpJo6sUm4c42d1x97lm5HsEvv6BTzVs4BVrxX2nQ
SIKmsAu5oAI5v9r9hN/qDWoHPaDFuFY5xNtfT6q4+Qj+KCpmwRD2knsznUIn
JHOGM0hKwBmYG6OEMRM0+rtMXUqiDPudHRNxsn8PG3Cj8YFA9fpzQHkaVRYl
ha4Y3mu2UTslmj8rpsSWeFqcLoYYbi/IqynV24HxFjlowF3RGfGI5YhweNY3
2E5xZzcAReL5MRuYeRzgWBYUJL9lCkmc5aHFm25Rn0fBLziMnZ0eqc+/4PKr
qDG1N9qe9Vg88xV7iVTR4f9CnEEYSnSRU3D9pZXfwOt3w0h98bj8G4d2gqTA
dhKG1M0gQUk65ZCfYI5ylip51WIfKAdTfE2SN8d+E3X2XG94JsSfkdcCEmBo
0BPLLEUOOoivjV4y2r9pMl8f1Zfie4Bz6eyLPDqD9aOIUZB7W/H0ff6i76Y5
X4Y6EjRKrAKvXWfOtpuyOALVyyyxOrfnfUxszJsRguNyDfi6g10m+oEUp/Rx
/w6UT3dukew68Qbz0Chs1tSK202vD7sBFZBJXxOvoPm2nXJOqkHUgSTr67bu
q4/kJ24ZowlpNE6bKx+kfietswDUc5c8OvwT5YUo7Rmviqg8SyFLyAovOEyp
ihMNB9Hcd82S4YPi/2y9A60bAzlvu8KBFk8Ng99RNjDvJbuQ6Q7e5STjrL/h
RbCa8qjrALDyop7RlUKzumxfvyaJqxq4JuqmragO9k7C6qnSzTv5BK8ZM/FF
tAN6vhaulc3saRMF4nxiAUhVqT0AN0KOa65A9xKqAfDWZjObjqDKmfLmtWbN
icWxP6cmJA1tzslKV1dxCWY5Tzl1E7Tama4TJyF3EuVGDnRUzplgKLqUjGa6
q4Uz2RHJlFIJu0qTfsvqs9jLcwrYulQeBlHjxCCVABxYpopGNTdxm5CityIa
UgYtHgehHrNu47wrrE6OqcDGVALpGZzT22c0VDvmdCwudZZeCS66ASLier1F
ek6l15PkmE5DKPxxoMQbLCP2G6OS5LC5uXUT1xmlnRaFjuz91IYMJJmV2wEI
j1CxxEn8aQ5H8jCPmTvUT8QnR///TXHPpRkn+Ud/Lx/0njjIb+kBSlNB6iOf
Rd05WjabD9yqwO/GTxLUVycejVJ9kZ2EppHIcy0K2NvYkZqjKYU7DFskY9oG
3xImwNAJKN1YyaWk0/MFGwOVgjWKQ51Qy0n2kMQb9NwOfhCpZ97nxwHjEAbc
uoMNyG90i4K2g3BX18X74vLtvU+2pvxWsd6GfCgjaISTv2hLLq3Y1mnavYdx
ABqrHjGZZ7wFYKmvHF6zOk08C9Qaq89WMq2/LXX8bs/djBFIlfuqvNxR7yWL
geGspJzRYmKVdBctdNNCWpvY43Q5Fc4tMGSZYhWJUqB7T/aVBIkonFJrcfu7
BYYuncGWULc4hsCBFr8UUSgvoOlKVrf8wUsrLjLsTSGeoXXjqXOJjtTbp/mK
z6wgpEJBY8sqGNRa+YX+Hq9XyoxQhYnVlGhxgj5pdtnSBsvc+TtGFdsFiV9v
FJwLhhZw1NZxIt8BioLT0uYZtUoUtcgiAGGDgOhp7ww+Cgq9jyKgT4kYzA2P
n0oTBTnM2wpncqsehQxmTMpS2PrNa0Ys5Ob3YCHBB3eYZkRrAykpkbcd7bl2
z7b7/++WyEI1WALHeMi88cALgeE+KhLAkjOWw+7euOakDr4heFpM8KokrpOw
pnXCfmQfZ48dqOK7nHbnOXjpY9fLOJLgCJQgEWxUUb0gfHUM6c5qQLq1FrSX
U4QGmx4OeZXzU9Xfd+GUjaL8G4pb4dZVvXIVpRuzxA9dvnzK/BGB37XSpAaz
GLm+2VWYcYhDXGedv2MFKZlZtCsphWbSsyIvSjmmQx5YU+2f/yaWQ+a9t/mV
sybrvEppCSEF/eI0IomG/Qmxd0zTMau9wjqKEu0N3De0zyXBQjcRs4Kin0MR
PrrpgFJ4k8gdF4kPENqfRcRzLw2AzXl/0KSj7EWjSbL6//TjV08fPTh6xOwP
vfCg+7iB4FUFQVYf4loESEIHjF9P+cEKrHtFLrJNy8QFMHS1MKxFXRIXCelZ
wIHp6appYxR6z/4R5N6N/gByaMPUVqVXUcscgu1lPC4C7uGQAUQosTo4YEDq
wyiMqgQYxZJZUS/j0Q4p/dBdapzCvobnhefJCOhzJAMHS4PZKQK2bmaUjAAH
FhXh2GbNe4AxcCjW5wHi9SpBqGcnrnq7qPGfB1LoRk8fZLOYKhApR5z33i3R
YtfbRI3YrPzexzl2uvoPT09fpnMCiVj2WAaaeqwfReLx7Z0eiljvmleS9ZRc
awleV1Jcw3VOKqODNzc8kXyVwLdKGUcflFz5FNOL//bDy1cvfvj+ybePrScc
e2OpnQrXNJaUXZ4HQVOriBlj3SBFJ6XS6aznXPdhKDq/a0ZMGHmdrTchK9Zr
3NBFEzYBvyPWf9tnYzMH/j2oBPb2mbu2PH9pPX9LvSUKnYpJdhxfUIogY1+Z
OiWCKdtFj+4dHWMXaZCUiC04jVZzAoeoLPpJ2buYKiit+Gmm3zwFy58Ukxgt
VJJQKfcQqE7KTCCly0JxJulrSJ9nRxBuzRlS7tjDyphkpJEJyR/9j9I7C5LQ
BjqA97TS4ZgnYBnFqnZgJB3zcsFb6rtkxM1pKPDgw6Hrw41eybBnQ3pWoZAk
NSA+QdFIXg0rPMrIYshvGuV3KeuRAYHQaKqy7VHFEUJ/WAgkFPFJ5fOsvm9M
mKDzEO0LdnGwl3AAnXJvMO4uEiQxF6qBOCXLarvkMohdc87qiiAJY8zM6h6H
MONogqN5DwkztE4+aOoKPSSV5p89/Pzjx8wFDatC3wz6GvbDfj75U2aPr/Bf
Yy56pXqtbyWj0cGQuJftta/fzC/kVXmDU3z+DdaQ/VqlMp9GOO4Hs4AyUMvq
S2kzJQIJtOWS2vz9o+n05MGDf46PHWyW3fG96qD6HY+j94LUrf7+yF6RgfKT
H1NPJUUJmEzNhIdZTpKwxXS7ZmdwandjTUWrz87M5Ou6uzy0D8QJjv8twCUj
XkdsNfqzLThv1yjTinZsb9mGZ0idbrtgh1EUPAknzn0JWfmbTqFy9I8rxTHX
/lm7LYWvm1UCsaLIkQWFelpb523BXNRYGJHKrqn/Ss8BN8/YbK+MWjqVazCq
WOfEVOyHgL8j8pQXDssuIOA/F8E6OAACwDVVNwBEo7e2UuWJf/c7W2NFhlLO
PBbL8OT06YsXUn4uTH7z1g2k4fSYBeK13//xW8y0RZfhHCGbn42+tPJo6obP
A4A/Fdfm+IScTiRgiKjbbL965cOPcRes/ZLlbbNBBSZbgdbg0Vo8zIcoJXMF
BW4UN2dYUopJCenbgoSsYuPEgX0zSAZK6eO53EbGQxiUmtkZTVPC958kVMVF
3JBxCuh2KYirUbUrFQOLTvLQ8/YT/ES91BqUjSvakbdRsGPJhC+++a5Kj8aP
BHmMTRzAGEi41yHRpygg+8niHITe3QVOJbqcDikdrpkgV3Geq8Dxv0mzWoN1
k0sB09SKmkcIGFz6dnZVR811feYrJ9SstXKgdOuN4vcPnz8dWR75XOfg8MOH
Zja/1D5N+M85PN1I0PsF8wlheKpRLW7MTq5T8n29M9NvvqijznXFt9k06PzJ
n8fiUdPoJZOEIUEB1U8ruUyjbnrDzFR+namddU1xW+BA6tqdEnFBvX7Nh9iU
Fao65eCcLnf/GQJAGRu5uIpQ8YREjWsDvAxtg8w5PX3yqMKWMK1u7HC2z3/T
VbLh7dOLVBdktgzpeVdiEUf7IyqFX8FQZu4LnjOwOWlrIsn1MLWUWekwPJKJ
cNbQa2eif8n2mcZuHhwduJiQx9qgm2WisD8cMVPCk6lTTrJ/jvp/GoBrBA4M
HYvJP1f5wn6ZDe9Ojf1uQv/8c3H3Twdu7p8Hb/EDuknYAXkw1P6Ot0guy1t3
/9TB6K6PfimNE1bcr5qG6mBWGffy3bvqHCe/oM979tqvHAQVel1XLPz+p0fB
3Y/fIz/aOpe4Ozaz/tPvuEjzg/GO1R9qUCV2nInidKREsH/ACaGtcdn9qr0x
nU6dm+6X75TkMf+H7pbuf21c4u+7+7j+B7YP/+/RwPb5Dlv5H7V36utfO8fi
I9LQ0C/fP953lc/02d2uon176H9zfLKP/gfH9yvl6a8a3V1l6y8a0BqcDrsG
NPxPPiBxxe4Z0PA/X+5U0J3tX5g2laLPOocp2w2sRc8RZBHNNCtaUMWazDDU
wxD5RkMB/OsbyxGdqUcIAW52NQX9grUNbZVT0tSgTTa9NKF20poJxQWpTkvx
WT55P2eX8lSTzSptFSy5DiiZAqCw6XLzkBLjAfSeXIjmxVBNuhsH8Hw64+9K
ZxN2W10dTX58BTAgISzNP0JE4fHzms4ArnomoJ5tnBO1e8xxqWNqbAK3t7YY
5Nvrphl8k+sDEiqK6u7IGdH8KAcTdDQxDpTEHR9K5VzdPpluzjB14gzts7Ob
Ox6Jt92bxfU1EGCpWroD98LiQt2p7OeAlZ0ZHYwVKrg4wV8xh0fj6mjEVgt7
mMzZruaSqLWdeNk26qGgVchUcQZdkhA1ivoPOcqNKAjZ4JQ1s91oen60xkdw
PXnVXCBvDThmVzu1FsLpk4GPsa4VUy2pfW1nZCSkV7Y5xdlCT9Kuxm7cnse5
2mx1EiiooFgZNNEW8aUzNvXIPObFNvrTfB3EKe+hM4Vzntp1MRhqR6BfGH9I
vC0i77hUsZEYBvuOAnUTS4CaK+tAbPkxkxjrLlFwN6A3oakNc8qxE07aQ3eg
WOuU5oFasbQBRhYbnhL6y6yxAjEZqlSIMOLAeeGFKo4Xuba4vk26gISm2pxA
qdyvoez2ucQHwICMch0JVZyK0Kw+fLKV3yYO0L/7KF3NHaJZ1SJj3RiULqaV
qwGxeeMsCdoQ0gc1jukZBbZWk5JImnve15CRDnicInF8ruh85diRJW+BzhWF
GJ0jQdStT29XS77/3TF7rn7BKz3q+Sxzf8NUgROjedxcNnm/+8z1tzEu0ExM
3Ezs7l02KQiBmOfjlllIUYZ+kGHfq/uUlwMdd1xZ2ASDoQbsR57/O64YwN42
HjclZDMMP3FxmMq6QzlQxMe3aX7Z8ve+nq2vnEw9kBTBe5rWlBfUPe8DrSC7
MGIl8/YlvyO7bFm8wM/4JAOlwR+E1lYJiTy7QJNKcfhXdiTbJ+P7r3qpiuQ+
LZ/7hYNA8gE8lFlAVToBaeF36l84i/Ovjnfmyz2hr4P4gOyu+G8KrzzU0uJt
tb+lxduDiltKOM2yS/9d24pbJqoaTQIwRgkmikBfJeemuLr1SlJ0dwo4Lbrc
9cyJI+J4Dj8rDjMQ+H/W9n4OP38xcf/8bP8S32CF0QP7/rzPuUWNOd+M/vNz
ZWPc6RHAqz0E4ezVvWfn54RRtGf70GyJDPPo+cEVmMq0sELbaRUQ11PS3xae
YNclGbShLABikUGpSNeAq0tweiM5yurgOuWQhHzaHep42d4WnaCGPqlgrMXL
8CukDj+LitiimZA9d1WvGH3vgh/g3OLXUdG9pvCbizIQIWj+3ocP//Ts60cP
v3z2w4vp8dH0+Pjo809fvXg1Pf780cP4hwcPHt777OPHTLtlcGZGbp/KFWMp
esDo/78jvkpWlDujJStAZhetHul5Qr5IQdvF6wmdhZori2AGCqa2A2pnSEEc
nATzTcXiVwpv4D+RA6SHPCIkh4c6axGdOksAOG/fanTTmRQZcjqrwpIpsou5
z/CSrmKDcWRMHIEBTXlZny+XVIc4q55u4/UxuK6x19cnDx6uj8f413uf3V8f
C0Xv7PrByTH98Pzps68rt2k6ChlrBDqVNNBbNGyvEORJGvlMuRZH4N6zpc8B
rD58ePH8+fPjew/vxd2SVLjnT795cjp59vWxYSSr5Wr5c1dE/9CVgTaL8R5G
gTsSpjz1HuRryQv8fjJr0R1UAlzI1+Oc5E83OtszzDbTtawbhuyl26lmnA6A
BPNW6luW/te422k70egrGr5AU7XL9vXNKNQWX4tb/qvnJz+cvmRDkA/xc9Yq
aAJ/QJun3OZTHB1kIr5UrM8xEsCxA+sE34uosWUk4eQ/rrJtFowOst93z+Ug
Jf6wDg6LAbvUIMtPlKyNOg54dkmZ/pRILkSVag9U1wthURbnD1aEIGri7+1N
qvkgdOYN6bxRQsWGg2ZuAblN7XjjvOacLtabJRhIk0Ax/NeBs4aRY3CBShOS
XDAZ2QxhG2c6CgGdcdlMWnycsVGwVnO9PV8KcwqVhGyF3lisFMj256vN+mZK
SoS6SjyLdCc5u0zwIDily5t0TminxjmsLaNLrxmf7ZB8ZxUHyxTvVOpaE0sk
pXlyc1CeRglPSLEKZEjn0SDEKaBsRby39SeJDwi3MdXZGDhXi+RV+EXDo0z1
nQPcOxDK2f9N51bmDgMo6LWw2uv6nUTDV62rHhNA259OHjw4/hwf/en+/c92
mgKaZojVAPuP3iUBJiplgD66T1cpOR5EqPIrucTP53U6DKIOwi5SWDZGtqg6
T3F/DK6SwbyzoonKXRSwExdB2+N+DMoY87BS5kceC1BzbEKoxoimAQijcGaR
2Crr8w30OJfEnZAIaeU43zI4NN63SuMu0pm0c4/KzrH+9Vz8710IXP/w4NHR
g7gMigdZapDqr+8UjQOSM8p0A6kkhI7rrtnOW8kYTXfVyx+/GokuYglW8XJZ
1jNR+eMDvNfIjqAhG2RMyvvxSgbvWO0T17FcxNZIoQCbuTqBxdi3J41RNjfo
SVWP/Z/orBwuOWFQnNZnwpbtTKG9tv1wEqK0eXAw2mvfa1/FsD/M+jDK7bHA
6ZopFcQx4+2LYUtRTxj+dRfThx7mHW0yfFJQHhzy85XQyR4hl5dwXycXKSGW
Nt2WK1m7BklCWrjHLHSyDxgmSJ5nCw5QHeGJkaC5zaJ+V3ZK+lZ+fP70h+++
e/79s+fPHvOVitL9LvjhA8eM1D3c/cjdYg2PupQ3KRn36+Y1MY7Bs+oy/KlK
bhH7A8wJDhSsWgu+uIKHsSZtpg1BP7vEyCnpSAzETbXQgd8E4UVqUfZ+OiUq
8PRLOoira+aN5sBN4kzyKFV7NHxdHt+MZpLFgxeS0zwlW5GUPO8EXpsZjp50
xjig0sMuOAFZWEUTdKl1tDbrGlWQNFtKmhccVI+kYt/5ags4iyw90nHcGD6/
aH1JIkKFY2Ie/ooOOvgAmluAPE615MRUKnzYdsySltrOIUNCnbbFCq5xG6wz
RTvDsjLHuZTekqubOhY32Y8Jkcso3SQHz/dA4xkOToQPoZClJdJj3B9ccMEn
jwb9JCrFkx9J1N9Eg55gbicQ/DfEXgj1VZ3V2MTrzQYgU/EioreJ154enhzF
HyhxPtN7FUZlsbrkXcQPhwSV0ZVyoEqhFcpYTUENCtzVm46DCkGo0kUPh7b7
vRCpMV4HV9G0FZMj1PJl+RGlNnS9R8ttK/KODhTpdEuEW+OceeG0s3kmuJ6/
jfNWMxmfxGu4qvG8uazfLpDxRydnzbXRupYS+XFIaa4m4nrRKOyBZ8uoEngz
TjtPi0HhcSkcf44R8d6jrl/NEq1JE9pd2nfr9nzbcdWoxHq4RJeHKyXYKGaS
Gk0xnHmEUoLWTauv23fkshrr3prPi6To2MJ8caXsK2L+yRx0N/FauRKfQ4p/
CkNm9XrZnguEowMr0HcB7V+duirdMUPJ5I1zTa9N8d/aVWO15Qw5zvKSfqie
JHBQyi9WzIAFrQAe+IOEguuVbQnA5euGIjnkMhcYuZ/uHJoGZu7eMCkaOB6w
r0kyPcGTf4hCdVM9EVwwepy6w2gErjM815y6Hxf0D35bof/r5j8J5gGP6Yfh
yZfaOtAnacqwOQyVKSaN7DyK7jedZNb6ok/M2BMXFvfxSrOmNwUqKcTrH5gh
J+4/AmmT/cS2GPbU2NwBlMOwTYYljoEbqawvapvjoTROQq4+BZUCThKffaXx
4/Avaz5kbMChzYh3bfV6G1WR+KsUOnC8X+UBrlhdhDjtVy0VuRKlYELUL4Ck
cN4YmrO9CCKMmGhjDEwS1eY4ROxou+I9MS9K6bLIWxQu5JSMV0U8zjTzTCtT
CW4enMfdpm2janKpJ5QBWpgs3LAE4gEVqSo5D4xqtGxv+AbCitqJlPT8jRsZ
u1A4BYWqUMKKsRjsC+NUEqtnCzCjOPV8ZFdxOszQMj6dLmhhJJfsLd2EMVUS
WE2gCCDnA4WirOHx4YFcgZ02b5orUJxIeJrXQqmzVVqpSc+eG8EMxS7i59nq
Y/9IXW4xkSqc8WKjp1ml+cgRy+L/XPEl5xSAqJ+3i41i24I6NQhlS+pBdbhZ
XOHaEoAqEt/tls4zU7c07y+jzFfYK/Yikb6eFWVm1/cIS0hhNDkk5MB7rcnv
UXJv1+wYiUtOO+km8KG4rm+WbT3Xt3RKeS1q7g7hktgQYs+Nz00OMS1ewCfk
tNDtoFn1DLtbHZ4zLV3chkTkQ8zcfAHOK7lO2FUmDlpHOLVu4hat5c5g5/3F
ujY310igRPlUy1G3a5qqyPlPjo3KHXsxQIQMiV7pL5bsJ/shGEQCj7Czkgw7
ciRNmF8xSSOZYfJgE7ULKlPi3UyK9RIyVD3b2PYQzqRbkKkxMTgvdy11Al33
nww8SZKJtCzU/oPS78bYeEgQiSKdAFJFQQZICMFookzKustBlgM/V6SFV8XY
D9wAcZ7itgblm8OkfWwiQCQr73FeFp1kpUGBMXfR1EoQwtuMECmHbgNlt7AL
oWQPS6wrSGehAhZcYDJBmcmc/M/FT3QzdRpy7zL5dVO9WazmvFu81mhaHZnM
tIWSS4qVu65lLFentZMJEE+RstuexkVdNpM/kkeadRyZDbTUwQN9taMJoTku
VFU604GZZxomC/esLSJUYc7xjdgvjuG2kKRo10mNDUsuXUZPXCJrjDy+tJm5
gl+UtMecvQA4xdiBIB+2sKc1VHeS1MNZdi8EQkygMfitRRdy012VJ4gDKDUX
KL2jvYJoYKEpGaiwqpBkuTCk/PJikuDRSEOL9wDtThhq2kkKw46tLjzPt2KW
HJh1pEXNOVYbRyPqlofQdaVqgX0ceLtZ/WcLTnlQjMJrM7sR0yFugTh0ZCUy
ZA5qk2i0TtWhnlES2Va4UgQgQk12NdIlWDz1DOyEnWKMeFYnqaoWTzbvHZsN
hVuSVVi1cxaMzertIgoXVUQILFDVeErljPcZPIUiIsbBOArjSq05jBsvjHi+
q8to3lVco99eeL5XGhWryX5aBar46roWnG4sa2Ifk1Unlp/l4g1l7+YjonTN
nNaIObXsu6ShIJtuQo/PrYEcfcNyZyVt2CygTbsGVIt4E1Bxz6u3EMppwDdS
uHjD9gCWYaANschMCoTMBM7AEPSqsgyd0BlUcJQ5fL0I/MCPeiMFYpx27vVB
ycMlo5I2UhPKK5WYs50qeYSJWNVbV4eG8u8drB4YQVGS4lQHTjwdubsvmW1x
La3PEETZbYm93bH2S2D6r9ekv8rCgM5IjDEVJDNkAbGxJePKGpQCXs2LJMUo
/i12+x16pw7dg/b8YtvBe3bGG+kM7K2xC05nCk4IrX5DTggWxJKAy+D9aJy1
XWPZSPcKHduxekP9DPe4nUWMs5ElVMudTrHk9mYBmfDhQ6qvRdafoZUgIrNR
qZZ8n8EwcQl1Pa7jGSaoxBbZaN6kGkVpYTs9DhdyGaTJaJy6xLMyhrBHnofI
e+rDca76JZGvnaukc7x6C1PltFGzjfXm42AQpEkjPbtk7L8W9GY1IwuW4Eh0
hUXbMOBexlYjLZ+3O8JgXZH3cyunVGjXovO6laObyrkN8NlVO9il/9fcuze3
bWX7gv/jU2DUVRPpNEnrbTtOdyRLsq3280pO0n3cHhVIQhIiklARpGTFcdX9
GvP15pPc9d5rAyCl5Jw7M6l7T8vExsZ+rudvreWGQpMsZtZdsDDSE6Qycjz8
qSKOU1F8vcI42recVtU2Tg+xatuYLohS+IaDTNxLvsohA9CAygMQKAEJMydE
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
n0KboMnm0rN+hn6MeXWmGFt4YWv5CwiL4eJtfiDb7WcPXTWa1xRaLTnnioGC
VruNxfe0X4/N6kadFNVYO1FHB6xbzngCLeWCLc8aD11X4vyUbuMvKmEP1dSV
Jy2h0QpqiuFMDXmJow2p8Wpt6yWejZ/V9px757iE5kdq+91EYa3WNreBo1rd
afteO0RrdbfeWROutfpk4TlZrR95mXeEnAnncnP5gYOBrdbPu1/IM8xA4rpb
Qst5dVcbR5y3bMHwamtxLlpSg8kGkNrqZm0MHq0GF2B76ZWIcIHL70MMIRxX
FySHPcNHIDMFuw1JZ03JaXNbJafU/wevogNaEvgw0j5+mcOy0lX7fk+/vRYP
kFY3s7JtvGHfh2fO4vqs9T2/0e49Z4Nsf69x/Pnl2GC06NXmYf8+bTNItr/f
cn7x402r5L2vuwn71+//LJ/z72vvsemg/W091d/Hz9Qk0P5SkwrR63XgaPvL
4bpE33yd3/1Ev0ZvfXvWcj+EiP+FklUoeqMppYuOUFM6rENRFE4oqurT1ubn
Z9GbTwRETxj6T/AUH8ANOcDDUF5Ms+vLYiCZdPhagJYPt2XZtV2g/zQVH/7U
At2HRyzhYG26j3SrO1QMf1jv9bY2/x4rkGF2qer4BIr/YbPX2/y/Nna7tRfi
zr0yIKXeftjAF590N+L37No4VOIPT+Qbru23mCj8/3Edz/LBZflHFrNFK1+4
fjjs+xdut23hIqq4bOFiELN1e9awIKgWbS2QlOLMmx+3PpepuS6gH+WmdNl/
sGMnLw5STAxT27Fx9uVMTS9Sp5qU7z/WiwnVLGLsLBvOkl5qySxINV/ey/b2
081O+vjpxtN6Xy1gXhJ92vv69CnCi37+XGfxFWgO09k1iUSL5+aHtvN4d7vW
yyXw0Fk/z2YkNj2ol92dzfVaL145oJJkpiKcOZWNhC3t5fHW+kbLAsXqPSXl
hJ0cwyyfRMPTsTzdrV94kUWiXuDgr248bc5Px7K5U5+RHOVGL5st+7+4FzHG
kRlm+dqGXnaf7NRJmBlN7rtU1MtPldTzmlBYoMEWa0OL0O9kj1nW6X2n0Wki
aLq5b4z3dddE1ZOl5892x3B9MgQtHdkDu2uPEyAb0p/pLuzv7n/f/i6IPyAT
1Z8Yo4tZIFPWf3UFmzEPZAP7k90tjJMg29kf7s7CRMi4tmyqD+pudXdnZ8vr
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

-->

</rfc>

